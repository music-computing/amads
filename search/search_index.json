{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"Algorithms for Music Analysis and Data Science (AMADS) <p>This repository collects and organises algorithms for music analysis and data science. If you are interested in participating, please get in touch with Mark Gotham or Roger Dannenberg.</p> <p>Much functionality in this package still remains to be tested/implemented/documented. Use at your own risk!</p> <ul> <li>For package functions, see the API Reference</li> <li>For motivation and background, please see the draft paper</li> <li>For information for developers, see Developer Notes</li> <li>For installation, see below and Installation</li> </ul>"},{"location":"#installation","title":"Installation","text":"<p>To use AMADS we recommend cloning the repository and installing it in editable mode. So:</p> <pre><code>cd ~/Documents  # or wherever you want to put the package\ngit clone https://github.com/music-computing/amads.git\npip install -e amads\n</code></pre>"},{"location":"#design-principles","title":"Design principles","text":"<ol> <li>We opt to create one repository, in one langauge, rather than attempting to list / direct to others.<ul> <li>It makes sense to have a single reference language for interoperability, comparison and more.</li> <li>The sources are far-flung, in many code languages, and not interoperable.</li> <li>That said, we do use AMADS as a kind of meta-package to connect    to external well-maintained libraries (including those not in    Python) when this makes the implementation substantially easier.</li> </ul> </li> <li>The language is Python, for all the usual reasons, chief among them    being its popularity.<ul> <li>some experienced programmers may find that a rather shallow reason,</li> <li>but commitment to access and interoperability makes a language's existing popularity critically important.</li> <li>E.g., we have in mind the student of music who gets that computing will open things up for them, but who also wants the time they invest in learning the ropes to be transferable in case they ever want or need to move away from music computing (imagine!).</li> </ul> </li> <li>Algorithms are:<ul> <li>linked to a credible publication or other demonstrable take-up by the community,</li> <li>implemented here as exactly as reference to the source allows (usually from scratch), or with clear commentary on any changes,</li> <li>open-source, </li> <li>well documented.</li> </ul> </li> </ol>"},{"location":"#uses","title":"Uses","text":"<p>We welcome all and any use cases. Among them, those we have had in mind during the development include:</p> <ul> <li>researchers using existing algorithms \u201coff the shelf\u201d for specific tasks, including comparison with a new approach,</li> <li>students learning a standard algorithm by implementing it from scratch and comparing the output with a reference implementation,</li> <li>those considering entry into the field to browse all this casually.</li> </ul>"},{"location":"#contributions","title":"Contributions","text":"<p>... are welcome!</p> <p>Please pitch in relevant material, making sure to include any relevant citation. Equally, please feel free to add issues (or write directly) to propose algorithms you'd like to see us implement and include here.</p>"},{"location":"core/","title":"Overview","text":""},{"location":"core/#core-data-structures","title":"Core Data Structures","text":"<p>In brief: The basic hierarchy of a score is shown here. Each level of this hierarchy can contain 0 or more instances of the next level. There are two score representations: a full score retains most of the structure of Western classical notation, while a flat score is a more abstracted representation emphasizing notes.</p> <p>See also Design Considerations for more in-depth coverage and rationale.</p>"},{"location":"core/#full-scores","title":"Full Scores","text":"<p>A \"full\" score looks like this:</p> Score - one per musical work or movement  Part - one per instrument  Staff - usually 1, but e.g. 2 for grand staff Measure - one for each measure. Each measure can contain multiple instances of the following:  Note Rest Chord Note - one for each note of the chord Clef KeySignature"},{"location":"core/#flat-scores","title":"Flat Scores","text":"<p>A \u201cflat\u201d score looks like this:</p> Score - one per musical work or movement Part - one per instrument Note - no other instances allowed, no ties"},{"location":"core/#well-formed-scores","title":"Well-Formed Scores","text":"<p>Score structure is not enforced (it is up to the developer), but AMADS functions expect well-formed scores in either of the full score or the flat score forms shown above.</p> <p>A well-formed score will have events belonging to a parent (EventGroup) in time order.</p> <p>Rests objects are created when scores are read from MusicXML, but MIDI has no representation for rests and the MIDI file reader does not insert Rest objects. Generally, you should ignore Rests since Notes all have <code>onset</code>s. Rests are not needed for timing.</p>"},{"location":"core/#tempo-time-duration","title":"Tempo, Time, Duration","text":"<p>Time is usually measured in quarters. (\u201cBeat\u201d is avioded since it is often ambiguous -- how many beats per measure are in 6/8 time?) Time can also be measured in real-time units of seconds.</p> <p>Tempo is indicated at the score level as a single mapping between seconds and quarters.</p> <p>You can convert every time and duration in an entire score from quarters to seconds (and vice versa), allowing you to work in musical time or real time. (See convert_to_seconds or  convert_to_quarters.)</p>"},{"location":"core/#events-and-eventgroups","title":"Events and EventGroups","text":"<p>To implement this hierarchical representation, we have an abstract superclass, amads.core.basics.Event. Every Event has the following attributes:</p> <ul> <li><code>onset</code> (float) - the time of the event</li> <li><code>duration</code> (float) - the duration (in beats or seconds) of the event</li> <li><code>parent</code> (EventGroup) - the object containing this event</li> <li><code>info</code> (Dictionary) - with (optional) additional information</li> </ul> <p>Anything that can be a <code>parent</code> is an <code>EventGroup</code> (<code>amads.core.basics.EventGroup</code>).  EventGroups including Part, Staff, Measure and Chord are also children, EventGroup inherits from Event. Everything is an Event! But not every Event is an EventGroup.</p>"},{"location":"core/#onset-times","title":"Onset Times","text":"<p>Onset times (as either quarters or seconds) are zero-based and absolute. Two measures of quarter notes in 4/4 time will have <code>onsets</code> of 0, 1, 2, 3, 4, 5, 6, 7. Note that the downbeat is not 1, and the first beat of the second measure is 4, not 0 or 1.</p> <p>Finally, <code>onset</code> can be None during the construction of a Score. If the <code>onset</code> is None and a Note (Event) is appended to the Events in a Measure (EventGroup), the <code>onset</code> of the Note is set so that the Events are sequential in time. This can be a convenience when writing expressions like <code>Measure(Note(), Note(), Rest(), Note())</code>, but we recommend that you always specify onset times rather than relying on constructors to infer onset times.</p>"},{"location":"core/#the-note-class","title":"The Note Class","text":"<p>The most important class is <code>amads.core.basics.Note</code>. In addition to <code>onset</code>, <code>duration</code> and <code>parent</code>, inherited from <code>Event</code>, a <code>Note</code> has</p> <ul> <li><code>pitch</code> (Pitch) - a pitch object (see below)</li> <li><code>dynamic</code> (optional int or str) - dynamic (loudness) level</li> <li><code>lyric</code> (optional str) - lyric text</li> <li><code>tie</code> (optional Note) - the Note this Note is tied to, if any</li> </ul>"},{"location":"core/#pitches","title":"Pitches","text":"<p>Pitches are complex enough to get their own class (an integer will not do). The pitch class has these attributes:</p> <ul> <li><code>key_num</code> (float) - MIDI-like key number, e.g. C4 = 60</li> <li><code>alt</code> (float) - alteration, e.g. one flat = -1</li> </ul> <p>Notice that you can always ignore <code>alt</code> and just use <code>key_num</code>, but if you care about note spelling, you will need <code>alt</code>.</p> <p>Notice also that both <code>key_num</code> and <code>alt</code> are floats, so you can express quarter tones (a quarter tone above C4 is represented by 60.5), and the <code>alt</code> would be 0.5 (a quarter tone sharp).</p> <p>The Pitch class has a wealth of properties to obtain the name as a string, the octave, pitch class, and others.</p>"},{"location":"core/#immutable-scores-mostly","title":"Immutable Scores (Mostly)","text":"<p>In general, AMADS Scores are immutable, which means you cannot (or should not) change them. When you need changes (consider simple operations like time-stretching a score or transposing or removing all but one instrument), AMADS almost always returns a copy, leaving the original intact. The goal is to avoid surprising side effects when the same score is passed through different operations and analyses.</p> <p>There are important exceptions. Some examples:</p> <ul> <li><code>Score.convert_to_seconds</code> or     <code>Score.convert_to_quarters</code> change the score (but either operation     can be undone by calling the other),</li> <li>it is permissible to \u201cannotate\u201d a score by adding new information,     e.g., setting new attributes to an Event's <code>info</code>.</li> <li>during construction, when there is only one reference to a Score, it     is normal to modify the score by inserting new events.</li> </ul> <p>You should never modify a Pitch. Always construct a new one, because when Notes are copied, the new Note shares the original Note's Pitch object. Assigning to <code>pitch.key_num</code> might change the <code>pitch</code> of many other notes.</p>"},{"location":"core/#accessing-and-processing-scores","title":"Accessing and Processing Scores","text":"<p>If you access notes directly, be aware that notes can be tied: Not every Note object represents a new performed tone. Also, Measures can contain Chord events that contain Notes, so Notes can exist at two levels of the hierarchy. Because of these and other complications, it is recommended that you use Score methods to extract the information you need rather than using your own code to traverse a Score.</p> <p>To process all notes in time order, call the Score method <code>amads.core.basics.Score.get_sorted_notes</code>, which returns a flat list of all notes, ordered by onset time, with ties merged.</p> <p>If you need notes from a particular staff or part, use <code>amads.core.basics.Score.collapse_parts</code> to obtain a score with only the desired information, and then call <code>score.find_all(Note)</code>  to get an iterator for all notes in onset time order, or use <code>score.list_all(Note)</code>  if you need a list rather than an iterator.</p> <p>The <code>score.find_all()</code> and <code>score.list_all()</code> methods can be used to retrieve other objects, e.g., to find all <code>Part</code> or <code>Staff</code> or <code>Measure</code> objects.</p>"},{"location":"paper/","title":"Overview of AMADS: Algorithms for Music Analysis and Data Science","text":"","tags":["music","scores","algorithms","data science"]},{"location":"paper/#summary","title":"Summary","text":"<p>A great deal of our musical heritage exists and survives  in sheet music: scores with notes, rests, dynamics, articulation, and the like. The equivalent digital encoding is generally called \u201csymbolic\u201d music. And while some may associate this with Western classical music, it serves styles and repertoires far beyond that (jazz leadsheets, Korean traditional music, \u2026).</p> <p>The last few decades have seen a growing body of work focused on this data, and therefore the emergence of many algorithms for analysis. Algorithms for Music Analysis and Data Science (AMADS) aims to provide a summary of those algorithms, bringing them together in a coherent way in relation to new standards for encoding. In so doing, it also fills in some gaps that this process identifies, and expands into some new areas.</p>","tags":["music","scores","algorithms","data science"]},{"location":"paper/#statement-of-need","title":"Statement of need","text":"<p>We begin with some high-level observations will serve to provide the context and motivation for this topic.</p> <ul> <li>Music computing is not a large field. There are wonderful, enthusiastic practitioners,      but rather few of us relative to more populous fields.</li> <li>Related, music computing is somewhat disparate, with those practitioners spread out across the world,      and with sub-fields like MIR, music theory, and music psychology having rather limited interaction,      at least relative to the clearly shared goals, tasks, and data.</li> <li>Educational resources can serve not only as material for preparing specific classes,     but also as a vehicle for consolidating the field     e.g., textbooks can function both for teaching and as reference books for experts.</li> <li>Code libraries can likewise serve as another gathering point,     supporting both newcomers with \"how to\u201c guides and consolidating the field for expert practitioners.</li> </ul> <p>While some parts of the music computing landscape are relatively well served with code libraries (e.g., tool-based libraries for extracting data from audio such as librosa and  madmom), there has been little by way of libraries for consolidating algorithms across the music computing, and so the coverage continues to be patchy and disparate.</p> <p>There have been several promising initiatives that draw together algorithms in a particular area. These include \u201dOMNISIA\u201c (Meredith et al. for pattern finding in Java), \u201dsynpy\u201c (Song et al., for rhythmic syncopation in Python). and the \u201cmidi toolbox\u201d (Toiviainen and Eerola, for melodic contour and more in Matlab). These are welcome efforts, but they  are expressed in different code languages, address a narrow scope, and in at least some cases, are no longer maintained.</p> <p>Then there are larger libraries that could serve to draw this together. At one time humdrum was a/the central point of reference.  That continues to be used and maintained (an impressive 40 years later!), but there are downsides, e.g., the 'language neutral' set up is commendable, but not very inviting for newcomers with expectations based on the landscape of today.</p> <p>Later, music21 was introduced. First published in 2010/11, this too continues to be maintained and used. That said, the creator-maintainer recently made the explicit decision (announced/reported here) that it is not / no longer there to provide the holistic directory function stated here. Instead, it specifically invites niche projects to go solo, with or without music21 as a dependency.</p> <p>Partitura is arguably one such project, though it explicitly suggests using music21 instead if \u201cyou are working in computational musicology.\u201d</p> <p>Students and researchers wishing to explore a topic, therefore have to do a lot of \u201cspade-work\u201d to compare any new algorithm with existing work, or even to make use of those existing algorithms. In short,  given this state of affairs, and following conversation with the maintainers of all those code libraries, it is clear that we need a new coordination effort drawing together the work cited above in a more coordinated fashion.</p>","tags":["music","scores","algorithms","data science"]},{"location":"paper/#philosophy","title":"Philosophy","text":"<p>AMADS seeks to address the above need, serving primarily to bring together these algorithms. We seek to be as user-friendly as possible, serving as a welcoming introduction to those new to the field, and a helpful reference library for those already active.</p> <p>There is a spectrum of options we could have taken in pursuing these goals. One extremely light-touch option we considered was to simply list the resources out there. This alone would have provided the field some manner of synthesis and sign-posting. We decided on the more ambitious and extensive undertaking seen here as many useful functions have no public implementation, or else an implementation in an all-but obsolete language. Pointing users to those sources would be of limited use. Much better is instead to provide an implementation in those cases.</p> <p>Where existing code packages are publicly available and clearly maintained by a named and currently active person or team, we aim to avoid re-implementation, and focus instead on providing an ecosystem that incorporates those packages as dependencies via an API. As such, AMADS serves as a kind of meta-package, with a unified Python API for acessing  both new code and other relevant packages in one place.</p> <p>There are trade-offs here. This meta-package scope necessarily makes the overall design less consistent than it might be if we reimplemented everything from scratch. Overall, we consider this an acceptable balance; we consider the current approach the best way to invest time in serving the field and building on what has been accomplished already.</p> <p>In keeping with the above, we will gladly consider pull request (PR) contributions that build on any of those packages (IDyoM, music21, Partitura, ...). We reserve the right to later refactor the inner workings, and will in such cases aim to keep details of the user-experience API consistent in terms of input/output and result.</p> <p>Another tradeoff has to do with underlying representations. For each algorithm, there is likely to be a \u201cnatural\u201d representation of the essential information where non-essential information is excluded, for example, lists of pitches without duration or dynamics. It is tempting to use these representations, but that leads to a proliferation of data readers, writers, converters and filters. This might simplify the implementation of algorithms, but then one cannot simply apply any analysis to any musical data object because the information required by the algorithm may have been abstracted away. AMADS tends to retain more information in its representation but offers an object-oriented approach where algorithms can efficiently extract whatever information they need.</p>","tags":["music","scores","algorithms","data science"]},{"location":"paper/#acknowledgements","title":"Acknowledgements","text":"<p>We strive to cite all involved in the research gathered here. All contributors to the new repository appear in the commit history and are generally listed as authors of the respective files. The design of this code library is informed by conversations with all relevant precedents (including those cited above). Many thanks to those developers, and to the new ones. Finally, we thank Dagstuhl for supporting seminar number 24302 which helped advance these plans.</p>","tags":["music","scores","algorithms","data science"]},{"location":"developer_notes/contributing/","title":"Contributing","text":"<p>We welcome contributions to the project! Whether you want to fix bugs, improve documentation, or add new features, here's how you can contribute:</p>"},{"location":"developer_notes/contributing/#core-data-structures-and-functions","title":"Core Data Structures and Functions","text":"<p>Our goal is compatibility among input, output, and analysis functions. Most of AMADS shares a common representation for music information, so you should be familiar with the core data structures and methods described in the API Reference Core Overview.</p> <p>In addition, check out the general Algorithms topic indexed on the \u201cAPI Reference Page\u201d topics, which include various functions to compute common analysis and statistical properties such as entropy, and there are also operations related to collections (sets, vectors, etc.). Even if it is a little work to put data in the right form to use these shared algorithms, we prefer this to avoid a proliferation of implementations of the same algorithm (which might have subtle bugs or surprising differences.</p> <p>Finally, the Design Considerations page gives some rationale for the AMADS design and some general guidelines for issues like score representation, new attributes, and mutability (or not).</p>"},{"location":"developer_notes/contributing/#github-contribution-workflow","title":"GitHub contribution workflow","text":"<p>You should have a local clone of AMADS from Github installed. These instructions will continue from that starting point.</p>"},{"location":"developer_notes/contributing/#1-uninstall-the-package","title":"1. (Un)Install the package","text":"<p>To work on AMADS, you should be using the package represented by your Github clone of AMADS. To be safe, in case you have AMADS installed already, uninstall AMADS using pip:</p> <pre><code>pip uninstall amads\n</code></pre> <p>Then, install your local repository as the AMADS package:</p> <pre><code>cd &lt;path-to-root-of-amads-repo&gt;\npip install -e .\n</code></pre> <p>This pip command will tell Python to use the local repo, so that any changes to the code will be incorporated into the package whenever you restart Python (e.g. start the next debugging session).</p>"},{"location":"developer_notes/contributing/#2-use-pre-commit","title":"2. Use pre-commit","text":"<ol> <li> <p>Install pre-commit hooks:</p> <p>pip install pre-commit &amp;&amp; pre-commit install</p> </li> <li> <p>Run pre-commit:</p> <pre><code>pre-commit run --all-files\n</code></pre> </li> </ol> <p>(You only need to do this once after you have installed pre-commit.)</p>"},{"location":"developer_notes/contributing/#3-submit-a-pull-request","title":"3. Submit a pull request","text":""},{"location":"developer_notes/contributing/#a-for-team-members","title":"A. For team members","text":"<p>In the this section, please replace \u201cfeature-name\u201d with the name of your branch.</p> <ol> <li> <p>Create a new branch from main:</p> <pre><code>git checkout -b feature-name\n</code></pre> </li> <li> <p>Make your changes and commit them</p> </li> <li> <p>See \u201cBefore you push, there might be new changes ...\u201d below.</p> </li> <li> <p>Push the branch:</p> <pre><code>git push origin feature-name\n</code></pre> </li> <li> <p>Open a pull request from your branch to main</p> </li> </ol>"},{"location":"developer_notes/contributing/#b-for-external-contributors","title":"B. For external contributors","text":"<ol> <li> <p>Fork the repository to your GitHub account</p> </li> <li> <p>Clone your fork:</p> <pre><code>git clone https://github.com/your-username/amads.git\n</code></pre> </li> <li> <p>Create a branch:</p> <pre><code>git checkout -b feature-name\n</code></pre> </li> <li> <p>Make your changes and commit them</p> </li> <li> <p>Push to your fork:</p> <pre><code>git push origin feature-name\n</code></pre> </li> <li> <p>Open a pull request from your fork to our main branch</p> </li> <li> <p>Before you push, there might be new changes in the repo to     integrate. To merge the changes:</p> <pre><code>git checkout main\ngit pull origin main\ngit branch # if needed to find your feature name\ngit checkout feature-name\ngit merge main\n</code></pre> </li> </ol> <p>8 If there are conflicts, edit/fix the files with conflicts and:</p> <pre><code>git add path/to/resolved/file\n</code></pre> <ol> <li> <p>Recommit:</p> <pre><code>git commit\n</code></pre> </li> <li> <p>Push to your fork (again):</p> <pre><code>git push origin feature-name\n</code></pre> </li> </ol>"},{"location":"developer_notes/contributing/#4-continuous-integration","title":"4. Continuous Integration","text":"<p>All pull requests must pass our automated test suite in the CI pipeline before they can be merged. This ensures code quality and prevents regressions.</p> <p>One of the tests will run the code coverage tool, which will report on the percentage of code that is covered by tests. If you see that the coverage is low, please add tests for the code you are changing.</p>"},{"location":"developer_notes/contributing/#5-code-review","title":"5. Code Review","text":"<p>A project maintainer will review your code. They may request changes or clarification. This helps maintain code quality and consistency.</p> <p>The reviewers points will appear as comments on the pull request, which you can view on GitHub. You can respond to those comments with your own comments, but in many cases you will also want to make changes to your code. To do this, simply push more commits to your branch. The pull request will automatically update to reflect the changes.</p> <p>Once you have made the required code changes for a particular discussion point, please add a comment to the thread indicating that you have made the changes. Do not resolve the comment yourself, as the reviewer needs to be able to check your changes. They are the one who should resolve the comment once they are satisfied.</p> <p>Once you have finished responding to all the comments, you can re-request review by clicking the \u201cRe-request review\u201d button in the GitHub UI.</p>"},{"location":"developer_notes/contributing/#6-merging","title":"6. Merging","text":"<p>Once your pull request passes CI and receives approval from a reviewer, it can be merged into the main codebase. You as author can merge it yourself, or you can ask a reviewer to merge it for you. When merging, please use the \u201cSquash and merge\u201d option, which will combine all the commits into a single commit. This helps keep the commit history clean and easy to understand. There's one case, though, where squashing is a bad idea, and that's when someone else is working on another branch that branched off your branch (in general we try to avoid this, but sometimes it happens!). In this case, you should merge the pull request as a normal merge, not a squash merge.</p>"},{"location":"developer_notes/contributing/#what-makes-a-good-pull-request","title":"What makes a good pull request?","text":"<p>You can contribute many kinds of things via a pull request:</p> <ul> <li>Bug fixes</li> <li>Documentation improvements</li> <li>New features and functionality</li> <li>Test cases</li> </ul> <p>When submitting pull requests, follow these guidelines:</p> <ol> <li>Keep changes small and focused<ul> <li>Each PR should address a single concern</li> <li>Break large changes into smaller, logical PRs</li> <li>This makes review easier and reduces merge conflicts</li> </ul> </li> <li>Write clear PR descriptions<ul> <li>Explain what the changes do and why they're needed</li> <li>Reference any related issues</li> <li>Include before/after examples if relevant</li> <li>List any breaking changes or dependencies</li> </ul> </li> </ol> <p>For example, instead of one large PR that adds multiple features, refactors code, and fixes bugs, break it into:</p> <ul> <li>PR 1: Add new feature X</li> <li>PR 2: Refactor module Y</li> <li>PR 3: Fix bug Z</li> </ul> <p>This approach helps reviewers understand your changes and speeds up the review process.</p>"},{"location":"developer_notes/contributing/#how-do-i-contribute-a-new-algorithm","title":"How do I contribute a new algorithm?","text":"<p>When contributing a new algorithm, first review existing examples in the source code to understand the project's structure and conventions. Consider carefully where your algorithm fits in the codebase hierarchy.</p> <p>When writing your code, try to follow our style guidlines. Write clear and complete documentation, including relevant citations with DOIs/URLs where possible.</p> <p>Your contribution should include comprehensive tests, including both doctests and unit tests. See <code>testing</code> for more information.</p> <p>If you haven't already, make sure you have installed the pre-commit hooks (see <code>style</code>). The hooks will help ensure your code meets the project's formatting and style requirements.</p>"},{"location":"developer_notes/design/","title":"Design Considerations","text":"<p>This document is an early design document, probably supplanted by other documentation, but reviewed and converted to Markdown on 10 Jan 2026, so it should be accurate.</p>"},{"location":"developer_notes/design/#terminology-and-structure","title":"Terminology and Structure","text":"<ul> <li> <p><code>onset</code> refers to the start time of a note or other event.</p> </li> <li> <p><code>offset</code> refers to the ending time of a note or other event.</p> </li> <li> <p><code>duration</code> refers to <code>offset - onset</code></p> </li> <li> <p>Scores are hierarchical, but all nodes and leaves represent   <code>onset</code> directly in absolute beat or time (not relative to the   onset time of the parent). The end time is called <code>offset</code> and is   computed as onset + duration.  (Note that in contexts outside of   AMADS, \"offset\" is a synonym for \"displacement,\" which is   essentially a \"delta\" or \"difference,\" so be careful not to be   confused: \"onset\" is the beginning, \"offset\" is the ending!)</p> </li> </ul> <p>The use of absolute onset times makes it relatively expensive to shift an object in time. E.g. to move a measure to a later time, you must shift not only the <code>onset</code> of the <code>Measure</code> but also all of the <code>Note</code>s and other objects in the <code>Measure</code>. However, the most common reason to use a <code>Measure</code> or some other object at another time is to reuse the object in a different context, e.g. to copy a measure from one part to another part. Since all member objects have a reference to their parent, the copy must be a deep copy of the entire subtree. Given the cost of the deep copy, the cost of recomputing the <code>onset</code>s is negligible. In addition, using an absolute <code>onset</code> simplifies a lot of code and makes access to the <code>onset</code> more efficient.</p> <p>The music representation hierarchy is constrained to match intuitive ideas about music structure. The levels of hierarchy are <code>Score</code>, <code>Part</code>, <code>Staff</code>, <code>Measure</code>, <code>Chord</code>, <code>Note</code>, and <code>Rest</code>. Often, this is overkill for the task at hand, so we support a \"flat\" representation which is basically a list of <code>Note</code> objects. More on this in the next section.</p> <p>The edge or leaf-nodes of the representation hierarchy include <code>Note</code> and <code>Rest</code> classes. All of these inherit from an abstract superclass called Event, which is basically just <code>onset</code>, <code>duration</code> and <code>parent</code> attributes. The <code>Note</code> subclass adds attributes for <code>pitch</code>, <code>dynamic</code>, <code>tie</code>, etc.</p> <p>Inner levels of hierarchy are represented by subclasses of <code>EventGroup</code>, which is in turn an <code>Event</code> with an added attribute named <code>content</code>, a list of children. E.g. a <code>Measure</code> is an <code>EventGroup</code>. You might expect the duration of an <code>EventGroup</code> to be implied by the content, but especially if Rests are removed, a <code>Measure</code> has a duration that is independent of the content. An <code>EventGroup</code> duration is mainly relevant of you want to append nodes sequentially: The duration gives you the offset time, which becomes the onset time of the next appended element.</p> <p>Pitch is structured and includes a representation of accidentals, so AMADS can disambiguate between Bb and A#, for example.</p>"},{"location":"developer_notes/design/#time","title":"Time","text":"<p>Time is normally measured in quarters, regardless of the meter. So a measure in 4/16 time has a duration of 1 (not 4). Scores have a tempo and information corresponding to a Standard MIDI File tempo track, so AMADS can convert from quarters to seconds or seconds to quarters.</p> <p>To work in seconds, it is most efficient to convert the entire score to seconds, meaning that every <code>onset</code> and <code>duration</code> attribute is converted in one pass through the score. Since the entire score stores time in one unit or the other, there are no separate attributes such as <code>offset_seconds</code> or <code>duration_seconds</code>, and computed values such as <code>offset</code> run identical computations whether the units are beats or seconds, so they return values in the same units as are stored in the score.</p>"},{"location":"developer_notes/design/#conversion-to-seconds","title":"Conversion to Seconds","text":"<p>Conversion to seconds is done in-place. This violates the immutable Score design (see next section) but note that if you convert back to beats, you can restore the original score, so changes are not necessarily visible even when scores are shared. Conversion involves using the score <code>TimeMap</code> to map between quarters and seconds. The <code>TimeMap</code> is stored as an array of breakpoints, so a lookup involves a search, but since most accesses are in time order, it is possible to cache the location of the previous lookup in case the next one is nearby. Thus, we can expect to make a single pass through the <code>TimeMap</code> to convert each <code>Staff</code> and its children.</p>"},{"location":"developer_notes/design/#immutable-scores","title":"Immutable Scores","text":"<p>In general, music structures in AMADS are immutable. This means that once you read or construct a score, you can extract data and reformat the data without side-effects from analysis functions. For example, given a piano score, you can extract the top staff into a new score. This will not delete the bottom staff, so you can still extract the bottom staff into another score. Similarly, if you merge all tied notes in a score, any references you had to notes before the merge will remain unaffected because the notes will be merged in a copy.</p> <p>Elements of the Score hierarchy have access to their parent, so parents cannot generally share sub-trees. E.g. to extract the flute Part from a complete Score, AMADS cannot simply construct a new Score that contains just the flute Part, because the original flute Part's parent is the original Score. Instead, the entire flute Part (but no other Parts) must be deep-copied to assign new parents to elements of the copy.</p> <p>It would be prohibitively expensive to rule out all modifications to Scores, e.g. transposing 100 notes should not make 100 copies of the original score, making one change at a time. The rule is that once you copy a score, you can make any number of modifications as long as there are no shared references to the score or score elements. Thus, scores are not observably mutable from the \"outside\" of computations. AMADS transformations such as <code>flatten</code> or <code>merge_tied_notes</code> generally make a single copy even though there are many changes.</p> <p>Another case is that some analysis algorithms need to report results on a per-note basis, e.g. assigning an entropy value to each note. In these cases, the analysis algorithm can create and set an analysis-specific attribute, e.g. <code>entropy</code>, on each note. Essentially, algorithms are allowed to annotate scores by adding new events and attributes, as long as they do not change existing attributes or insert or delete Notes, Rests, Chords or other event types understood by AMADS.</p> <p>In keeping with Python best practices, we do not use Python's ability to add attributes to objects dynamically. Instead, there is one attribute, <code>info</code>, on every <code>Event</code> that serves as a dictionary for additional information that does not have a place in the declared attributes. We consider <code>info</code> to be mutable, so analysis algorithms and their users should be careful to avoid overwriting information there.</p>"},{"location":"developer_notes/design/#basic-representation-and-simplifications","title":"Basic Representation and Simplifications","text":"<p>The \u201cstandard\u201d score has parts representing instrumental parts. Each part has 1 or more staves (e.g. a piano part would ordinarily have 2 staves [\u201cstaves\u201d is the plural of \u201cstaff\u201d, but documentation often uses \u201cstaffs\u201d in the sense of \u201cmultiple instances of the Staff class.\u201d]), each staff has measures, and measures have notes and chords which have notes. Notes can be tied, so a single \u201clogical\u201d note can be represented (as in standard notation) by multiple notes tied together. This is basically because notes do not fit within the hierarchy imposed by measures and beats. When a note crosses a measure boundary, and sometimes when it crosses a beat boundary, at least in conventional notation, it must be split across these boundaries and the original note is indicated by ties between the fragments.</p> <p>All this hierarchy can get in the way, so we allow various simplifications:</p> <ul> <li> <p>Tied notes can be replaced by single notes, with durations that may   extend beyond a measure boundary (<code>merge_tied_notes()</code> method)</p> </li> <li> <p>Rests can be removed (<code>remove_rests()</code> method)</p> </li> <li> <p>Staves within each part can be collapsed to a single staff   (currently, no method does just this)</p> </li> <li> <p>Chords can be removed, moving notes \u201cup\u201d into measures   (<code>expand_chords()</code> method)</p> </li> <li> <p>Staves, measures and chords can be removed and all \"leaf\" notes   moved directly into parts (<code>flatten()</code> method, which additionally   removes ties as in <code>merge_tied_notes()</code> since there are no more   explicit measures)</p> </li> <li> <p>Multiple parts can be combined into a single part (<code>merge_part()</code>   method, but this also does <code>flatten()</code> which implies   <code>merge_tied_notes()</code>)</p> </li> </ul> <p>So there are lots of variations all having to do with removing different hierarchies. We considered a hierarchy of representations, each with additional notation details or hierarchy, but this seems too complicated and while it might be appropriate for certain kinds of analysis, the intermediate levels of simplification do not correspond to any familiar notation and so they are not intuitive.</p> <p>In conclusion, the main thing users should think about is measure structure vs. \u201cflat\u201d note lists, so we have two categories for scores: full and flat. Within these types, we can have checks for the more subtle differences and operations to remove structure:</p>"},{"location":"developer_notes/design/#full-scores","title":"Full Scores","text":"<p><code>.has_rests()</code>     The Score or Part or Staff or Measure has one or more Rest objects.</p> <p><code>.remove_rests()</code>     Construct a Score or Part or Staff or Measure without any     Rests. Note that removing rests does not change the timing of     notes or other objects since each Events has a delta time relative     to the parent (as opposed to music notation where a note begins     after a previous note or rest).</p> <p><code>.has_chords()</code>     The Score or Part or Staff or Measure has one or more Chord objects.</p> <p><code>.expand_chords()</code>     Convert a Score, Part, Staff or Measure to one without chords     (chord notes become ordinary notes within the parent).</p> <p><code>.has_ties()</code>     The Score, Part, Staff or Measure has one or more tied notes.</p> <p><code>.merge_tied_notes()</code>     Convert the Score, Part, Staff or Measure to one without     ties. Although not required, we expect ties to break notes where     they cross measure boundaries.  After <code>.merge_tied_notes()</code>,     notes may cross one or more measure boundaries.</p> <p><code>.remove_measures()</code>     The <code>.remove_measures()</code> method \"lifts\" notes into the Staff     level, preserving each Staff. This is neither a Full Score     nor a Flat Score, but might be useful in processing each Staff     separately. Note that tied notes can cross staves.     <code>remove_measures()</code> merges ties to eliminate staff-crossings.     For example if (staff 1, note 1) ties to (staff 2, note 2), then     note 2 will be removed from staff 2 (and the duration of note 1     will be adjusted).</p> <p><code>.flatten()</code>     Convert a full score into a flat score. Parts are preserved or     collapsed based on an optional parameter. Tied notes are always     merged because we assume ties are not useful in this     context. Non-Note events are not retained in Part(s) because they     might only be relevant within the hierarchy of a measured     score. However, non-Note events can be inserted into a flat score.</p> <p><code>.collapse_parts()</code>     Merge the notes of selected Parts and Staffs into a flat score     with one Part. When called with no part or staff selection, all     notes are combined this is equivalent to     <code>.flatten(collapse=True)</code>.</p>"},{"location":"developer_notes/design/#flat-scores","title":"Flat Scores","text":"<p><code>.is_flat()</code>     Test if this is a flat score. A flat score has a strict hierarchy     described by: Score-Part-Note. There are no tied notes. Also,     there are no Staff, Measure, Rest or Chord objects, but there may     be other subclasses of Events at any level.</p> <p><code>.is_flat_and_collapsed()</code>     Test if this is a flat score with one and only one Part.</p> <p><code>.part_count()</code>     Returns number of parts</p>"},{"location":"developer_notes/design/#other-scores","title":"Other Scores","text":"<p>Scores which are neither Full nor Flat are at least possible to construct. E.g. a Score-Part-Note hierarchy with tied notes or a Score with a mix of measured and flattened Parts. Developers should consider that valid Full Scores could have Chord objects with zero or one Notes.</p> <p>Ideally, algorithms should detect violations in assumptions and report them as errors: We do not want users to call functions with an intuitive idea of what they should do, only to get some non-intuitive result that the user does not notice. It's better to raise an error to say \u201cyou can't do this, or I don't support it\u201d than to silently return something possibly wrong.</p> <p>The <code>.is_well_formed()</code> and <code>.is_well_formed_full_score()</code> methods can check for conformance to the standard forms.</p>"},{"location":"developer_notes/design/#distributions-and-histograms","title":"Distributions and Histograms","text":"<p>The Distribution class models statistical distributions or histograms. Attributes describe the data with enough detail to produce reasonably labeled plots, so by returning a Distribution object rather than simply a vector, the user can call <code>.plot()</code> without even knowing the proper axes and labels.</p> <p>Distributions are often built with a Histogram object to do calculations, but the Histogram class can be used independently of Distributions, and neither is a subclass of the other.</p>"},{"location":"developer_notes/documentation/","title":"Documentation","text":"<p>This guide explains how to build and maintain the project\\'s documentation using mkdocs.</p>"},{"location":"developer_notes/documentation/#prerequisites","title":"Prerequisites","text":"<p>Before building the documentation, ensure you have the dev dependencies installed:</p> <pre><code>pip3 install mkdocs mkdocs-material \"mkdocstrings[python]\"\nin project root: mkdocs new .\n</code></pre>"},{"location":"developer_notes/documentation/#building-documentation","title":"Building documentation","text":""},{"location":"developer_notes/documentation/#macos-or-linux","title":"macOS or Linux","text":"<pre><code>PYTHONPATH=. mkdocs serve \n</code></pre> <p>(You can write <code>build</code> instead of <code>serve</code> to just build once.)</p> <p>This will start a live server that automatically rebuilds the documentation when changes are detected. </p> <p>However, changes to Python source code will not rebuild. I keep a small shell window running <code>PYTHONPATH=. mkdocs serve</code>. After editing some docs in code, I go to the window and type CTRL-C CTRL-P RETURN, which kills the server, recalls the build command and runs it. When everything is updated, your browser will update the page automatically.</p>"},{"location":"developer_notes/documentation/#windows","title":"Windows","text":"<p>Can someone help with this?</p>"},{"location":"developer_notes/documentation/#writing-documentation","title":"Writing documentation","text":"<p>Documentation files are written in MarkDown (.md) format. Here are some key points:</p> <ul> <li>Use <code>.md</code> extension for documentation files</li> <li>Follow the numpydoc style for docstrings</li> <li>Cross-reference other pages using <code>:ref:</code> roles</li> <li>Add new pages to the appropriate toctree in <code>index.rst</code></li> </ul>"},{"location":"developer_notes/documentation/#authorship","title":"Authorship","text":"<p>If you want to get credit in the formatted documentation,  add something like this to a docstring: </p> <p><code>&lt;small&gt;**Authors**: Yiming Huang, Roger B. Dannenberg&lt;/small&gt;</code></p> <p>If the module appears in documentation, you can put this at the bottom of the text of the module docstring (at the top of the file).</p> <p>In many cases, there is no special information associated with the module, e.g., it is simply a container for algorithms. In that case, we do not produce documentation for the module, and you should put the author credit into the function(s) that do appear in the documentation. Generally put the <code>**Authors**</code> line below the descriptive strings for the function and above the \u201c<code>Parameters</code>\u201d heading. See docs for <code>duration_distribution_1</code> within Time : Distributions.</p>"},{"location":"developer_notes/documentation/#adding-new-documentation-files","title":"Adding new documentation files","text":"<p>To add a new documentation file:</p> <ol> <li> <p>Create a new <code>.md</code> file in the appropriate directory:</p> <p><code>touch docs/reference/melody/melody_info.md</code></p> </li> <li> <p>Add content to your .md file using MarkDown syntax:</p> </li> </ol> <pre><code># Extra Information on Melody Modules\n\nThis is a guide for users using functions in amads.melody\n\n## Section title\n\nContent goes here.\n</code></pre> <ol> <li>Add the file to the nav: info near the bottom of <code>mkdocs.yml</code> in the root of the repo.</li> </ol> <pre><code>nav:\n  - Home: index.md\n  - Project Overview: paper.md\n  - API Reference:\n    - Core:\n      ...\n    ...\n    - Melody:\n    ...\n    - reference/melody/melody_info.md\n    OR\n    - AlternateTitle: reference/melody/melody_info.md\n    ...\n  ...\n</code></pre> <p>The file will now appear in the documentation navigation. Make sure to:</p> <ul> <li>Use descriptive filenames that reflect the content</li> <li>Place files in appropriate subdirectories (reference,       developer_notes, etc.)</li> <li>Keep <code>mkdocs.yml</code> well-organized.</li> <li>Build and check that the new page appears correctly</li> </ul>"},{"location":"developer_notes/documentation/#adding-code-to-documentation","title":"Adding Code to Documentation","text":"<ul> <li>Note that modules are not directly added to <code>mkdocs.yml</code> in       the root of the repo. Instead, you create a <code>.md</code> file       (see previous section) that imports code documentation.</li> <li>The relationship between modules and <code>.md</code> files is flexible       since this is all manual: You can document multiple       modules in a single page or even split a single module       into multiple pages.</li> </ul> <p>The syntax to \u201cimport\u201d code documention into MarkDown is like this:</p> <pre><code>::: amads.time.swing.match_beats_and_upbeats\n</code></pre> <p>The path can name an entire module, a class, or a function.</p>"},{"location":"developer_notes/documentation/#add-the-module","title":"Add the module?","text":"<p>If there is useful information in a doc-string at the top of the module source code, then you should add the module to <code>mkdocs.yml</code>. However, this will (by default) add all the content of the module as well without putting it in the table-of-contents in the right margin!</p> <p>Therefore, if you add the module, you should disable members like this:</p> <pre><code>::: amads.time.swing\n    options:\n      members: false\n</code></pre> <p>This example, in <code>docs/reference/time/swing.md</code>, adds general documentation from the top of <code>amads/time/swing.py</code>, but it does not add functions.</p>"},{"location":"developer_notes/documentation/#add-classes-and-functions","title":"Add classes and functions","text":"<p>Mkdocs does not automatically create documentation pages for code, so for each topic, you need to create a .md file that is included in <code>mkdocs.yml</code>. This example is from <code>docs/reference/melody/swing.md</code>, which displays the documentation for <code>amads/melody/swing.py</code>. Four functions (there are no classes) are added to the page after the module documentation, which naturally comes first:</p> <pre><code>::: amads.time.swing\n    options:\n      members: false\n\n----------------\n\n::: amads.time.swing.beat_upbeat_ratio \n\n------------------\n\n::: amads.time.swing.mean_bur\n\n------------------\n\n::: amads.time.swing.std_bur\n\n------------------\n\n::: amads.time.swing.match_beats_and_upbeats\n</code></pre> <p>In this case the table of contents in the right margin will have \u201cswing\u201d, \u201cbeat_upbeat_ratio\u201d, \u201cmean_bur\u201d, \u201cstd_bur\u201d and \u201cmatch_beats_and_upbeats\u201d.</p> <p>You can also add additional text to the <code>.md</code> page</p> <p>This is referenced in <code>mkdocs.yml</code> like this:</p> <pre><code>nav:\n  ...\n  - API Reference:\n    ...\n    - Time\n      ...\n      - Swing: reference/time/swing.md\n      ...\n    ...\n  ...\n</code></pre> <p>The page title, Swing, could also be put in the <code>swing.md</code> file.</p>"},{"location":"developer_notes/documentation/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li> <p>Missing modules: If you see warnings about missing modules,     ensure all development dependencies are installed:</p> <p><code>bash pip install -e .[docs]</code></p> </li> <li> <p>Build errors: Clear the build directory and rebuild.</p> <p>``` bash rm -rf docs/_build/*  # Unix/macOS</p> </li> </ol>"},{"location":"developer_notes/documentation/#or","title":"or","text":"<p>rmdir /s /q docs_build  # Windows make html ```</p>"},{"location":"developer_notes/github/","title":"Github","text":"<p>This page describes configuration details for Github.</p> <p>See also GitHub contribution workflow.</p>"},{"location":"developer_notes/github/#testing-and-continuous-integration","title":"Testing and Continuous Integration","text":"<p>The configuration is in <code>.github/workflows/tests.yml</code></p> <p>There are two (potential) sets of tests:</p> <pre><code>python -c \"from amads.ci import run_main_tests; run_main_tests()\"\n</code></pre> <p>which is actually run, and the following which is commented out:</p> <pre><code>python -c \"from amads.ci import run_ci_group_tests;\nrun_ci_group_tests('tests_melsim')\"\n</code></pre> <p>We had problems with melsim, probably related to its dependency on R.</p>"},{"location":"developer_notes/github/#amads.ci.run_main_tests","title":"run_main_tests","text":"<pre><code>run_main_tests()\n</code></pre> <p>Run the main tests, i.e. all tests except those in the ci_groups dictionary. Assumes that the working directory is the root of the repository.</p> Source code in <code>amads/ci.py</code> <pre><code>def run_main_tests():\n    \"\"\"\n    Run the main tests, i.e. all tests except those in the ci_groups dictionary.\n    Assumes that the working directory is the root of the repository.\n    \"\"\"\n    paths_to_ignore = paths_in_ci_groups\n    ignore_args = [f\"--ignore={path}\" for path in paths_to_ignore]\n    pytest_args = coverage_args + ignore_args\n    sys.exit(pytest.main(pytest_args))\n</code></pre>"},{"location":"developer_notes/making_a_release/","title":"Making a release","text":"<p>To make a release, follow these steps:</p> <ol> <li> <p>Decide on the version number. See Semantic     Versioning for guidance. Briefly, the version     number is of the form <code>X.Y.Z</code> where:</p> <ul> <li><code>X</code> is the major version number,</li> <li><code>Y</code> is the minor version number,</li> <li><code>Z</code> is the patch version number.</li> </ul> <p>The major version number should be incremented when you make incompatible API changes. The minor version number should be incremented when you add backwards-compatible functionality. The patch version number should be incremented when you make backwards-compatible bug fixes.</p> <p>For example, if the current version is <code>0.1.0</code> and you have made some backwards-compatible bug fixes, you would increment the patch version to <code>0.1.1</code>.</p> </li> <li> <p>Update the version number in the <code>pyproject.toml</code> file.     (Note: you will also see version number in the <code>amads.eggs/PKG-INFO</code> file.     do not manually change that).</p> </li> <li> <p>Commit the changes and push them to the <code>main</code> branch.</p> </li> <li> <p>Create a new tag for the release as follows (replace <code>0.1.1</code> with     the new version number):</p> <p><code>sh git tag v0.1.1</code></p> </li> <li> <p>Push the tag to the remote repository:</p> <p><code>sh git push origin v0.1.1</code></p> </li> <li> <p>GitHub Actions will automatically build the distribution and publish     it to PyPI. You can view the progress of the release in the     \\\"Actions\\\" tab of the GitHub repository. Once the release is     complete, you should be able to see the release on PyPI:     https://pypi.org/project/amads/#history.</p> </li> </ol> <p>Once the package is more mature, we should additionally maintain a changelog that lists what changes have been made in the latest version.</p>"},{"location":"developer_notes/modules/","title":"Modules","text":"<p>Author</p> <p>:   Roger B. Dannenberg</p> <p>Date</p> <p>:   Sep 2024</p> <p>This is an attempt to explain to myself how module naming and loading can work for SMART. I\\'m not experienced with creating packages, so this might be really basic stuff for those in the know.</p> <p>First, it\\'s good to know a package is a collection of modules. A module is a single python script (file).</p>"},{"location":"developer_notes/modules/#problems","title":"Problems","text":"<ul> <li>Want to control the naming (somewhat) independently of the file     system organization.</li> <li>Want to load modules incrementally, e.g. we want to load only     analysis algorithms that we intend to use.</li> <li>Want to load modules conditionally, such as deciding to use     Partitura or Music21 for input/output implementation.</li> <li>Want to write test code we can run in the debugger OR from anywhere     after installing our package with no special configuration.</li> </ul>"},{"location":"developer_notes/modules/#what-should-our-namespace-look-like","title":"What should our namespace look like?","text":"<p>There should be one top level module name. \\\"smart\\\" is too generic, so possibly amads.</p>"},{"location":"developer_notes/modules/#controlling-naming","title":"Controlling naming","text":"<p>Within amads, we should have algorithms, e.g.</p> <pre><code>amads.durdist1.durdist1(score)\n</code></pre> <p>is the durdist1 function. It is not (according to the file system)</p> <pre><code>amads.src.algorithms.durdist1.durdist1\n</code></pre> <p>Putting this in <code>__init__.py</code> should accomplish this goal (need to test):</p> <pre><code>import .src.algorithms.durdist1\n</code></pre> <p>Or maybe we can iterate through the algorithms directory and import all the directories there. We need to test that this does not actually import <code>durdist1.py</code>, which can be imported by</p> <pre><code>from amads.durdist1 import durdist1\n</code></pre>"},{"location":"developer_notes/modules/#incremental-loading","title":"Incremental loading","text":"<p>(Need to test this) With the organization suggested above, actual modules are loaded when imported, so the user will explicitly load whatever is needed but nothing else.</p>"},{"location":"developer_notes/modules/#conditional-loading","title":"Conditional loading","text":"<p>Maybe it\\'s better to simply load what you want. In particular, users can write the following for Partitura IO:</p> <pre><code>from amads.ptio import pt_midi_import\n</code></pre> <p>(Need to test this.)</p> <p>We can also write a midi_import function that conditionally calls pt_midi_import or m21_midi_import based on what modules are loaded. (Need to test this.)</p>"},{"location":"developer_notes/modules/#running-test-code-with-the-debugger","title":"Running test code with the debugger","text":"<p>In VScode, you can set PYTHONPATH to include the parent directory, but I think we need there to be a directory actually named amads (or whatever it\\'s called) in order to import it that way into test modules.</p>"},{"location":"developer_notes/music21/","title":"Music21","text":"<p>These are RBD\\'s notes on Music21. Probably this does not belong in AMADS but it\\'s a reference to help understand Music21.</p> <p>https://www.music21.org/music21docs/usersGuide/</p>"},{"location":"developer_notes/music21/#note-class","title":"Note class","text":"<ul> <li>name: e.g. <code>'F'</code></li> <li>octave: e.g. <code>5</code> (ISO)</li> <li>pitch: e.g. <code>'F5'</code>, <code>'B-2'</code>, <code>'D#3'</code></li> </ul> <p>Maybe it would make more sense to have an alter (alteration)? Music21 uses, e.g. <code>bflat.pitch.accidental.alter == -1</code>, so alterations are actually objects, maybe because they have some interesting attributes like position \\'left\\' or \\'above\\'</p> <p>Canonical note representation could be: * <code>&lt;start, duration, pitch, lyric&gt;</code> (see Pitch and Duration below)</p> <p>derived from this are: * <code>name_with_octave</code> * <code>pitch_class</code> * <code>frequency</code> * <code>alter_name</code> * <code>key_number</code> (or maybe midi) * <code>unicode_name</code> * <code>unicode_name_with_octave</code></p> <p>methods include: * <code>enharmonic()</code> * <code>lower_enharmonic()</code> * <code>upper_enharmonic()</code></p> <p>Rests class - another class. Accessing pitch gives an exception</p> <p>For convenience, Note has a lot of methods, but Note should be composed of: * <code>&lt;start, duration, pitch, tie&gt;</code>, where tie is <code>'start'</code>, <code>'stop'</code>, or <code>'continue'</code> (both)</p> <p>Pitch is <code>&lt;name, octave, alter&gt;</code> and derived are: * <code>name_with_octave</code> * <code>pitch_class</code> * <code>frequency</code> * <code>alter_name</code> * <code>key_number</code> (or maybe midi) * <code>unicode_name</code> * <code>unicode_name_with_octave</code></p> <p>methods include: * <code>enharmonic()</code> * <code>lower_enharmonic()</code> * <code>upper_enharmonic()</code></p> <p>Duration using rationals - see fractions.py</p> <p>measured in quarters</p> <p>properties are:</p> <ul> <li><code>quarters</code></li> </ul>"},{"location":"developer_notes/music21/#structure","title":"Structure","text":"<p>Stream is supertype for Score, Part and Measure Streams have time (delta) and a list of components: * <code>Stream</code> * <code>Note</code> * <code>Chord</code> * <code>Clef</code> * <code>TimeSignature</code> * <code>Rest</code>?</p> <p>Component deltas are relative to the parent, not global.</p> <p>We can add a tempo curve that consists of breakpoints starting at (0,0), and map seconds to quarters Operations could then include: fix the tempo, e.g.</p> <p>linear mapping at some number of quarters/second; convert internal deltas from quarters to seconds; convert internal deltas from seconds to quarters.</p> <p>Ties: in Music21, notes can have durations that take them out of the measure, OR notes can have ties.</p>"},{"location":"developer_notes/music21/#chord","title":"Chord","text":"<p>similar to Note, but it has pitches instead of pitch methods include: * <code>root</code> * <code>bass</code></p>"},{"location":"developer_notes/music21/#tempo","title":"Tempo","text":"<p>not in Music21 - should add tempo curve to Stream</p>"},{"location":"developer_notes/style/","title":"Style","text":""},{"location":"developer_notes/style/#code-style","title":"Code style","text":"<p>This document outlines the coding style guidelines for contributing to this project.</p>"},{"location":"developer_notes/style/#author-attribution","title":"Author attribution","text":"<p>Author attribution should be included at the top of each module using <code>__author__</code>. Use only names, no email addresses:</p> <pre><code>__author__ = \"Huw Cheston\"\n</code></pre> <p>For multiple authors, use a list:</p> <pre><code>__author__ = [\"Huw Cheston\", \"Mark Gotham\"]\n</code></pre> <p>See documentation for notes on getting your name into formatted documentation (<code>__author__</code> will not do it).</p>"},{"location":"developer_notes/style/#code-organization","title":"Code organization","text":"<p>Modules should be organized in a logical hierarchy that reflects their purpose. For example, complexity algorithms go in:</p> <pre><code>algorithm/complexity/lz77.py\n</code></pre> <p>Note that functions will be importable in multiple ways:</p> <pre><code>from amads.harmony.root_finding.parncutt_1988 import root\nfrom amads.all import root_parncutt_1988\n</code></pre> <p>The first style is more verbose, but it makes the logical organization of the package more explicit. The second style is more appropriate for interactive use.</p> <p>In order to support the second style, we add import statements to the <code>amads/all.py</code> file for everything.</p> <p>Then the <code>__init__.py</code> file for nearly all directories is empty.</p>"},{"location":"developer_notes/style/#details-on-module-organization-and-naming","title":"Details on module organization and naming","text":"<p>We initially set up <code>__init__.py</code> files to include everything beneath them. This might be nice so that you could simply write</p> <pre><code>from amads.harmony import get_root\n</code></pre> <p>skipping the detail that <code>get_root</code> might actually be in a submodule <code>amads.harmony.root_finding</code> or <code>amads.harmony.root_finding.parncutt</code> but this \"aggressive\" loading is:</p> <ul> <li>well, aggressive, loading much more than necessary</li> <li>caused some cyclical dependencies</li> <li>does not match mkdocs documentation, which would describe     <code>get_root</code> as <code>amads.harmony.root_finding.parncutt.get_root</code>,     not <code>amads.harmony.get_root</code></li> </ul> <p>In short, attempts to create \u201cvirtual\u201d namespaces that do not match the directory structure conflict in subtle ways with Python tools. In spite of Python's popularity and goals of simplicity, I think there is obvious confusion and design failure in Python abstractions. In the end, it seems \u201csimpler is better,\u201d and trying to create \u201chelpful\u201d abstractions (like a harmony module with all things harmony) just adds to confusion and maintenance problems.</p>"},{"location":"developer_notes/style/#function-naming","title":"Function naming","text":"<p>Be explicit about what functions return. Don't make users guess:</p> <pre><code># Good\nlz77_size()\nlz77_compression_ratio()\n\n# Bad\nlz77()  # Unclear what this returns\n</code></pre>"},{"location":"developer_notes/style/#code-structure","title":"Code structure","text":"<p>Local function definitions should be avoided as they can negatively impact performance. Instead, define functions at module level:</p> <pre><code># Good\ndef _helper_function(x):\n    return x * 2\n\ndef main_function(x):\n    return _helper_function(x)\n\n# Bad\ndef main_function(x):\n    def helper_function(x):  # Defined locally - avoid this\n        return x * 2\n    return helper_function(x)\n</code></pre> <p>We implement a pipeline for standardizing code formatting using <code>black</code>. This will ensure consistent code style across the project at the expense of allowing \u201ccustom\u201d formatting in special cases. You can override <code>black</code> (e.g., this is done in <code>amads.core.basics</code>) and \u201cdo it yourself\u201d but please stick to the general Python conventions seen throughout AMADS and avoid any surprising code layout.</p> <p>Docstrings should use numpydoc formatting:</p> <pre><code>def calculate_entropy(pitches: list[int]) -&gt; float:\n    \"\"\"Calculate the entropy of a pitch sequence.\n\n    Parameters\n    ----------\n    pitches\n        List of MIDI pitch numbers\n\n    Returns\n    -------\n    float\n        Entropy value between 0 and 1\n\n    Examples\n    --------\n    &gt;&gt;&gt; calculate_entropy([60, 62, 64])\n    0.682\n    \"\"\"\n    pass\n</code></pre> <p>External package imports (except numpy) should be done locally within functions for efficiency. This avoids loading unused dependencies:</p> <pre><code># Good\ndef plot_histogram(data):\n    import matplotlib.pyplot as plt  # Import inside function\n    plt.hist(data)\n    plt.show()\n\n# Bad\nimport matplotlib.pyplot as plt  # Global import - avoid this\n\ndef plot_histogram(data):\n    plt.hist(data)\n    plt.show()\n</code></pre>"},{"location":"developer_notes/style/#types","title":"Types","text":"<ul> <li>Provide type hints for function parameters and return types</li> <li>If a function accepts either <code>float</code> or <code>int</code> you can use     <code>float</code> as the type hint. <code>int</code> will be understood as being     accepted too</li> <li>Functions should accept Python base types as inputs but can     optionally support numpy arrays.</li> <li>Return Python base types by default, use numpy types only when     necessary</li> <li>For internal computations, either base Python or numpy is fine</li> <li>Where possible, only take simple singular input types and let     users handle iteration (well, we're not consistent on this point,     so this policy may change. An argument for is simplifying type     specifications, which in some cases are too complex to be really     helpful.)</li> </ul>"},{"location":"developer_notes/style/#common-patterns","title":"Common patterns","text":"<p>When implementing algorithms, we distinguish between internal and external functions. Internal functions implement the core algorithm or equation. External functions wrap these internal implementations, handling input validation, type checking, and any necessary data conversion. This separation of concerns helps keep the core algorithmic logic clean and focused while ensuring robust input handling at the API level.</p> <p>For example:</p> <pre><code># External function\ndef calculate_entropy(pitches: list[int]) -&gt; float:\n    \"\"\"Calculate the entropy of a pitch sequence.\n\n    Handles input validation and conversion before\n    calling _calculate_entropy_core().\n    \"\"\"\n    if not pitches:\n        raise ValueError(\"Input pitch list cannot be empty\")\n\n    # Convert pitches to counts\n    from collections import Counter\n    counts = list(Counter(pitches).values())\n\n    return _calculate_entropy(counts)\n\n# Internal function\ndef _calculate_entropy(counts: list[int]) -&gt; float:\n    \"\"\"Core entropy calculation from Shannon (1948).\n\n    Internal function that implements the entropy formula.\n    Assumes input has been validated.\n    \"\"\"\n    total = sum(counts)\n    probabilities = [c/total for c in counts]\n    return -sum(p * math.log2(p) for p in probabilities if p &gt; 0)\n</code></pre> <p>Put the external function at the beginning of the module, so that it's the first thing the user sees. Note that we prefix the internal function with an underscore, to indicate that it's not part of the public API.</p>"},{"location":"developer_notes/style/#notes","title":"Notes","text":"<p>In documentation, you can put the main points at the top and put details in a collapsible box later on. We prefer to put Notes after Attributes, Parameters, Returns, and Raises sections. If there is a \u201cnote\u201d that deserves to be seen more immediately, just write something like:</p> <pre><code>Note: see also [plot][amads.core.distribution.Distribution.plot]\n</code></pre> <p>while a full notes section would be written (below Parameters, Returns, etc.):</p> <pre><code>Notes\n-----\n\n- here is one detail we omitted in the docstring above\n- here is another detail\n- and the details just keep coming!\n</code></pre>"},{"location":"developer_notes/style/#references","title":"References","text":"<p>Include references with DOIs/URLs where possible. Here are some examples. Put References below Attributes, Parameters, Returns, Raises and Notes sections.</p> <pre><code>References\n----------\n[1] Ziv, J., &amp; Lempel, A. (1977). A universal algorithm for\n     sequential data compression.\n     IEEE Transactions on Information Theory. 23/3 (pp. 337\u2013343).\n     https://doi.org/10.1109/TIT.1977.1055714\n\n[2] Cheston, H., Schlichting, J. L., Cross, I., &amp; Harrison, P. M. C. (2024).\n     Rhythmic qualities of jazz improvisation predict performer\n     identity and style in source-separated audio recordings.\n     Royal Society Open Science. 11/11.\n     https://doi.org/10.1098/rsos.231023\n</code></pre>"},{"location":"developer_notes/testing/","title":"Testing","text":"<p>This project uses pytest for testing. To run the tests, follow these steps:</p>"},{"location":"developer_notes/testing/#prerequisites","title":"Prerequisites","text":"<p>Make sure you have the development dependencies installed:</p> <pre><code>pip install -e \".[dev]\"\n</code></pre>"},{"location":"developer_notes/testing/#running-all-tests","title":"Running all tests","text":"<p>From the root directory of the project, run:</p> <pre><code>pytest\n</code></pre>"},{"location":"developer_notes/testing/#running-specific-tests","title":"Running specific tests","text":"<p>To run tests in a specific file:</p> <pre><code>pytest tests/test_pitch_list_transformations.py\n</code></pre> <p>To run a specific test function:</p> <pre><code>pytest\ntests/test_pitch_list_transformations.py::test_function_name\n</code></pre>"},{"location":"developer_notes/testing/#testing-with-vscode","title":"Testing with VSCode","text":"<p>Install pytest-cov:</p> <pre><code>pip install pytest-cov\n</code></pre> <p>Install anyio:</p> <pre><code>pip install anyio\n</code></pre> <p>In VSCode, type Command Shift P and from the (large) command menu, find \u201cPython: Configure Tests\u201d. Select \u201cpytest\u201d and then \u201c. (Root directory)\u201d. Then all tests appear in the Test Explorer.</p> <p>To get to Test Explorer, select the Erlenmeyer (conical) flask icon in the far left column (pop-up description is \u201cTesting\u201d.</p> <p>Select a test or set of tests. In the selected test, there are small icons to run, run with debugger, or run with coverage, so pick one.</p>"},{"location":"developer_notes/testing/#writing-tests","title":"Writing tests","text":"<p>Tests are located in the <code>tests/</code> directory. Each test file should start with <code>test_</code> and each test function should also start with <code>test_</code>.</p> <p>Example test:</p> <pre><code>def test_my_function():\n    result = my_function()\n    assert result == expected_value\n</code></pre>"},{"location":"developer_notes/testing/#doctests","title":"Doctests","text":"<p>The project also uses doctests for testing code examples in docstrings. Doctests are written in the docstring of a function and show example usage with expected outputs. This is a great way to implement simple tests that also serve as useful documentation.</p> <p>Example doctest:</p> <pre><code>def entropy(d):\n    \"\"\"\n    Calculate the relative entropy of a distribution.\n\n    Parameters\n    ----------\n    d : list\n        The input distribution.\n\n    Returns\n    -------\n    float\n        The relative entropy (0 &lt;= H &lt;= 1).\n\n    Examples\n    --------\n    &gt;&gt;&gt; entropy([0.5, 0.5])\n    1.0\n\n    &gt;&gt;&gt; entropy(         # multiple line example\n    ...     [0.5, 0.5]\n    ... )\n    1.0\n    \"\"\"\n</code></pre> <p>These doctests are automatically run when you run <code>pytest</code>.</p>"},{"location":"developer_notes/testing/#continuous-integration","title":"Continuous Integration","text":"<p>Tests are automatically run via GitHub Actions CI on pushes to main and pull requests.</p> <p>You can view the CI configuration in <code>.github/workflows/tests.yml</code> and check test results in the \u201cActions\u201d tab of the GitHub repository.</p> <p>By default tests are run in the tests_main CI job. However, some tests that require bespoke dependencies are run in separate CI jobs (e.g. <code>tests_melsim</code>).</p>"},{"location":"developer_notes/testing/#code-coverage","title":"Code Coverage","text":"<p>To measure how much code is covered by tests</p> <ul> <li>Install <code>coverage</code>, e.g., <code>pip3 install coverage</code></li> <li>Install <code>pytest-cov</code>, e.g., <code>pip3 install pytest-cov</code></li> <li>Current directory should be the repo root ABOVE amads,    e.g., current directory should contain amads, tests, and demos</li> <li>Run <code>coverage run -m pytest</code></li> <li>View results with <code>coverage report</code> or <code>coverage html</code></li> </ul>"},{"location":"reference/basics/","title":"Classes Representing Basic Score Elements","text":""},{"location":"reference/basics/#amads.core.basics","title":"basics","text":"<p>Basic Symbolic Music Representation Classes</p> <pre><code>from amads.core import *\n</code></pre> <p>Note: <code>amads.core</code> includes <code>amads.core.basics</code>, <code>amads.core.distribution</code> and <code>amads.core.timemap</code>.</p>"},{"location":"reference/basics/#amads.core.basics--overview","title":"Overview","text":"<p>The basic hierarchy of a score is described here.</p> <p>Author: Roger B. Dannenberg</p> Constructor Details <p>The safe way to construct a score is to fully specify onsets for every Event.  These onsets are absolute and will not be adjusted provided that the parent onset is also specified.</p> <p>However, for convenience and to support simple constructs such as</p> <p>Chord(Note(pitch=60), Note(pitch=64)),</p> <p>onsets are optional and default to None. To make this simple example work:</p> <ul> <li> <p>Concurrences (Score, Part, and Chord) replace unspecified (None)   onsets in their immediate content with the parent's onset (or 0 if   it is None).</p> </li> <li> <p>Sequences (Staff, Measure) replace unspecified (None) onsets in   their immediate content starting with the parent's onset (or 0 if   None) for the first event and the offset of the previous Event for   subsequent events.</p> </li> <li> <p>To handle the construction of nested Events, when an unspecified   (None) onset of an EventGroup is replaced, the entire subtree of   its content is shifted by the same amount. E.g. if a Chord is   constructed with Notes with unspecified onsets, the Notes onsets   will initially be replaced with zeros. Then, if the Chord onset is   unspecified (None) and the Chord is passed in the content of a   Measure and the Chord onset is replaced with 1.0, then the Notes   are shifted to 1.0. If the Measure is then passed in the content of   a Staff, the Measure and all its content might be shifted again.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event","title":"Event","text":"<pre><code>Event(parent: EventGroup | None, onset: float | None, duration: float)\n</code></pre> <p>A superclass for Note, Rest, EventGroup, and anything happening in time.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>Event | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration of the event in quarters or seconds.</p> </li> <li> <code>info</code>               (<code>dict | None</code>)           \u2013            <p>Additional attribute/value information.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, parent: Optional[\"EventGroup\"],\n             onset: Optional[float], duration: float):\n    \"\"\"\n    Initialize an Event instance.\n\n    \"\"\"\n    self.parent = None  # set below when inserted into parent\n    self._onset = onset\n    self.duration = duration\n    self.info = None\n\n    if parent:\n        assert isinstance(parent, EventGroup)\n        parent.insert(self)\n    else:\n        self.parent = None\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics/#amads.core.basics.Event(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>)           \u2013            <p>The onset (start) time. This can be an \u201cidealized\u201d time for a symbolic score or an actual \u201creal\u201d time from a performance. Default is None.</p>"},{"location":"reference/basics/#amads.core.basics.Event(duration)","title":"<code>duration</code>","text":"(<code>float</code>)           \u2013            <p>The duration of the event in quarters or seconds. This can be zero for objects such as key signatures or time signatures.</p>"},{"location":"reference/basics/#amads.core.basics.Event-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Event.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Event-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Event.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Event.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Event.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Event.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Event.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Event.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float) -&gt; Event\n</code></pre> <p>Change the onset by an increment.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>Event</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float) -&gt; \"Event\":\n    \"\"\"\n    Change the onset by an increment.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `Event`.\n    \"\"\"\n    self._onset += increment  # type: ignore\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Event.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Event.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Note","title":"Note","text":"<pre><code>Note(\n    parent: EventGroup | None = None,\n    onset: float | None = None,\n    duration: float = 1.0,\n    pitch: Pitch | int | float | str | None = 60,\n    dynamic: int | str | None = None,\n    lyric: str | None = None,\n)\n</code></pre> <p>               Bases: <code>Event</code></p> <p>Note represents a musical note.</p> <p>A <code>Note</code> is normally an element of a <code>Measure</code> in a full score, and an element of a <code>Part</code> in a flat score.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time. None represents an unspecified onset.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration of the note in quarters or seconds. See the property <code>tied_duration</code> for the duration of an entire group if the note is the first of a tied group of notes.</p> </li> <li> <code>pitch</code>               (<code>Pitch | None</code>)           \u2013            <p>The pitch of the note. Unpitched notes have a pitch of None.</p> </li> <li> <code>dynamic</code>               (<code>int | str | None</code>)           \u2013            <p>Dynamic level (integer MIDI velocity or arbitrary string).</p> </li> <li> <code>lyric</code>               (<code>str | None</code>)           \u2013            <p>Lyric text.</p> </li> <li> <code>tie</code>               (<code>Note | None</code>)           \u2013            <p>The note that this note is tied to, if any.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__deepcopy__</code>             \u2013              <p>Return a (mostly) deep copy of the Note instance.</p> </li> <li> <code>__str__</code>             \u2013              <p>Short string representation.</p> </li> <li> <code>show</code>             \u2013              <p>Print note information.</p> </li> <li> <code>enharmonic</code>             \u2013              <p>Return a <code>Pitch</code> representing the enharmonic.</p> </li> <li> <code>upper_enharmonic</code>             \u2013              <p>Return a valid enharmonic Pitch with alt decreased, e.g., C#-&gt;Db.</p> </li> <li> <code>lower_enharmonic</code>             \u2013              <p>Return a valid enharmonic Pitch with alt increased, e.g., Db-&gt;C#.</p> </li> <li> <code>simplest_enharmonic</code>             \u2013              <p>Return a valid Pitch with the simplest enharmonic representation.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self,\n             parent: Optional[\"EventGroup\"] = None,\n             onset: Optional[float] = None,\n             duration: float = 1.0,\n             pitch: Union[\"Pitch\", int, float, str, None] = 60,\n             dynamic: Union[int, str, None] = None,\n             lyric: Optional[str] = None):\n    super().__init__(parent, onset, float(duration))\n    if isinstance(pitch, (int, float, str)):\n        pitch = Pitch(pitch)\n    self.pitch = pitch\n    self.dynamic = dynamic\n    self.lyric = lyric\n    self.tie = None\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics/#amads.core.basics.Note(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The onset (start) time. If None (default) is specified, a default onset will be calculated when the Note is inserted into an EventGroup.</p>"},{"location":"reference/basics/#amads.core.basics.Note(duration)","title":"<code>duration</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The duration of the note in quarters or seconds.</p>"},{"location":"reference/basics/#amads.core.basics.Note(pitch)","title":"<code>pitch</code>","text":"(<code>Pitch | int | float</code>, default:                   <code>60</code> )           \u2013            <p>A Pitch object or an integer MIDI key number that will be converted to a Pitch object. The default (60) represents middle C.</p>"},{"location":"reference/basics/#amads.core.basics.Note(dynamic)","title":"<code>dynamic</code>","text":"(<code>int | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Dynamic level (integer MIDI velocity or arbitrary string).</p>"},{"location":"reference/basics/#amads.core.basics.Note(lyric)","title":"<code>lyric</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Lyric text.</p>"},{"location":"reference/basics/#amads.core.basics.Note-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Note.tied_duration","title":"tied_duration  <code>property</code>","text":"<pre><code>tied_duration: float | int\n</code></pre> <p>Retrieve the duration of the note in quarters or seconds.</p> <p>If the note is the first note of a sequence of tied notes, return the duration of the entire sequence. However, if there are preceding notes tied to this note, they will not be considered part of the tied sequence. If you want to avoid processing notes that are tied to from earlier notes, you should either use merge_tied_notes() to eliminate them, or follow the <code>tie</code> links and add tied-to notes to a set as you traverse the score so you can ignore them when they are encountered. In some cases, notes can be tied across staves, in which case it might require two passes to (1) find all tied-to notes, and then (2) enumerate the rest of them. merge_tied_notes() handles this case properly.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The duration of the note and those it is tied to directly or indirectly, in quarters or seconds. The sum of durations is returned without checking whether notes are contiguous.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.step","title":"step  <code>property</code>","text":"<pre><code>step: str\n</code></pre> <p>Retrieve the name of the pitch without accidental, e.g., \"G\".</p> <p>If the note is unpitched (pitch is None), return the empty string.</p>"},{"location":"reference/basics/#amads.core.basics.Note.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>Retrieve the name of the pitch with accidental, e.g., \"Bb\".</p> <p>If the note is unpitched (pitch is None), return the empty string.</p>"},{"location":"reference/basics/#amads.core.basics.Note.name_with_octave","title":"name_with_octave  <code>property</code>","text":"<pre><code>name_with_octave: str\n</code></pre> <p>Retrieve the name of the pitch with octave, e.g., A4 or Bb3.</p> <p>If the note is unpitched (pitch is None), return the empty string.</p>"},{"location":"reference/basics/#amads.core.basics.Note.pitch_class","title":"pitch_class  <code>property</code> <code>writable</code>","text":"<pre><code>pitch_class: int\n</code></pre> <p>Retrieve the pitch class of the note, e.g., 0, 1, 2, ..., 11.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p>"},{"location":"reference/basics/#amads.core.basics.Note.octave","title":"octave  <code>property</code> <code>writable</code>","text":"<pre><code>octave: int\n</code></pre> <p>Retrieve the octave number of the note.</p> <p>The note name is based on <code>key_num - alt</code>, e.g., C4 has octave 4 while B#3 has octave 3. See also Pitch.register.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The octave number of the note.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.key_num","title":"key_num  <code>property</code>","text":"<pre><code>key_num: float | int\n</code></pre> <p>Retrieve the MIDI key number of the note, e.g., C4 = 60.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The MIDI key number of the note.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Note-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Note.__deepcopy__","title":"__deepcopy__","text":"<pre><code>__deepcopy__(memo: dict) -&gt; Note\n</code></pre> <p>Return a (mostly) deep copy of the Note instance.</p> <p>Except the pitch is shallow copied to avoid copying the entire Pitch object, which is considered immutable.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Note</code>           \u2013            <p>A deep copy of the Note instance with a shallow copy of the pitch.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __deepcopy__(self, memo: dict) -&gt; \"Note\":\n    \"\"\"Return a (mostly) deep copy of the Note instance.\n\n    Except the pitch is shallow copied to avoid copying\n    the entire Pitch object, which is considered immutable.\n\n    Parameters\n    ----------\n    memo : dict\n        A dictionary to keep track of already copied objects.\n\n    Returns\n    -------\n    Note\n        A deep copy of the Note instance with a shallow copy of the pitch.\n    \"\"\"\n    cls = self.__class__\n    result = cls.__new__(cls)\n    memo[id(self)] = result\n\n    # Iterate up the superclass chain and copy __slots__ at each level\n    # If there is a __dict__, it will be in a __slots__ and will be deep\n    # copied, so all attributes in __dict__ will be copied. If there is\n    # multiple inheritance with duplicated slots, this will copy the\n    # duplicated slot two (or more) times, but it should get the right\n    # result.\n    for base in cls.__mro__:\n        if hasattr(base, '__slots__'):\n            for slot in base.__slots__:\n                if slot == \"pitch\":\n                    result.pitch = self.pitch\n                else:\n                    setattr(result, slot,\n                            copy.deepcopy(getattr(self, slot), memo))\n\n    return result\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.__deepcopy__(memo)","title":"<code>memo</code>","text":"(<code>dict</code>)           \u2013            <p>A dictionary to keep track of already copied objects.</p>"},{"location":"reference/basics/#amads.core.basics.Note.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation.</p> <p>Returns:</p> <ul> <li> <code> str</code>           \u2013            <p>A short human-readable description of the note.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation.\n\n   Returns\n    -------\n    str\n        A short human-readable description of the note.\n    \"\"\"\n    dynamic_info = \"\"\n    if self.dynamic is not None:\n        dynamic_info = f\", dynamic={self.dynamic}\"\n\n    lyric_info = \"\"\n    if self.lyric is not None:\n        lyric_info = f\", lyric={self.lyric}\"\n\n    return (f\"Note({self._event_times()}{dynamic_info}{lyric_info}, \" +\n            f\"pitch={self.name_with_octave}/{self.key_num})\")\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.show","title":"show","text":"<pre><code>show(\n    indent: int = 0, file: TextIO | None = None, tied: bool = False\n) -&gt; Note\n</code></pre> <p>Print note information.</p> <p>Output includes pitch name, onset, duration, and optional tie, dynamic, and lyric information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Note</code>           \u2013            <p>The Note instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0, file: Optional[TextIO] = None,\n         tied: bool = False) -&gt; \"Note\":\n    \"\"\"Print note information.\n\n    Output includes pitch name, onset, duration, and optional\n    tie, dynamic, and lyric information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n    tied : bool\n        Include information about ties.\n\n    Returns\n    -------\n    Note\n        The Note instance itself.\n    \"\"\"\n    tie_info = \"\"\n    if self.tie is not None:\n        tie_info = \" tied\"\n    tie_prefix = \"  tied to \" if tied else \"\"\n\n    print(\" \" * indent, tie_prefix, self, tie_info, sep=\"\", file=file)\n    if self.tie:\n        self.tie.show(indent + 2, tied=True, file=file)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics/#amads.core.basics.Note.show(tied)","title":"<code>tied</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Include information about ties.</p>"},{"location":"reference/basics/#amads.core.basics.Note.enharmonic","title":"enharmonic","text":"<pre><code>enharmonic() -&gt; Pitch\n</code></pre> <p>Return a <code>Pitch</code> representing the enharmonic.</p> <p>The enharmonic <code>Pitch</code>'s <code>alt</code> will be zero or have the opposite sign such that <code>alt</code> is minimized. E.g., the enharmonic of C-double-flat is A-sharp (not B-flat). If <code>alt</code> is zero, return a Pitch with alt of +1 or -1 if possible. Otherwise, return a Pitch with alt of -2.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the enharmonic equivalent of the note.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def enharmonic(self) -&gt; \"Pitch\":\n    \"\"\"Return a `Pitch` representing the enharmonic.\n\n    The enharmonic `Pitch`'s `alt` will be zero or have the opposite\n    sign such that `alt` is minimized. E.g., the enharmonic of\n    C-double-flat is A-sharp (not B-flat). If `alt` is zero, return\n    a Pitch with alt of +1 or -1 if possible. Otherwise, return a\n    Pitch with alt of -2.\n\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the enharmonic equivalent of the note.\n    \"\"\"\n    if self.pitch is None:\n        raise ValueError(\"Unpitched note has no enharmonic equivalent.\")\n    return self.pitch.enharmonic()\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.upper_enharmonic","title":"upper_enharmonic","text":"<pre><code>upper_enharmonic() -&gt; Pitch\n</code></pre> <p>Return a valid enharmonic Pitch with alt decreased, e.g., C#-&gt;Db.</p> <p>It follows that the alt is decreased by 1 or 2, e.g., C### (with <code>alt</code> = +3) becomes D# (with <code>alt</code> = +1).</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the upper enharmonic equivalent of the note.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def upper_enharmonic(self) -&gt; \"Pitch\":\n    \"\"\"Return a valid enharmonic Pitch with alt decreased, e.g., C#-&gt;Db.\n\n    It follows that the alt is decreased by 1 or 2, e.g., C###\n    (with `alt` = +3) becomes D# (with `alt` = +1).\n\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the upper enharmonic\n        equivalent of the note.\n    \"\"\"\n    if self.pitch is None:\n        raise ValueError(\n                  \"Unpitched note has no upper enharmonic equivalent.\")\n    return self.pitch.upper_enharmonic()\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.lower_enharmonic","title":"lower_enharmonic","text":"<pre><code>lower_enharmonic() -&gt; Pitch\n</code></pre> <p>Return a valid enharmonic Pitch with alt increased, e.g., Db-&gt;C#.</p> <p>It follows that the alt is increased by 1 or 2, e.g., D# (with <code>alt</code> = +1) becomes C### (with <code>alt</code> = +3).</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the lower enharmonic equivalent of the note.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def lower_enharmonic(self) -&gt; \"Pitch\":\n    \"\"\"Return a valid enharmonic Pitch with alt increased, e.g., Db-&gt;C#.\n\n    It follows that the alt is increased by 1 or 2, e.g., D#\n    (with `alt` = +1) becomes C### (with `alt` = +3).\n\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the lower enharmonic\n        equivalent of the note.\n    \"\"\"\n    if self.pitch is None:\n        raise ValueError(\n                  \"Unpitched note has no lower enharmonic equivalent.\")\n    return self.pitch.lower_enharmonic()\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.simplest_enharmonic","title":"simplest_enharmonic","text":"<pre><code>simplest_enharmonic(sharp_or_flat: str | None = 'default') -&gt; Pitch\n</code></pre> <p>Return a valid Pitch with the simplest enharmonic representation.</p> <p>(See [simplest_enharmonic]  [amads.core.pitch.Pitch.simplest_enharmonic].)</p> <p>Parameters:</p> Exceptions <p>If the note is unpitched (pitch is None), raise ValueError.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the enharmonic equivalent.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def simplest_enharmonic(self, \n        sharp_or_flat: Optional[str] = \"default\") -&gt; \"Pitch\":\n    \"\"\"Return a valid Pitch with the simplest enharmonic representation.\n\n    (See [simplest_enharmonic]\n     [amads.core.pitch.Pitch.simplest_enharmonic].)\n\n    Parameters\n    ----------\n    sharp_or_flat: str\n        This is only relevant if the pitch needs an alteration, otherwise\n        it is unused. The value can be \"sharp\" (use sharps), \"flat\" (use\n        flats), and otherwise use the same enharmonic choice as the Pitch\n        constructor.\n\n    Exceptions\n    ----------\n    If the note is unpitched (pitch is None), raise ValueError.\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the enharmonic equivalent.\n    \"\"\"\n    if self.pitch is None:\n        raise ValueError(\n                  \"Unpitched note has no simplest enharmonic equivalent.\")\n    return self.pitch.simplest_enharmonic(sharp_or_flat)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.simplest_enharmonic(sharp_or_flat)","title":"<code>sharp_or_flat</code>","text":"(<code>str | None</code>, default:                   <code>'default'</code> )           \u2013            <p>This is only relevant if the pitch needs an alteration, otherwise it is unused. The value can be \"sharp\" (use sharps), \"flat\" (use flats), and otherwise use the same enharmonic choice as the Pitch constructor.</p>"},{"location":"reference/basics/#amads.core.basics.Note.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Note.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Note.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Note.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Note.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Note.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float) -&gt; Event\n</code></pre> <p>Change the onset by an increment.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>Event</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float) -&gt; \"Event\":\n    \"\"\"\n    Change the onset by an increment.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `Event`.\n    \"\"\"\n    self._onset += increment  # type: ignore\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Note.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Note.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Rest","title":"Rest","text":"<pre><code>Rest(\n    parent: EventGroup | None = None,\n    onset: float | None = None,\n    duration: float = 1,\n)\n</code></pre> <p>               Bases: <code>Event</code></p> <p>Rest represents a musical rest.</p> <p>A <code>Rest</code> is normally an element of a <code>Measure</code>.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float</code>)           \u2013            <p>The onset (start) time. None represents an unspecified onset.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration of the rest in quarters or seconds.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Display the Rest information.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, parent: Optional[\"EventGroup\"] = None,\n             onset: Optional[float] = None, duration: float = 1):\n    super().__init__(parent, onset, duration)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics/#amads.core.basics.Rest(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>The onset (start) time. An initial value of None might be assigned when the Note is inserted into an EventGroup.</p>"},{"location":"reference/basics/#amads.core.basics.Rest(duration)","title":"<code>duration</code>","text":"(<code>float</code>, default:                   <code>1</code> )           \u2013            <p>The duration of the rest in quarters or seconds.</p>"},{"location":"reference/basics/#amads.core.basics.Rest-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Rest.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Rest-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Rest.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"Rest({self._event_times()})\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; Rest\n</code></pre> <p>Display the Rest information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Rest</code>           \u2013            <p>The Rest instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0, file: Optional[TextIO] = None) -&gt; \"Rest\":\n    \"\"\"Display the Rest information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    Rest\n        The Rest instance itself.\n    \"\"\"\n\n    print(\" \" * indent, self, sep=\"\", file=file)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics/#amads.core.basics.Rest.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Rest.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Rest.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Rest.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Rest.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Rest.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float) -&gt; Event\n</code></pre> <p>Change the onset by an increment.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>Event</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float) -&gt; \"Event\":\n    \"\"\"\n    Change the onset by an increment.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `Event`.\n    \"\"\"\n    self._onset += increment  # type: ignore\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Rest.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Rest.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Measure","title":"Measure","text":"<pre><code>Measure(\n    *args: Event,\n    parent: EventGroup | None = None,\n    onset: float | None = None,\n    duration: float = 4,\n    number: str | None = None\n)\n</code></pre> <p>               Bases: <code>Sequence</code></p> <p>A Measure models a musical measure (bar).</p> <p>A Measure can contain many object types including Note, Rest, Chord, and (in theory) custom Events. Measures are elements of a Staff.</p> <p>See Constructor Details.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time. None represents \"unknown\" and to be determined when this object is added to a parent.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this Measure.</p> </li> <li> <code>number</code>               (<code>str | None</code>)           \u2013            <p>A string representing the measure number if any.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>time_signature</code>             \u2013              <p>Retrieve the time signature that applies to this measure.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust the content to be sequential.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, *args: Event, parent: Optional[EventGroup] = None,\n             onset: Optional[float] = None, duration: float = 4,\n             number: Optional[str] = None):\n    super().__init__(parent, onset, duration, list(args))\n    self.number = number\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure(*args)","title":"<code>*args</code>","text":"(<code>Event</code>, default:                   <code>()</code> )           \u2013            <p>A variable number of Event objects to be added to the group.</p>"},{"location":"reference/basics/#amads.core.basics.Measure(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Measure(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The onset (start) time. None means unknown, to be set when Sequence is added to a parent. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Measure(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>4</code> )           \u2013            <p>The duration in quarters or seconds. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Measure(number)","title":"<code>number</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A string representing the measure number. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Measure-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Measure.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Measure-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Measure.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    nstr = f\", number={self.number}\" if self.number else \"\"\n    return f\"Measure({self._event_times()}{nstr})\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.time_signature","title":"time_signature","text":"<pre><code>time_signature() -&gt; TimeSignature\n</code></pre> <p>Retrieve the time signature that applies to this measure.</p> <p>Returns:</p> <ul> <li> <code>TimeSignature</code>           \u2013            <p>The time signature from the score corresponding to the time of this measure.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If there is no Score or no onset time.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_signature(self) -&gt; TimeSignature:\n    \"\"\"Retrieve the time signature that applies to this measure.\n\n    Returns\n    -------\n    TimeSignature\n        The time signature from the score corresponding to the\n        time of this measure.\n\n    Raises\n    ------\n    ValueError\n        If there is no Score or no onset time.\n    \"\"\"\n    score = self.score\n    if score is None:\n        raise ValueError(\"Measure has no Score\")\n    else:  # find time sig at onset + a little to avoid rounding error:\n        return score._find_time_signature(self.onset + 0.001)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Measure.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = True) -&gt; float\n</code></pre> <p>Adjust the content to be sequential.</p> <p>The resulting content will begin with the parameter <code>onset</code> (defaults to 0), and each other object will get an onset equal to the offset of the previous element. The duration of self is set to the offset of the last element.  This method essentially arranges the content to eliminate gaps. pack() works recursively on elements that are <code>EventGroups</code>.</p> <p>Be careful not to pack <code>Measures</code> (directly or through recursion) if the Measure's content durations do not add up to the intended quarters per measure.</p> <p>To override the sequential behavior, set the <code>sequential</code>  parameter to False.  In that case, pack behaves like the <code>Concurrence.pack()</code> method.</p> <p>The pack method alters self and its content in place.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential: bool = True) -&gt; float:\n    \"\"\"Adjust the content to be sequential.\n\n    The resulting content will begin with the parameter `onset`\n    (defaults to 0), and each other object will get an onset equal\n    to the offset of the previous element. The duration of self is\n    set to the offset of the last element.  This method essentially\n    arranges the content to eliminate gaps. pack() works recursively\n    on elements that are `EventGroups`.\n\n    Be careful not to pack `Measures` (directly or through\n    recursion) if the Measure's content durations do not add up to\n    the intended quarters per measure.\n\n    To override the sequential behavior, set the `sequential` \n    parameter to False.  In that case, pack behaves like the\n    `Concurrence.pack()` method.\n\n    The pack method alters self and its content in place.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    return super().pack(onset, sequential)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Measure.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Measure.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics/#amads.core.basics.Staff","title":"Staff","text":"<pre><code>Staff(\n    *args: Event,\n    parent: EventGroup | None = None,\n    onset: float | None = 0,\n    duration: float | None = None,\n    number: int | None = None\n)\n</code></pre> <p>               Bases: <code>Sequence</code></p> <p>A Staff models a musical staff.</p> <p>This can also model one channel of a standard MIDI file track. A Staff normally contains Measure objects and is an element of a Part.</p> <p>See Constructor Details.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> <li> <code>number</code>               (<code>int | None</code>)           \u2013            <p>The staff number. Normally a Staff is given an integer number where 1 is the top staff of the part, 2 is the 2nd, etc.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>remove_measures</code>             \u2013              <p>Modify Staff by removing all Measures.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust the content to be sequential.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, *args: Event,\n             parent: Optional[EventGroup] = None,\n             onset: Optional[float] = 0,\n             duration: Optional[float] = None,\n             number: Optional[int] = None):\n    super().__init__(parent, onset, duration, list(args))\n    self.number = number\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff(*args)","title":"<code>*args</code>","text":"(<code>Event | None</code>, default:                   <code>()</code> )           \u2013            <p>A variable number of Event objects to be added to the group.</p>"},{"location":"reference/basics/#amads.core.basics.Staff(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics/#amads.core.basics.Staff(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>0</code> )           \u2013            <p>The onset (start) time. If unknown (None), it will be set when this Staff is added to a parent. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Staff(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration in quarters or seconds. (If duration is omitted or None, the duration is set so that self.offset ends at the max offset of args, or 0 if there is no content.) Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Staff(number)","title":"<code>number</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>The staff number. Normally, a Staff is given an integer number where 1 is the top staff of the part, 2 is the 2nd, etc. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Staff-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Staff.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Staff-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Staff.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    nstr = f\", number={self.number}\" if self.number else \"\"\n    return f\"Staff({self._event_times()}{nstr})\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.remove_measures","title":"remove_measures","text":"<pre><code>remove_measures() -&gt; Staff\n</code></pre> <p>Modify Staff by removing all Measures.</p> <p>Notes are \u201clifted\u201d from Measures to become direct content of this Staff. There is no special handling for notes tied to or from another Staff, so normally this method should be used only on a Staff where ties have been merged (see <code>merge_tied_notes()</code>). This method is normally called from <code>remove_measures()</code> in Part, which insures that this Staff is not shared, so it is safe to modify it. If called directly, the caller, to avoid unintended side effects, must ensure that this Staff is not shared data. Only Note and KeySignature objects are copied from Measures to the Staff. All other objects are removed.</p> <p>Returns:</p> <ul> <li> <code>Staff</code>           \u2013            <p>A Staff with all Measures removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_measures(self) -&gt; \"Staff\":\n    \"\"\"Modify Staff by removing all Measures.\n\n    Notes are \u201clifted\u201d from Measures to become direct content of this\n    Staff. There is no special handling for notes tied to or from another\n    Staff, so normally this method should be used only on a Staff where\n    ties have been merged (see `merge_tied_notes()`).\n    This method is normally called from `remove_measures()` in Part,\n    which insures that this Staff is not shared, so it is safe to\n    modify it. If called directly, the caller, to avoid unintended\n    side effects, must ensure that this Staff is not shared data.\n    Only Note and KeySignature objects are copied from Measures\n    to the Staff. All other objects are removed.\n\n    Returns\n    -------\n    Staff\n        A Staff with all Measures removed.\n    \"\"\"\n    new_content = []\n    for measure in self.content:\n        if isinstance(measure, Measure):\n            for event in measure.content:\n                if isinstance(event, (Note, KeySignature)):\n                    new_content.append(event)\n                # else ignore the event\n        else:  # non-Measure objects are simply copied\n            new_content.append(measure)\n    self.content = new_content\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Staff.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = True) -&gt; float\n</code></pre> <p>Adjust the content to be sequential.</p> <p>The resulting content will begin with the parameter <code>onset</code> (defaults to 0), and each other object will get an onset equal to the offset of the previous element. The duration of self is set to the offset of the last element.  This method essentially arranges the content to eliminate gaps. pack() works recursively on elements that are <code>EventGroups</code>.</p> <p>Be careful not to pack <code>Measures</code> (directly or through recursion) if the Measure's content durations do not add up to the intended quarters per measure.</p> <p>To override the sequential behavior, set the <code>sequential</code>  parameter to False.  In that case, pack behaves like the <code>Concurrence.pack()</code> method.</p> <p>The pack method alters self and its content in place.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential: bool = True) -&gt; float:\n    \"\"\"Adjust the content to be sequential.\n\n    The resulting content will begin with the parameter `onset`\n    (defaults to 0), and each other object will get an onset equal\n    to the offset of the previous element. The duration of self is\n    set to the offset of the last element.  This method essentially\n    arranges the content to eliminate gaps. pack() works recursively\n    on elements that are `EventGroups`.\n\n    Be careful not to pack `Measures` (directly or through\n    recursion) if the Measure's content durations do not add up to\n    the intended quarters per measure.\n\n    To override the sequential behavior, set the `sequential` \n    parameter to False.  In that case, pack behaves like the\n    `Concurrence.pack()` method.\n\n    The pack method alters self and its content in place.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    return super().pack(onset, sequential)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Staff.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Staff.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics/#amads.core.basics.Part","title":"Part","text":"<pre><code>Part(\n    *args: Event,\n    parent: Score | None = None,\n    onset: float = 0.0,\n    duration: float | None = None,\n    number: str | None = None,\n    instrument: str | None = None,\n    flat: bool = False\n)\n</code></pre> <p>               Bases: <code>EventGroup</code></p> <p>A Part models a staff or staff group such as a grand staff.</p> <p>For that reason, a Part contains one or more Staff objects. It should not contain any other object types. Parts are normally elements of a Score. Note that in a flat score, a Part is a collection of Notes, not Staffs, and it should be organized more sequentially than concurrently, so the default assignment of onset times may not be appropriate.</p> <p>See Constructor Details.</p> <p>Part is an EventGroup rather than a Sequence or Concurrence because in flat scores, it acts like a Sequence of notes, but in full scores, it is like a Concurrence of Staff objects.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> <li> <code>number</code>               (<code>str | None</code>)           \u2013            <p>A string representing the part number (if any). E.g., \"22a\".</p> </li> <li> <code>instrument</code>               (<code>str | None</code>)           \u2013            <p>A string representing the instrument name (if any).</p> </li> </ul> Notes <pre><code>Standard MIDI File tracks often have text instrument names in\ntype 4 meta events. These are stored in the `instrument` attribute.\nTracks often contain events for a single MIDI channel and a single\n\u201cprogram\u201d that is another representation of \u201cinstrument.\u201d In fact,\nthe `pretty_midi` library considers MIDI program to be a property\nof the track rather than a timed event within the track (many\nsequencers use this model as well). Therefore, if there is a\nsingle MIDI program in a track (or an AMADS Part), the program\nnumber (int) is stored in `info` using the key `\"midi_program\"`.\n</code></pre> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>is_well_formed_full_part</code>             \u2013              <p>Test if Part is measured and well-formed.</p> </li> <li> <code>flatten</code>             \u2013              <p>Build a flat Part where content will consist of notes only.</p> </li> <li> <code>is_flat</code>             \u2013              <p>Test if Part is flat (contains only notes without ties).</p> </li> <li> <code>remove_measures</code>             \u2013              <p>Return a Part with all Measures removed.</p> </li> <li> <code>calc_differences</code>             \u2013              <p>Calculate inter-onset intervals (IOIs), IOI-ratios and intervals.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust the content to onsets starting with the onset parameter.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, *args: Event,\n             parent: Optional[Score] = None,\n             onset: float = 0.0,\n             duration: Optional[float] = None,\n             number: Optional[str] = None,\n             instrument: Optional[str] = None,\n             flat: bool = False):\n    content = list(args)\n    if flat:  # adjust onsets to form a sequence (must be done before\n        prev_onset : float = 0.0  # onset of previous note\n        prev_offset : float = 0.0  # offset of previous note\n        if not onset is None:\n            prev_onset = onset\n            prev_offset = onset\n        for elem in content:\n            if elem.parent and elem.parent != self:\n                raise ValueError(\"Event already has a parent\")\n            elem.parent = self  # type: ignore\n            if elem.onset is None:\n                elem.onset = prev_offset\n            elif elem.onset &lt; prev_onset:\n                raise ValueError(\"Event onsets are not in time order\")\n            prev_onset = elem.onset\n            prev_offset = elem.offset\n        packed_args = []\n    super().__init__(parent, onset, duration, content)\n    self.number = number\n    self.instrument = instrument\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part(*args)","title":"<code>*args</code>","text":"(<code>Event | None</code>, default:                   <code>()</code> )           \u2013            <p>A variable number of Event objects to be added to the group. parent : Optional[EventGroup] The containing object or None. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Part(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time. If unknown (None), it will be set when this Part is added to a parent. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Part(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration in quarters or seconds. (If duration is omitted or None, the duration is set so that self.offset ends at the max offset of args, or 0 if there is no content.)  Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Part(number)","title":"<code>number</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A string representing the part number.</p>"},{"location":"reference/basics/#amads.core.basics.Part(instrument)","title":"<code>instrument</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>A string representing the instrument name.</p>"},{"location":"reference/basics/#amads.core.basics.Part(flat)","title":"<code>flat</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, content in <code>*args</code> with onset None are modified to start at the offset of the previous note (or at <code>onset</code> if this is the first Event in <code>*args</code>, or at 0.0 if <code>onset</code> is unspecified). Otherwise, this is assumed to be a Part in a full score, <code>*args</code> is assumed to contain <code>Staff</code>s, and their default onset times are given <code>onset</code> by onset (or 0.0 if <code>onset</code> is unspecified). This  must be passed as a keyword argument due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Part-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Part.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Part-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Part.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    nstr = f\", number={self.number}\" if self.number else \"\"\n    name = f\", instrument={self.instrument}\" if self.instrument else \"\"\n    return f\"Part({self._event_times()}{nstr}{name})\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.is_well_formed_full_part","title":"is_well_formed_full_part","text":"<pre><code>is_well_formed_full_part()\n</code></pre> <p>Test if Part is measured and well-formed.</p> <p>Part must conform to a strict hierarchy of: Part-Staff-Measure-(Note or Rest or Chord) and Chord-Note.</p> Source code in <code>amads/core/basics.py</code> <pre><code>def is_well_formed_full_part(self):\n    \"\"\"Test if Part is measured and well-formed.\n\n    Part must conform to a strict hierarchy of:\n    Part-Staff-Measure-(Note or Rest or Chord) and Chord-Note.\n    \"\"\"\n    for staff in self.content:  # type: ignore (Part contains Staffs)\n        staff : Staff\n        # only Staffs are expected, but things outside of the hierarchy\n        # are allowed, so we only rule out violations of the hierarchy:\n        if isinstance(staff, (Score, Part, Measure, Note, Rest, Chord)):\n            return False\n        if isinstance(staff, Staff) and not staff._is_well_formed():\n            return False\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.flatten","title":"flatten","text":"<pre><code>flatten(in_place=False)\n</code></pre> <p>Build a flat Part where content will consist of notes only.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Part</code>           \u2013            <p>a new part that has been flattened</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def flatten(self, in_place=False):\n    \"\"\"Build a flat Part where content will consist of notes only.\n\n    Parameters\n    ----------\n    in_place : bool\n        If in_place=True, assume Part already has no ties and can be\n        modified. Otherwise, return a new Part where deep copies of\n        tied notes are merged.\n\n    Returns\n    -------\n    Part\n        a new part that has been flattened\n    \"\"\"\n    part = self if in_place else self.merge_tied_notes()\n    notes : List[Note] \\\n          = part.list_all(Note)  # type: ignore (Notes &lt; Events)\n    for note in notes:\n        note.parent = part\n    notes.sort(key=lambda x: (x.onset, x.pitch))\n    part.content = notes  # type: ignore (List[Note] &lt; List[Event])\n    return part\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.flatten(in_place)","title":"<code>in_place</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If in_place=True, assume Part already has no ties and can be modified. Otherwise, return a new Part where deep copies of tied notes are merged.</p>"},{"location":"reference/basics/#amads.core.basics.Part.is_flat","title":"is_flat","text":"<pre><code>is_flat()\n</code></pre> <p>Test if Part is flat (contains only notes without ties).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the Part is flat</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def is_flat(self):\n    \"\"\"Test if Part is flat (contains only notes without ties).\n\n    Returns\n    -------\n    bool\n        True iff the Part is flat\n    \"\"\"\n    for note in self.content:\n        # only Notes without ties are expected, but things outside of\n        # the hierarchy are allowed, so we only rule out violations of\n        # the hierarchy:\n        if isinstance(note, (Score, Part, Staff, Measure, Rest, Chord)):\n            return False\n        if isinstance(note, Note) and note.tie is not None:\n            return False\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.remove_measures","title":"remove_measures","text":"<pre><code>remove_measures(score: Score | None, has_ties: bool = True) -&gt; Part\n</code></pre> <p>Return a Part with all Measures removed.</p> <p>Preserves Staffs in the hierarchy. Notes are \u201clifted\u201d from Measures to become direct content of their Staff. Uses <code>merge_tied_notes()</code> to copy this Part unless <code>has_ties</code> is False, in which case there must be no tied notes and this Part is modified. (Note: it is harmless for <code>has_ties</code> to be True even if there are no ties. This will simply copy the Part before removing measures.)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Part</code>           \u2013            <p>A Part with all Measures removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_measures(self, score: Optional[\"Score\"],\n                    has_ties: bool = True) -&gt; \"Part\":\n    \"\"\"Return a Part with all Measures removed.\n\n    Preserves Staffs in the hierarchy. Notes are \u201clifted\u201d from Measures\n    to become direct content of their Staff. Uses `merge_tied_notes()`\n    to copy this Part unless `has_ties` is False, in which case\n    there must be no tied notes and this Part is modified. (Note: it is\n    harmless for `has_ties` to be True even if there are no ties. This\n    will simply copy the Part before removing measures.)\n\n    Parameters\n    ----------\n    score : Union[Score, None]\n        The Score instance (if any) to which the new Part will be added.\n    has_ties : bool\n        If False, assume this is a copy we are free to modify,\n        there are tied notes, and this Part is already contained\n        by `score`. If True, this Part will be copied into `score`.\n\n    Returns\n    -------\n    Part\n        A Part with all Measures removed.\n    \"\"\"\n    part : Part = (self.merge_tied_notes(score) \n                   if has_ties else self)  # type: ignore\n    for staff in part.content:\n        if isinstance(staff, Staff):\n            staff.remove_measures()\n    return part\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.remove_measures(score)","title":"<code>score</code>","text":"(<code>Score | None</code>)           \u2013            <p>The Score instance (if any) to which the new Part will be added.</p>"},{"location":"reference/basics/#amads.core.basics.Part.remove_measures(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If False, assume this is a copy we are free to modify, there are tied notes, and this Part is already contained by <code>score</code>. If True, this Part will be copied into <code>score</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Part.calc_differences","title":"calc_differences","text":"<pre><code>calc_differences(what: list[str]) -&gt; list[Note]\n</code></pre> <p>Calculate inter-onset intervals (IOIs), IOI-ratios and intervals.</p> <p>This method modifies the Part in place, calculating several differences between notes. Onset differences (IOIs) are the time differences between a Note's onset and the onset of the previous Note in the same Part (regardless of Staff). The IOI of the first Note in the Part is set to None. The IOI values are computed when <code>what</code> contains \"ioi\" or \"ioi_ratio\" and stored as <code>\"ioi\"</code> in the Note's <code>info</code> dictionary.</p> <p>The IOI-ratio of a Note is the ratio of its IOI to the IOI of the previous Note. The IOI-ratios of the first two Notes are set to None. The IOI-ratio values are computed when <code>what</code> contains \"ioi_ratio\" and stored as <code>\"ioi_ratio\"</code> in the Note's <code>info</code> dictionary.</p> <p>The pitch interval of a Note is the difference in semitones between its pitch and the pitch of the previous Note in the same Part. The interval of the first Note in the Part is set to None. The interval values are computed when <code>what</code> contains \"interval\" and stored as <code>\"interval\"</code> in the Note's <code>info</code> dictionary.</p> <p>Note that this method assumes that the Part has no concurrent Notes (IOI == 0) and no ties. In either case, a ValueError is raised.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If there are tied notes or concurrent notes in the Part or if <code>what</code> does not contain any of \"ioi\", \"ioi_ratio\" or \"interval\".</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Note]</code>           \u2013            <p>The sorted list of Notes with calculated IOIs and IOI-ratios.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def calc_differences(self, what: List[str]) -&gt; List[Note]:\n    \"\"\"Calculate inter-onset intervals (IOIs), IOI-ratios and intervals.\n\n    This method modifies the Part in place, calculating several\n    differences between notes. Onset differences (IOIs) are the\n    time differences between a Note's onset and the onset of the\n    previous Note in the same Part (regardless of Staff). The IOI\n    of the first Note in the Part is set to None. The IOI values\n    are computed when `what` contains \"ioi\" or \"ioi_ratio\" and\n    stored as `\"ioi\"` in the Note's `info` dictionary.\n\n    The IOI-ratio of a Note is the ratio of its IOI to the IOI of\n    the previous Note. The IOI-ratios of the first two Notes are set\n    to None. The IOI-ratio values are computed when `what` contains\n    \"ioi_ratio\" and stored as `\"ioi_ratio\"` in the Note's `info`\n    dictionary.\n\n    The pitch interval of a Note is the difference in semitones between\n    its pitch and the pitch of the previous Note in the same Part. The\n    interval of the first Note in the Part is set to None. The interval\n    values are computed when `what` contains \"interval\" and stored\n    as `\"interval\"` in the Note's `info` dictionary.\n\n    Note that this method assumes that the Part has no concurrent\n    Notes (IOI == 0) and no ties. In either case, a ValueError is raised.\n\n    Parameters\n    ----------\n    what : list of str\n        A list of strings indicating what differences to compute.\n        Valid strings are: 'ioi' (for inter-onset intervals),\n        'ioi_ratio' (for ratio of successive IOIs), and\n        'interval' (for pitch intervals in semitones).\n\n    Raises\n    ------\n    ValueError\n        If there are tied notes or concurrent notes in the Part or if\n        `what` does not contain any of \"ioi\", \"ioi_ratio\" or \"interval\".\n\n    Returns\n    -------\n    List[Note]\n        The sorted list of Notes with calculated IOIs and IOI-ratios.\n    \"\"\"\n    # this will raise an exception if there are ties:\n    notes : List[Note] = self.get_sorted_notes(has_ties=False)\n    do_ioi = \"ioi\" in what or \"ioi_ratio\" in what\n    do_interval = \"interval\" in what\n    do_ioi_ratio = \"ioi_ratio\" in what\n    if not (do_ioi or do_interval or do_ioi_ratio):\n        raise ValueError(\n                \"what must contain 'ioi', 'ioi_ratio' or 'interval'\")\n    if len(notes) == 0:\n        return []  # nothing to do\n    else:\n        if do_ioi:\n            notes[0].set(\"ioi\", None)\n        if do_ioi_ratio:\n            notes[0].set(\"ioi_ratio\", None)\n        if do_interval:\n            notes[0].set(\"interval\", None)\n\n    prev_ioi : Optional[float] = None\n    prev_note : Note = notes[0]\n    for note in notes[1 : ]:\n        if do_ioi:\n            ioi = note.onset - prev_note.onset\n            if ioi &lt;= 0:\n                raise ValueError(\n                        \"Part is not monophonic; cannot compute IOIs\")\n            note.set(\"ioi\", ioi)\n        if do_ioi_ratio:\n            if prev_ioi is None:\n                note.set(\"ioi_ratio\", None)\n            else:  # ignore typing because ioi is bound earlier:\n                note.set(\"ioi_ratio\", ioi / prev_ioi)  # type: ignore\n            prev_ioi = ioi  # type: ignore (ioi is bound if do_ioi) \n        if do_interval:\n            note.set(\"interval\", note.key_num - prev_note.key_num)\n        prev_note = note\n    return notes\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.calc_differences(what)","title":"<code>what</code>","text":"(<code>list of str</code>)           \u2013            <p>A list of strings indicating what differences to compute. Valid strings are: 'ioi' (for inter-onset intervals), 'ioi_ratio' (for ratio of successive IOIs), and 'interval' (for pitch intervals in semitones).</p>"},{"location":"reference/basics/#amads.core.basics.Part.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Part.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Part.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Part.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Part.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Part.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Part.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics/#amads.core.basics.Part.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Part.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Part.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics/#amads.core.basics.Part.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Part.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics/#amads.core.basics.Part.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics/#amads.core.basics.Part.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics/#amads.core.basics.Part.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Part.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics/#amads.core.basics.Part.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics/#amads.core.basics.Part.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = False) -&gt; float\n</code></pre> <p>Adjust the content to onsets starting with the onset parameter.</p> <p>By default onsets are set to <code>onset</code> and the duration of self is set to the maximum duration of the content. pack() works recursively on elements that are EventGroups. Setting sequential to True implements sequential packing, where events are placed one after another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential : bool = False) -&gt; float:\n    \"\"\"Adjust the content to onsets starting with the onset parameter.\n\n    By default onsets are set to `onset` and the duration of self is set to\n    the maximum duration of the content. pack() works recursively on\n    elements that are EventGroups. Setting sequential to True implements\n    sequential packing, where events are placed one after another.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    self.onset = onset\n    self.duration = 0\n    for elem in self.content:\n        elem.onset = onset\n        if isinstance(elem, EventGroup):   # either Sequence or Concurrence\n            elem.duration = elem.pack(onset)  #type: ignore\n        if sequential:\n            onset += elem.duration\n        else:\n            self.duration = max(self.duration, elem.duration)\n    if sequential:\n        self.duration = onset - self.onset\n    return self.duration\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics/#amads.core.basics.Part.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics/#amads.core.basics.Part.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics/#amads.core.basics.Part.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Part.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Part.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics/#amads.core.basics.Score","title":"Score","text":"<pre><code>Score(\n    *args: Event,\n    onset: float | None = 0,\n    duration: float | None = None,\n    time_map: TimeMap | None = None,\n    time_signatures: list[TimeSignature] | None = None\n)\n</code></pre> <p>               Bases: <code>Concurrence</code></p> <p>A Score (abstract class) represents a musical work.</p> <p>Normally, a Score contains Part objects, all with onsets zero, and has no parent.</p> <p>See Constructor Details.</p> <p>Additional properties may be assigned, e.g., 'title', 'source_file', 'composer', etc. (See set.)</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> <li> <code>time_map</code>               (<code>TimeMap</code>)           \u2013            <p>A map from quarters to seconds (or seconds to quarters).</p> </li> <li> <code>time_signatures</code>               (<code>list[TimeSignature]</code>)           \u2013            <p>A list of all time signature changes</p> </li> <li> <code>_units_are_seconds</code>               (<code>bool</code>)           \u2013            <p>True if the units are seconds, False if the units are quarters.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>from_melody</code>             \u2013              <p>Create a Score from a melody specified by pitches and timing.</p> </li> <li> <code>copy</code>             \u2013              <p>Make a deep copy.</p> </li> <li> <code>emptycopy</code>             \u2013              <p>Copy score without content.</p> </li> <li> <code>append_time_signature</code>             \u2013              <p>Append a time signature change to the score.</p> </li> <li> <code>calc_differences</code>             \u2013              <p>Calculate inter-onset intervals (IOIs), IOI-ratios and intervals.</p> </li> <li> <code>convert_to_seconds</code>             \u2013              <p>Convert the score to represent time in seconds.</p> </li> <li> <code>convert_to_quarters</code>             \u2013              <p>Convert the score to represent time in quarters.</p> </li> <li> <code>collapse_parts</code>             \u2013              <p>Merge the notes of selected Parts and Staffs.</p> </li> <li> <code>flatten</code>             \u2013              <p>Deep copy notes in a score to a flat score.</p> </li> <li> <code>is_flat</code>             \u2013              <p>Test if Score is flat.</p> </li> <li> <code>is_flat_and_collapsed</code>             \u2013              <p>Determine if score has been flattened into one part</p> </li> <li> <code>is_well_formed_full_score</code>             \u2013              <p>Test if Score is a well-formed full score.</p> </li> <li> <code>note_containers</code>             \u2013              <p>Returns a list of non-empty note containers.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust onsets to pack events in the entire Score.</p> </li> <li> <code>part_count</code>             \u2013              <p>How many parts are in this score?</p> </li> <li> <code>parts_are_monophonic</code>             \u2013              <p>Determine if each part of a musical score is monophonic.</p> </li> <li> <code>remove_measures</code>             \u2013              <p>Create a new Score with all Measures removed.</p> </li> <li> <code>show</code>             \u2013              <p>Print the Score information.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, *args: Event,\n             onset: Optional[float] = 0,\n             duration: Optional[float] = None,\n             time_map: Optional[\"TimeMap\"] = None,\n             time_signatures: Optional[List[TimeSignature]] = None):\n    super().__init__(None, onset, duration, list(args))  # parent is None\n    self.time_map = time_map if time_map else TimeMap()\n    self.time_signatures = (\n            time_signatures if time_signatures else [TimeSignature(0)])\n    self._units_are_seconds = False\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score(*args)","title":"<code>*args</code>","text":"(<code>Event</code>, default:                   <code>()</code> )           \u2013            <p>A variable number of Event objects to be added to the group.</p>"},{"location":"reference/basics/#amads.core.basics.Score(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>0</code> )           \u2013            <p>The onset (start) time. If unknown (None), onset will be set when the score is added to a parent, but normally, Scores do not have parents, so the default onset is 0. You can override this using keyword parameter (due to <code>*args</code>).</p>"},{"location":"reference/basics/#amads.core.basics.Score(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration in quarters or seconds. (If duration is omitted or None, the duration is set so that self.offset ends at the max offset of args, or 0 if there is no content.) Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Score(time_map)","title":"<code>time_map</code>","text":"(<code>TimeMap</code>, default:                   <code>None</code> )           \u2013            <p>A map from quarters to seconds (or seconds to quarters). Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics/#amads.core.basics.Score-attributes","title":"Attributes","text":""},{"location":"reference/basics/#amads.core.basics.Score.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>True if the units are in quarters, False if in seconds.</p>"},{"location":"reference/basics/#amads.core.basics.Score.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>True if the units are in seconds, False if in quarters.</p>"},{"location":"reference/basics/#amads.core.basics.Score.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Score.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Score.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics/#amads.core.basics.Score-functions","title":"Functions","text":""},{"location":"reference/basics/#amads.core.basics.Score.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"{self.__class__.__name__}({self._event_times()}, \" + \\\n           f\"units={'seconds' if self._units_are_seconds else 'quarters'})\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.from_melody","title":"from_melody  <code>classmethod</code>","text":"<pre><code>from_melody(\n    pitches: list[Pitch | int | float | str],\n    durations: float | list[float] = 1.0,\n    iois: float | list[float] | None = None,\n    onsets: list[float] | None = None,\n    ties: list[bool] | None = None,\n) -&gt; Score\n</code></pre> <p>Create a Score from a melody specified by pitches and timing.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>A new (flat) Score object containing the melody. If pitches is empty, returns a score with an empty part.</p> </li> </ul> <p>Examples:</p> <p>Create a simple C major scale with default timing (sequential quarter notes):</p> <pre><code>&gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65, 67, 69, 71, 72])  # all quarter notes\n&gt;&gt;&gt; notes = score.content[0].content\n&gt;&gt;&gt; len(notes)  # number of notes in first part\n8\n&gt;&gt;&gt; notes[0].key_num\n60\n&gt;&gt;&gt; score.duration  # last note ends at t=8\n8.0\n</code></pre> <p>Create three notes with varying durations:</p> <pre><code>&gt;&gt;&gt; score = Score.from_melody(\n...     pitches=[60, 62, 64],  # C4, D4, E4\n...     durations=[0.5, 1.0, 2.0],\n... )\n&gt;&gt;&gt; score.duration  # last note ends at t=3.5\n3.5\n</code></pre> <p>Create three notes with custom IOIs:</p> <pre><code>&gt;&gt;&gt; score = Score.from_melody(\n...     pitches=[60, 62, 64],  # C4, D4, E4\n...     durations=1.0,  # quarter notes\n...     iois=2.0,  # 2 beats between each note onset\n... )\n&gt;&gt;&gt; score.duration  # last note ends at t=5\n5.0\n</code></pre> <p>Create three notes with explicit onsets:</p> <pre><code>&gt;&gt;&gt; score = Score.from_melody(\n...     pitches=[60, 62, 64],  # C4, D4, E4\n...     durations=1.0,  # quarter notes\n...     onsets=[0.0, 2.0, 4.0],  # onset times 2 beats apart\n... )\n&gt;&gt;&gt; score.duration  # last note ends at t=5\n5.0\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>@classmethod\ndef from_melody(cls,\n                pitches: list[Union[Pitch, int, float, str]],\n                durations: Union[float, list[float]] = 1.0,\n                iois: Optional[Union[float, list[float]]] = None,\n                onsets: Optional[list[float]] = None,\n                ties: Optional[list[bool]] = None) -&gt; \"Score\":\n    \"\"\"Create a Score from a melody specified by pitches and timing.\n\n    Parameters\n    ----------\n    pitches : list of int or list of Pitch\n        MIDI note numbers or Pitch objects for each note.\n    durations : float or list of float\n        Durations in quarters for each note. If a scalar value,\n        it will be repeated for all notes.\n    iois : float or list of float or None Inter-onset\n        intervals between successive notes. If a scalar value,\n        it will be repeated for all notes. If not provided and\n        onsets is None, takes values from the durations argument,\n        assuming that notes are placed sequentially without overlap.\n    onsets : list of float or None\n        Start times. Cannot be used together with iois.\n        If both are None, defaults to using durations as IOIs.\n    ties : list of bool or None\n        If provided, a list of booleans indicating whether each\n        note is tied to the next note. The last note's tie value\n        is ignored. If None, no ties are created.\n\n    Returns\n    -------\n    Score\n        A new (flat) Score object containing the melody. If pitches\n        is empty, returns a score with an empty part.\n\n    Examples\n    --------\n    Create a simple C major scale with default timing (sequential quarter notes):\n\n    &gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65, 67, 69, 71, 72])  # all quarter notes\n    &gt;&gt;&gt; notes = score.content[0].content\n    &gt;&gt;&gt; len(notes)  # number of notes in first part\n    8\n    &gt;&gt;&gt; notes[0].key_num\n    60\n    &gt;&gt;&gt; score.duration  # last note ends at t=8\n    8.0\n\n    Create three notes with varying durations:\n\n    &gt;&gt;&gt; score = Score.from_melody(\n    ...     pitches=[60, 62, 64],  # C4, D4, E4\n    ...     durations=[0.5, 1.0, 2.0],\n    ... )\n    &gt;&gt;&gt; score.duration  # last note ends at t=3.5\n    3.5\n\n    Create three notes with custom IOIs:\n\n    &gt;&gt;&gt; score = Score.from_melody(\n    ...     pitches=[60, 62, 64],  # C4, D4, E4\n    ...     durations=1.0,  # quarter notes\n    ...     iois=2.0,  # 2 beats between each note onset\n    ... )\n    &gt;&gt;&gt; score.duration  # last note ends at t=5\n    5.0\n\n    Create three notes with explicit onsets:\n\n    &gt;&gt;&gt; score = Score.from_melody(\n    ...     pitches=[60, 62, 64],  # C4, D4, E4\n    ...     durations=1.0,  # quarter notes\n    ...     onsets=[0.0, 2.0, 4.0],  # onset times 2 beats apart\n    ... )\n    &gt;&gt;&gt; score.duration  # last note ends at t=5\n    5.0\n    \"\"\"\n    if len(pitches) == 0:\n        return cls._from_melody(pitches=[], onsets=[], durations=[], ties=None)\n\n    if iois is not None and onsets is not None:\n        raise ValueError(\"Cannot specify both iois and onsets\")\n\n    # Convert scalar durations to list\n    if isinstance(durations, (int, float)):\n        durations = [float(durations)] * len(pitches)\n\n    # If onsets are provided, use them directly\n    if onsets is not None:\n        if len(onsets) != len(pitches):\n            raise ValueError(\"onsets list must have same length as pitches\")\n        onsets = [float(d) for d in onsets]\n\n    # Otherwise convert IOIs to onsets\n    else:  # onsets is Nonex\n        onsets = [0.0]\n        # If no IOIs provided, use durations as default IOIs\n        if iois is None:\n            iois = durations[:-1]  # last duration not needed for IOIs\n        # Convert scalar IOIs to list\n        elif isinstance(iois, (int, float)):\n            iois = [float(iois)] * (len(pitches) - 1)\n\n        # Validate IOIs length\n        if len(iois) != len(pitches) - 1:\n            raise ValueError(\"iois list must have length len(pitches) - 1\")\n\n        # Convert IOIs to onsets\n        onsets = [0.0]  # first note onsets at 0\n        current_time = 0.0\n        for ioi in iois:\n            current_time += float(ioi)\n            onsets.append(current_time)\n\n    if not (len(pitches) == len(onsets) == len(durations)):\n        raise ValueError(\"All input lists must have the same length\")\n\n    return cls._from_melody(pitches, onsets, durations, ties)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.from_melody(pitches)","title":"<code>pitches</code>","text":"(<code>list of int or list of Pitch</code>)           \u2013            <p>MIDI note numbers or Pitch objects for each note.</p>"},{"location":"reference/basics/#amads.core.basics.Score.from_melody(durations)","title":"<code>durations</code>","text":"(<code>float or list of float</code>, default:                   <code>1.0</code> )           \u2013            <p>Durations in quarters for each note. If a scalar value, it will be repeated for all notes.</p>"},{"location":"reference/basics/#amads.core.basics.Score.from_melody(iois)","title":"<code>iois</code>","text":"(<code>float or list of float or None Inter-onset</code>, default:                   <code>None</code> )           \u2013            <p>intervals between successive notes. If a scalar value, it will be repeated for all notes. If not provided and onsets is None, takes values from the durations argument, assuming that notes are placed sequentially without overlap.</p>"},{"location":"reference/basics/#amads.core.basics.Score.from_melody(onsets)","title":"<code>onsets</code>","text":"(<code>list of float or None</code>, default:                   <code>None</code> )           \u2013            <p>Start times. Cannot be used together with iois. If both are None, defaults to using durations as IOIs.</p>"},{"location":"reference/basics/#amads.core.basics.Score.from_melody(ties)","title":"<code>ties</code>","text":"(<code>list of bool or None</code>, default:                   <code>None</code> )           \u2013            <p>If provided, a list of booleans indicating whether each note is tied to the next note. The last note's tie value is ignored. If None, no ties are created.</p>"},{"location":"reference/basics/#amads.core.basics.Score.copy","title":"copy","text":"<pre><code>copy()\n</code></pre> <p>Make a deep copy.</p> <p>This is equivalent to EventGroup.insert_copy_into, and provided because scores do not normally have a parent and there is nothing to \"copy into.\"</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>a copy of the score.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def copy(self):\n    \"\"\"Make a deep copy.\n\n    This is equivalent to [EventGroup.insert_copy_into](\n        basics_more.md#amads.core.basics.EventGroup.insert_emptycopy_into),\n    and provided\n    because scores do not normally have a parent and there is nothing\n    to \"copy into.\"\n\n    Returns\n    -------\n    Score\n        a copy of the score.\n    \"\"\"\n    return self.insert_copy_into(None)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.emptycopy","title":"emptycopy","text":"<pre><code>emptycopy()\n</code></pre> <p>Copy score without content.</p> <p>See insert_emptycopy_into.</p> <p>Since a Score does not normally have a parent, it is normal for the parent to be None, so <code>emptycopy()</code> is provided to make code more readable.</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>a copy of the score with no content</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def emptycopy(self):\n    \"\"\"Copy score without content.\n\n    See [insert_emptycopy_into](\n         basics_more.md#amads.core.basics.EventGroup.insert_emptycopy_into).\n\n    Since a Score does not normally have a parent, it is normal for the\n    parent to be None, so `emptycopy()` is provided to make code more\n    readable.\n\n    Returns\n    -------\n    Score\n        a copy of the score with no content\n    \"\"\"\n    return self.insert_emptycopy_into(None)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.append_time_signature","title":"append_time_signature","text":"<pre><code>append_time_signature(time_signature: TimeSignature) -&gt; None\n</code></pre> <p>Append a time signature change to the score.</p> <p>If there is already a time signature at the given time, it is replaced.</p> <p>Parameters:</p> Source code in <code>amads/core/basics.py</code> <pre><code>def append_time_signature(self, time_signature: TimeSignature) -&gt; None:\n    \"\"\"Append a time signature change to the score.\n\n    If there is already a time signature at the given time, it is\n    replaced.\n\n    Parameters\n    ----------\n    time_signature : TimeSignature\n        The time signature to append.\n    \"\"\"\n    # Remove any existing time signature at the same time\n    if isclose(self.time_signatures[-1].time, time_signature.time,\n               abs_tol=0.003):\n        self.time_signatures.pop()\n    self.time_signatures.append(time_signature)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.append_time_signature(time_signature)","title":"<code>time_signature</code>","text":"(<code>TimeSignature</code>)           \u2013            <p>The time signature to append.</p>"},{"location":"reference/basics/#amads.core.basics.Score.calc_differences","title":"calc_differences","text":"<pre><code>calc_differences(what: list[str]) -&gt; list[list[Note]]\n</code></pre> <p>Calculate inter-onset intervals (IOIs), IOI-ratios and intervals.</p> <p>This method is a convenience function that calls Part.calc_differences() on each Part of the Score. Since this method requires that Notes have no ties and are not concurrent (IOI == 0), the Score will normally be flat, which means only one Part.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list of List[Note]</code>           \u2013            <p>A list of Notes from each Part with the requested difference properties set.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def calc_differences(self, what: List[str]) -&gt; List[List[Note]]:\n    \"\"\"Calculate inter-onset intervals (IOIs), IOI-ratios and intervals.\n\n    This method is a convenience function that calls Part.calc_differences()\n    on each Part of the Score. Since this method requires that Notes have\n    no ties and are not concurrent (IOI == 0), the Score will normally be\n    flat, which means only one Part.\n\n    Parameters\n    ----------\n    what : list of str\n        A list of strings indicating what differences to compute.\n        Valid strings are: 'ioi' (for inter-onset intervals),\n        'ioi_ratio' (for ratio of successive IOIs), and\n        'interval' (for pitch intervals in semitones).\n\n    Returns\n    -------\n    list of List[Note]\n        A list of Notes from each Part with the requested difference\n        properties set.\n    \"\"\"\n    notes: List[List[Note]] = []\n    parts: Generator = self.find_all(Part)\n    for part in parts:\n        part_notes = part.calc_differences(what)\n        notes.append(part_notes)\n    return notes\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.calc_differences(what)","title":"<code>what</code>","text":"(<code>list of str</code>)           \u2013            <p>A list of strings indicating what differences to compute. Valid strings are: 'ioi' (for inter-onset intervals), 'ioi_ratio' (for ratio of successive IOIs), and 'interval' (for pitch intervals in semitones).</p>"},{"location":"reference/basics/#amads.core.basics.Score.convert_to_seconds","title":"convert_to_seconds","text":"<pre><code>convert_to_seconds() -&gt; None\n</code></pre> <p>Convert the score to represent time in seconds.</p> <p>This function modifies Score without making a copy.</p> Source code in <code>amads/core/basics.py</code> <pre><code>def convert_to_seconds(self) -&gt; None:\n    \"\"\"Convert the score to represent time in seconds.\n\n    This function modifies Score without making a copy.\n    \"\"\"\n    if self.units_are_seconds:\n        return\n    for ts in self.time_signatures:\n        ts.time = self.time_map.quarter_to_time(ts.time)\n    super()._convert_to_seconds(self.time_map)\n    self._units_are_seconds = True   # set the flag\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.convert_to_quarters","title":"convert_to_quarters","text":"<pre><code>convert_to_quarters() -&gt; None\n</code></pre> <p>Convert the score to represent time in quarters.</p> <p>This function modifies Score without making a copy.</p> Source code in <code>amads/core/basics.py</code> <pre><code>def convert_to_quarters(self) -&gt; None:\n    \"\"\"Convert the score to represent time in quarters.\n\n    This function modifies Score without making a copy.\n    \"\"\"\n    if not self.units_are_seconds:\n        return\n    for ts in self.time_signatures:\n        ts.time = self.time_map.time_to_quarter(ts.time)\n    super()._convert_to_quarters(self.time_map)\n    self._units_are_seconds = False   # clear the flag\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.collapse_parts","title":"collapse_parts","text":"<pre><code>collapse_parts(part=None, staff=None, has_ties=True)\n</code></pre> <p>Merge the notes of selected Parts and Staffs.</p> <p>This function is used to extract only selected parts or staffs from a Score and return the data as a flat Score (only one part containing only Notes, with ties merged).</p> <p>The <code>flatten()</code> method is similar and generally preferred. Use this <code>collapse_parts()</code> only if you want to select an individual Staff (e.g., only the left hand when left and right appear as two staffs) or when you only want to process one Part and avoid the cost of flattening all Parts with <code>flatten()</code>.</p> <p>If you are calling this method to extract notes separately for each Staff, it may do extra work. It might save some computation by performing a one-time</p> <pre><code>score = score.merge_tied_notes()\n</code></pre> <p>and calling this method with the parameter has_ties=False.  If has_ties is False, it is assumed without checking that each part.has_ties() is False, allowing this method to skip calls to part.merge_tied_notes() for each selected part.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>A ValueError is raised if:</p> <ul> <li>staff is given without a part specification</li> <li>staff is given and this is a flat score (no staves)</li> </ul> </li> </ul> Note <p>The use of lists like [1] for part and staff index notation is not ideal, but parts can be assigned a designated number that is not the same as the index, so we need a way to select by designated number, e.g., 1, and by index, e.g., [1]. Initially, I used tuples, but they are error prone. E.g., part=(0) means part=0, so you would have to write collapse_parts(part=((0))). With [n] notation, you write collapse_parts(part=[0]) to indicate an index. This is prettier and less prone to error.</p> Source code in <code>amads/core/basics.py</code> <pre><code>def collapse_parts(self, part=None, staff=None, has_ties=True):\n    \"\"\"Merge the notes of selected Parts and Staffs.\n\n    This function is used to extract only selected parts or staffs\n    from a Score and return the data as a flat Score (only\n    one part containing only Notes, with ties merged).\n\n    The `flatten()` method is similar and generally preferred. Use\n    this `collapse_parts()` only if you want to select an individual\n    Staff (e.g., only the left hand when left and right appear as\n    two staffs) or when you only want to process one Part and avoid\n    the cost of flattening *all* Parts with `flatten()`.\n\n    If you are calling this method to extract notes separately for each\n    Staff, it may do extra work. It might save some computation by\n    performing a one-time\n\n        score = score.merge_tied_notes()\n\n    and calling this method with the parameter has_ties=False. \n    If has_ties is False, it is assumed without checking that\n    each part.has_ties() is False, allowing this method to skip\n    calls to part.merge_tied_notes() for each selected part.\n\n    Parameters\n    ----------\n    part : Union[int, str, list[int], None]\n        If part is not None, only notes from the selected part are\n        included:\n\n        1. part may be an integer to match a part number (`number` is an\n              attribute of `Part`), or\n        2. part may be a string to match a part instrument, or\n        3. part may be a list with an index, e.g., [3] will select the 4th\n              part (because indexing is zero-based).\n    staff : Union[int, List[int], None]\n        If staff is given, only the notes from selected staves are\n        included. Note that staff selection requires part selection.\n        Thus, if staff is given without part, an Exception is raised.\n        Also, if staff is given and this is a flat score (no staves),\n        an Exception is raised.\n        Staff selection works as follows:\n\n        1. staff may be an integer to match a staff number, or\n        2. staff may be a list with an index, e.g., [1] will select\n             the 2nd staff.\n    has_ties : bool\n        Indicates the possibility of tied notes, which must be merged\n        as part of flattening. If the parts are flat already,\n        setting has_ties=False will save some computation.\n\n    Raises\n    ------\n    ValueError\n        A ValueError is raised if:\n\n        - staff is given without a part specification\n        - staff is given and this is a flat score (no staves)\n\n    Note\n    ----\n    The use of lists like [1] for part and staff index notation\n    is not ideal, but parts can be assigned a designated number that\n    is not the same as the index, so we need a way to select by\n    designated number, e.g., 1, and by index, e.g., [1]. Initially, I\n    used tuples, but they are error prone. E.g., part=(0) means part=0,\n    so you would have to write collapse_parts(part=((0))). With [n]\n    notation, you write collapse_parts(part=[0]) to indicate an index.\n    This is prettier and less prone to error.\n    \"\"\"\n\n    # Algorithm: Since we might be selecting individual Staffs and\n    # Parts, we want to do selection first, then copy to avoid\n    # modifying the source Score (self).\n    content = []  # collect selected Parts/Staffs here\n    score : Score = self.emptycopy()  # type: ignore\n    parts : Generator = self.find_all(Part)\n    for i, p in enumerate(parts):\n        if (part is None\n            or (isinstance(part, int) and part == p.number)\n            or (isinstance(part, str) and part == p.instrument)\n            or (isinstance(part, list) and part[0] == i)):\n            # merging tied notes takes place at the Part level because\n            # notes can be tied across Staffs.\n            if has_ties:\n                # put parts into score copy to allow onset computation\n                # later, we will merge notes and remove these parts\n                p = p.merge_tied_notes(score)\n\n            if staff is None:  # no staff selection, use whole Part\n                content.append(p)\n            else:  # must find Notes in selected Staffs\n                staffs = p.find_all(Staff)\n                for i, s in enumerate(staffs):\n                    if (staff is None\n                        or (isinstance(staff, int) and staff == s.number)\n                        or (isinstance(staff, list) and staff[0] == i)):\n                        content.append(s)\n    # now content is a list of Parts or Staffs to merge\n    notes = []\n    for part_or_staff in content:  # works with both Part and Score:\n        notes += part_or_staff.list_all(Note)\n    new_part = Part(parent=score)\n    if not has_ties:\n        # because we avoided merging ties in parts, notes still belong\n        # to the original score (self), so we need to copy them:\n        copies = []  # copy all notes to here\n        for note in notes:\n            # rather than a possibly expensive insert into new_part, we\n            # use sort (below) to construct the content of new_part.\n            copies.append(note.insert_copy_into(new_part))\n        notes = copies\n    # notes can be modified, so reuse them in the new_part:\n    for note in notes:\n        note.parent = new_part\n    notes.sort(key=lambda x: (x.onset, x.pitch))\n    new_part.content = notes\n    # remove all the parts that we merged, leaving only new_part\n    score.content = [new_part]\n    return score\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.collapse_parts(part)","title":"<code>part</code>","text":"(<code>int | str | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>If part is not None, only notes from the selected part are included:</p> <ol> <li>part may be an integer to match a part number (<code>number</code> is an       attribute of <code>Part</code>), or</li> <li>part may be a string to match a part instrument, or</li> <li>part may be a list with an index, e.g., [3] will select the 4th       part (because indexing is zero-based).</li> </ol>"},{"location":"reference/basics/#amads.core.basics.Score.collapse_parts(staff)","title":"<code>staff</code>","text":"(<code>int | list[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>If staff is given, only the notes from selected staves are included. Note that staff selection requires part selection. Thus, if staff is given without part, an Exception is raised. Also, if staff is given and this is a flat score (no staves), an Exception is raised. Staff selection works as follows:</p> <ol> <li>staff may be an integer to match a staff number, or</li> <li>staff may be a list with an index, e.g., [1] will select      the 2nd staff.</li> </ol>"},{"location":"reference/basics/#amads.core.basics.Score.collapse_parts(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Indicates the possibility of tied notes, which must be merged as part of flattening. If the parts are flat already, setting has_ties=False will save some computation.</p>"},{"location":"reference/basics/#amads.core.basics.Score._find_time_signature","title":"_find_time_signature","text":"<pre><code>_find_time_signature(when: float) -&gt; TimeSignature\n</code></pre> <p>Look up TimeSignature in effect at time <code>when</code></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>TimeSignature</code>           \u2013            <p>The time signature in effect at time <code>when</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def _find_time_signature(self, when : float) -&gt; TimeSignature:\n    \"\"\"Look up TimeSignature in effect at time `when`\n\n    Parameters\n    ----------\n    when : float\n        The time to look up the time signature for. Be careful\n        about rounding errors at time signature change times.\n\n    Returns\n    -------\n    TimeSignature\n        The time signature in effect at time `when`.\n    \"\"\"\n    for ts in reversed(self.time_signatures):\n        if ts.time &lt;= when:\n            return ts\n    assert False, \"No time signature found\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score._find_time_signature(when)","title":"<code>when</code>","text":"(<code>float</code>)           \u2013            <p>The time to look up the time signature for. Be careful about rounding errors at time signature change times.</p>"},{"location":"reference/basics/#amads.core.basics.Score.flatten","title":"flatten","text":"<pre><code>flatten(collapse=False)\n</code></pre> <p>Deep copy notes in a score to a flat score.</p> <p>A flat score consists of only Parts containing Notes (ties are merged).</p> <p>See collapse_parts to select specific Parts or Staffs and flatten them.</p> <p>Parameters:</p> Source code in <code>amads/core/basics.py</code> <pre><code>def flatten(self, collapse=False):\n    \"\"\"Deep copy notes in a score to a flat score.\n\n    A flat score consists of only Parts containing Notes\n    (ties are merged).\n\n    See [collapse_parts][amads.core.basics.Score.collapse_parts]\n    to select specific Parts or Staffs and flatten them.\n\n    Parameters\n    ----------\n    collapse : bool\n        If collapse is True, multiple parts are collapsed into a single\n        part, and notes are ordered according to onset times. The resulting\n        score contains one or more Parts, each containing only Notes.\n    \"\"\"\n    # make a deep copy of the score, merging tied notes in the process.\n    score : Score = self.merge_tied_notes()  # type: ignore\n    # it is now safe to modify score because it has been copied\n    if collapse:  # similar to Part.flatten() but we have to sort and\n        # do some other extra work to put all notes into score\n        # first, see if all parts have the same instrument. If so, we\n        # will set instrument in the collapsed part. Otherwise, the\n        # collapsed part will not have an instrument name.\n        instrument = None\n        instr_state = None\n        for part in score.content:\n            if isinstance(part, Part):\n                if instr_state is None:  # capture first instrument name\n                    instrument = part.instrument\n                    instr_state = \"set\"\n                elif instrument != part.instrument:\n                    instr_state = \"multiple\"\n                    instrument = None  # multiple instrument names found\n                else:  # this part.instrument is consistent\n                    pass\n\n        new_part = Part(parent=score, onset=score.onset,\n                        instrument=instrument)\n        notes : list[Note] = score.list_all(Note)  # type: ignore\n        score.content = [new_part]  # remove all other parts and events\n        for note in notes:\n            note.parent = new_part\n        # notes with equal onset times are sorted in pitch from high to low\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n\n        new_part.content = notes  # type: ignore (List[Note] &lt; List[Event])\n\n        # set the Part duration so it ends at the max offset of all Parts:\n        offset = max((part.offset for part in self.find_all(Part)),\n                     default=0)\n        new_part.duration = offset - score.onset\n\n    else:  # flatten each part separately\n        for part in score.find_all(Part):\n            part.flatten(in_place=True)  # type: ignore (part is a Part)\n    return score\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.flatten(collapse)","title":"<code>collapse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If collapse is True, multiple parts are collapsed into a single part, and notes are ordered according to onset times. The resulting score contains one or more Parts, each containing only Notes.</p>"},{"location":"reference/basics/#amads.core.basics.Score._from_melody","title":"_from_melody  <code>classmethod</code>","text":"<pre><code>_from_melody(\n    pitches: list[Pitch | int | float | str],\n    onsets: list[float],\n    durations: list[float],\n    ties: list[bool] | None,\n) -&gt; Score\n</code></pre> <p>Helper function to create a Score from preprocessed lists of pitches, onsets, durations and ties.</p> <p>All inputs must be lists of the same length, with numeric values already converted to float, except for ties, which may be None or of any length of booleans (extras are ignored, missing values are treated as False).</p> Source code in <code>amads/core/basics.py</code> <pre><code>@classmethod\ndef _from_melody(cls,\n                 pitches: list[Union[Pitch, int, float, str]],\n                 onsets: list[float],\n                 durations: list[float],\n                 ties: Optional[list[bool]]) -&gt; \"Score\":\n    \"\"\"Helper function to create a Score from preprocessed lists of pitches,\n    onsets, durations and ties.\n\n    All inputs must be lists of the same length, with numeric values already\n    converted to float, except for ties, which may be None or of any length\n    of booleans (extras are ignored, missing values are treated as False).\n    \"\"\"\n    if not (len(pitches) == len(onsets) == len(durations)):\n        raise ValueError(\"All inputs must be lists of the same length\")\n    if not all(isinstance(x, float) for x in onsets):\n        raise ValueError(\"All onsets must be floats\")\n    if not all(isinstance(x, float) for x in durations):\n        raise ValueError(\"All durations must be floats\")\n\n    # Check for overlapping notes\n    for i in range(len(onsets) - 1):\n        current_end = onsets[i] + durations[i]\n        next_onset = onsets[i + 1]\n        if current_end &gt; next_onset:\n            raise ValueError(\n                    f\"Notes overlap: note {i} ends at {current_end:.2f}\" + \\\n                    f\" but note {i + 1} starts at {next_onset:.2f}\")\n\n    score = cls()\n    part = Part(parent=score)\n\n    # Create notes and add them to the part\n\n    tied = False\n    for pitch, onset, duration in zip(pitches, onsets, durations):\n        if not isinstance(pitch, Pitch):\n            pitch = Pitch(pitch)\n\n        note = Note(part, onset, duration, pitch)\n        if tied:\n            prev_note.tie = note  # type: ignore (prev_note is Note)\n        prev_note = note\n        if ties and len(ties) &gt; 0:\n            tied = ties.pop(0)\n        else:\n            tied = False\n\n    # Set the score duration to the end of the last note\n    if len(onsets) &gt; 0:\n        score.duration = float(max(onset + duration for onset, duration\n                                               in zip(onsets, durations)))\n    else:\n        score.duration = 0.0\n\n    return score\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.is_flat","title":"is_flat","text":"<pre><code>is_flat()\n</code></pre> <p>Test if Score is flat.</p> <p>a flat Score conforms to strict hierarchy of: Score-Part-Note with no tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the score is flat.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def is_flat(self):\n    \"\"\"Test if Score is flat.\n\n    a flat Score conforms to strict hierarchy of:\n    Score-Part-Note with no tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the score is flat.\n    \"\"\"\n    for part in self.content:\n        # only Parts are expected, but things outside of the hierarchy\n        # are allowed, so we only rule out violations of the hierarchy:\n        if isinstance(part, (Score, Staff, Measure, Note, Rest, Chord)):\n            return False\n        if isinstance(part, Part) and not part.is_flat():\n            return False\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.is_flat_and_collapsed","title":"is_flat_and_collapsed","text":"<pre><code>is_flat_and_collapsed()\n</code></pre> <p>Determine if score has been flattened into one part</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the score is flat and has one part.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def is_flat_and_collapsed(self):\n    \"\"\"Determine if score has been flattened into one part\n\n    Returns\n    -------\n    bool\n        True iff the score is flat and has one part.\n    \"\"\"\n    return self.part_count() == 1 and self.is_flat()\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.is_well_formed_full_score","title":"is_well_formed_full_score","text":"<pre><code>is_well_formed_full_score() -&gt; bool\n</code></pre> <p>Test if Score is a well-formed full score.</p> <p>A well-formed full score is measured and conforms to a strict hierarchy of: Score-Part-Staff-Measure-(Note or Rest or Chord) and Chord-Note.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the Score is a well-formed full Score.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def is_well_formed_full_score(self) -&gt; bool:\n    \"\"\"Test if Score is a well-formed full score.\n\n    A well-formed full score is measured and conforms to a strict\n    hierarchy of: Score-Part-Staff-Measure-(Note or Rest or Chord)\n    and Chord-Note.\n\n    Returns\n    -------\n    bool\n        True iff the Score is a well-formed full Score.\n    \"\"\"\n    for part in self.content:\n        # only Parts are expected, but things outside of the hierarchy\n        # are allowed, so we only rule out violations of the hierarchy:\n        if isinstance(part, (Score, Staff, Measure, Note, Rest, Chord)):\n            return False\n        if isinstance(part, Part) and not part.is_well_formed_full_part():\n            return False\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.note_containers","title":"note_containers","text":"<pre><code>note_containers()\n</code></pre> <p>Returns a list of non-empty note containers.</p> <p>For full (measured) Scores, these are the Staff objects. For flat Scores, these are the Part objects. This is mainly useful for extracting note sequences where each part or staff represents a separate sequence. This method will retrieve either parts or staffs, whichever applies. This implementation also handles a mix of Parts with and without Staffs, returning a list of whichever is the direct parent of a list of Notes.</p> <p>Returns:</p> <ul> <li> <code>list(EventGroup)</code>           \u2013            <p>list of (recursively) contained EventGroups that contain Notes</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def note_containers(self):\n    \"\"\"Returns a list of non-empty note containers.\n\n    For full (measured) Scores, these are the Staff objects.\n    For flat Scores, these are the Part objects. This is mainly\n    useful for extracting note sequences where each part or staff\n    represents a separate sequence. This method will retrieve\n    either parts or staffs, whichever applies. This implementation\n    also handles a mix of Parts with and without Staffs, returning\n    a list of whichever is the direct parent of a list of Notes.\n\n    Returns\n    -------\n    list(EventGroup)\n        list of (recursively) contained EventGroups that contain Notes\n    \"\"\"\n    containers = []\n    # start with parts, which are common to both measured scores and\n    # flat scores. If the Part has a Staff, the Staffs are the\n    # containers we want. If the Part has a Note, the Part itself is\n    # the container. Other event classes can exist and are ignored.\n    for part in self.find_all(Part):  # type: ignore (Part is an Event)\n        part : Part\n        for event in part.content:\n            if isinstance(event, Staff):\n                containers += part.list_all(Staff)\n                break\n            elif isinstance(event, Note):\n                containers.append(part)\n                break\n        # if part was empty, it is not added to containers\n    return containers\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = False) -&gt; float\n</code></pre> <p>Adjust onsets to pack events in the entire Score.</p> <p>This method modifies the Score in place, adjusting onsets so that events occur sequentially without gaps. By default, self is assumed to be a full score containing Parts with Staffs and Measures, so all contained Parts are concurrent, starting at <code>onset</code>, and Parts are also packed, making all Staffs start concurrently.</p> <p>If the Score is flat (Parts contain only Notes), set <code>sequential</code> to True, which overrides the packing of Parts, making their content sequential (Notes) instead of concurrent (Staffs).</p> <p>Note that the direct content of this Score starts concurrently at <code>onset</code> in either case. Pack is recursive, but it makes content concurrent in Concurrences like Chords and sequential is Sequences like Staffs and Measures.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The modified Score instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential: bool = False) -&gt; float:\n    \"\"\"Adjust onsets to pack events in the entire Score.\n\n    This method modifies the Score in place, adjusting onsets\n    so that events occur sequentially without gaps. By default,\n    self is assumed to be a full score containing Parts with Staffs\n    and Measures, so all contained Parts are concurrent, starting\n    at `onset`, and Parts are also packed, making all Staffs start\n    concurrently.\n\n    If the Score is flat (Parts contain only Notes), set `sequential`\n    to True, which overrides the packing of Parts, making their\n    content sequential (Notes) instead of concurrent (Staffs).\n\n    Note that the direct content of this Score starts concurrently\n    at `onset` in either case. Pack is recursive, but it makes\n    content concurrent in Concurrences like Chords and sequential\n    is Sequences like Staffs and Measures.\n\n    Parameters\n    ----------\n    onset : float\n        The onset time for the Score after packing.\n    sequential : bool\n        If true, Parts are conconcurrently started at `onset`, but\n        each Part is packed sequentially, so that the first event\n        in each Part starts at `onset`, and subsequent events\n        start at the offset of the previous event. Use False for\n        full scores (with Parts and Staffs) and True for flat scores\n        (with Parts containing only Notes).\n    Returns\n    -------\n    Score\n        The modified Score instance itself.\n    \"\"\"\n    dur = 0.0\n    for part in self.content:  # type: ignore (score contains Parts)\n        part.onset = onset\n        if isinstance(part, Part):\n            dur = max(dur, part.pack(onset, sequential))\n        # anything but Part follows default packing behavior:\n        elif isinstance(part, EventGroup):\n            dur = max(dur, part.pack(onset))\n        else:\n            dur = max(dur, part.duration)\n    self.duration = dur\n    return dur\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset time for the Score after packing.</p>"},{"location":"reference/basics/#amads.core.basics.Score.pack(sequential)","title":"<code>sequential</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, Parts are conconcurrently started at <code>onset</code>, but each Part is packed sequentially, so that the first event in each Part starts at <code>onset</code>, and subsequent events start at the offset of the previous event. Use False for full scores (with Parts and Staffs) and True for flat scores (with Parts containing only Notes).</p>"},{"location":"reference/basics/#amads.core.basics.Score.part_count","title":"part_count","text":"<pre><code>part_count()\n</code></pre> <p>How many parts are in this score?</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of parts in this score.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def part_count(self):\n    \"\"\"How many parts are in this score?\n\n    Returns\n    -------\n    int\n        The number of parts in this score.\n    \"\"\"\n    return len(self.list_all(Part))\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.parts_are_monophonic","title":"parts_are_monophonic","text":"<pre><code>parts_are_monophonic() -&gt; bool\n</code></pre> <p>Determine if each part of a musical score is monophonic.</p> <p>A monophonic part has no overlapping notes (e.g., chords).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if each part is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def parts_are_monophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if each part of a musical score is monophonic.\n\n    A monophonic part has no overlapping notes (e.g., chords).\n\n    Returns\n    -------\n    bool\n        True if each part is monophonic, False otherwise.\n    \"\"\"\n    for part in self.find_all(Part):\n        part = cast(Part, part)\n        if not part.ismonophonic():\n            return False\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.remove_measures","title":"remove_measures","text":"<pre><code>remove_measures() -&gt; Score\n</code></pre> <p>Create a new Score with all Measures removed.</p> <p>Preserves Staffs in the hierarchy. Notes are \"lifted\" from Measures to become direct content of their Staff. The result satisfies neither <code>is_flat()</code> nor <code>is_well_formed_full_score()</code>, but it could be useful in preserving a separation between staves. See also <code>collapse_parts</code>, which can be used to extract individual staves from a score. The result will have ties merged. (If you want to preserve ties and access the notes in a Staff, consider using find_all(Staff), and then for each staff, find_all(Note), but note that ties can cross between staves.)</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>A new Score instance with all Measures removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_measures(self) -&gt; \"Score\":\n    \"\"\"Create a new Score with all Measures removed.\n\n    Preserves Staffs in the hierarchy. Notes are \"lifted\" from Measures\n    to become direct content of their Staff. The result satisfies neither\n    `is_flat()` nor `is_well_formed_full_score()`, but it could be useful\n    in preserving a separation between staves. See also `collapse_parts`,\n    which can be used to extract individual staves from a score. The result\n    will have ties merged. (If you want to preserve ties and access the\n    notes in a Staff, consider using find_all(Staff), and then for each staff,\n    find_all(Note), but note that ties can cross between staves.)\n\n    Returns\n    -------\n    Score\n        A new Score instance with all Measures removed.\n    \"\"\"\n    score : Score = self.emptycopy()  # type: ignore\n    for part in self.content:  # type: ignore (score contains Parts)\n        if isinstance(part, Part):\n            # puts a copy of Part with merged_notes into score and\n            # then removes measures from each staff:\n            part.remove_measures(score)\n        else:  # non-Part objects are simply copied\n            part.insert_copy_into(score)\n    return score\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; Score\n</code></pre> <p>Print the Score information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The Score instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n         file: Optional[TextIO] = None) -&gt; \"Score\":\n    \"\"\"Print the Score information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    Score\n        The Score instance itself.\n    \"\"\"\n\n    print(\" \" * indent, self, sep=\"\", file=file)\n    self.time_map.show(indent + 4, file=file)\n\n    print(\" \" * indent, \"    time_signatures [\", sep=\"\", end=\"\") \n    need_blank = \"\"\n    col = indent + 21\n    for ts in self.time_signatures:\n        tss = str(ts)\n        if len(tss) + col &gt; 79:\n            print(\"\\n\", \" \" * (indent + 20), end=\"\")\n            col = indent + 21\n        print(need_blank, tss, sep=\"\", end=\"\")\n        col += len(tss)\n        need_blank = \" \"\n    print(\"]\")  # newline after time signatures\n\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore\n        # type ignore because (all Events have show())\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics/#amads.core.basics.Score.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score._event_onset","title":"_event_onset","text":"<pre><code>_event_onset() -&gt; str\n</code></pre> <p>produce onset string for str</p> Source code in <code>amads/core/basics.py</code> <pre><code>def _event_onset(self) -&gt; str:\n    \"\"\"produce onset string for __str__\n    \"\"\"\n    return (\"onset=None\" if self.onset is None else\n            f\"onset={self.onset:0.3f}\")\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score._event_times","title":"_event_times","text":"<pre><code>_event_times(dur: bool = True) -&gt; str\n</code></pre> <p>produce onset and duration string for str</p> Source code in <code>amads/core/basics.py</code> <pre><code>def _event_times(self, dur: bool = True) -&gt; str:\n    \"\"\"produce onset and duration string for __str__\n    \"\"\"\n    duration = self.duration\n    if duration is not None:\n        duration = f\"{self.duration:0.3f}\"\n    return f\"{self._event_onset()}, duration={duration}\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics/#amads.core.basics.Score.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics/#amads.core.basics.Score.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics/#amads.core.basics.Score.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics/#amads.core.basics.Score.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics/#amads.core.basics.Score.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics/#amads.core.basics.Score.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics/#amads.core.basics.Score.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics/#amads.core.basics.Score._quantize","title":"_quantize","text":"<pre><code>_quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>\"Since <code>_quantize</code> is called recursively on children, this method is needed to redirect <code>EventGroup._quantize</code> to <code>quantize</code></p> Source code in <code>amads/core/basics.py</code> <pre><code>def _quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"\"Since `_quantize` is called recursively on children, this method is\n    needed to redirect `EventGroup._quantize` to `quantize`\n    \"\"\"\n    return self.quantize(divisions)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score._convert_to_seconds","title":"_convert_to_seconds","text":"<pre><code>_convert_to_seconds(time_map: TimeMap) -&gt; None\n</code></pre> <p>Convert the event's duration and onset to seconds using the provided TimeMap. Convert content as well.</p> <p>Parameters:</p> Source code in <code>amads/core/basics.py</code> <pre><code>def _convert_to_seconds(self, time_map: TimeMap) -&gt; None:\n    \"\"\"Convert the event's duration and onset to seconds using the\n    provided TimeMap. Convert content as well.\n\n    Parameters\n    ----------\n    time_map : TimeMap\n        The TimeMap object used for conversion.\n    \"\"\"\n    super()._convert_to_seconds(time_map)\n    for elem in self.content:\n        elem._convert_to_seconds(time_map)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score._convert_to_seconds(time_map)","title":"<code>time_map</code>","text":"(<code>TimeMap</code>)           \u2013            <p>The TimeMap object used for conversion.</p>"},{"location":"reference/basics/#amads.core.basics.Score._convert_to_quarters","title":"_convert_to_quarters","text":"<pre><code>_convert_to_quarters(time_map: TimeMap) -&gt; None\n</code></pre> <p>Convert the event's duration and onset to quarters using the provided TimeMap. Convert content as well.</p> <p>Parameters:</p> Source code in <code>amads/core/basics.py</code> <pre><code>def _convert_to_quarters(self, time_map: TimeMap) -&gt; None:\n    \"\"\"Convert the event's duration and onset to quarters using the\n    provided TimeMap. Convert content as well.\n\n    Parameters\n    ----------\n    time_map : TimeMap\n        The TimeMap object used for conversion.\n    \"\"\"\n    onset_quarters = time_map.time_to_quarter(self.onset)\n    offset_quarters = time_map.time_to_quarter(self.onset + self.duration)\n    self.onset = onset_quarters\n    self.duration = offset_quarters - onset_quarters\n    for elem in self.content:\n        elem._convert_to_quarters(time_map)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score._convert_to_quarters(time_map)","title":"<code>time_map</code>","text":"(<code>TimeMap</code>)           \u2013            <p>The TimeMap object used for conversion.</p>"},{"location":"reference/basics/#amads.core.basics.Score.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics/#amads.core.basics.Score.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics/#amads.core.basics.Score.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Score.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics/#amads.core.basics.Score.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics/#amads.core.basics.Score.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics/#amads.core.basics.Score.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics/#amads.core.basics.Score.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics/#amads.core.basics.Score.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics/#amads.core.basics.Score.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics/#amads.core.basics.Score.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics/#amads.core.basics.Score.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics/#amads.core.basics.Score.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/","title":"Classses Representing Basic Score Elements","text":"<pre><code>from amads.core import *\n</code></pre> <p>Note: importing <code>amads.core</code> imports <code>amads.core.basics</code>, <code>amads.core.distribution</code> and <code>amads.core.timemap</code>. </p>"},{"location":"reference/basics_more/#amads.core.basics.Clef","title":"Clef","text":"<pre><code>Clef(\n    parent: EventGroup | None = None,\n    onset: float = 0.0,\n    clef: str = \"treble\",\n)\n</code></pre> <p>               Bases: <code>Event</code></p> <p>Clef is a zero-duration Event with clef information.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>Always zero for this subclass.</p> </li> <li> <code>clef</code>               (<code>str</code>)           \u2013            <p>The clef name, one of \"treble\", \"bass\", \"alto\", \"tenor\",  \"percussion\", \"treble8vb\" (Other clefs may be added later.)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Display the Clef information.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self,\n             parent: Optional[\"EventGroup\"] = None,\n             onset: float = 0.0, clef: str = \"treble\"):\n    super().__init__(parent, onset, 0)\n    if clef not in [\"treble\", \"bass\", \"alto\", \"tenor\",\n                  \"percussion\", \"treble8vb\"]:\n        raise ValueError(f\"Invalid clef: {clef}\")\n    self.clef = clef\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time. An initial value of None might be assigned when the Clef is inserted into an EventGroup.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef(clef)","title":"<code>clef</code>","text":"(<code>str</code>, default:                   <code>'treble'</code> )           \u2013            <p>The clef name, one of \"treble\", \"bass\", \"alto\", \"tenor\",  \"percussion\", \"treble8vb\" (Other clefs may be added later.)</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef-attributes","title":"Attributes","text":""},{"location":"reference/basics_more/#amads.core.basics.Clef.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Clef-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.basics.Clef.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"Clef({self._event_onset()}, {self.clef})\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; Clef\n</code></pre> <p>Display the Clef information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Clef</code>           \u2013            <p>The Clef instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0, file: Optional[TextIO] = None) -&gt; \"Clef\":\n    \"\"\"Display the Clef information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    Clef\n        The Clef instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float) -&gt; Event\n</code></pre> <p>Change the onset by an increment.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>Event</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float) -&gt; \"Event\":\n    \"\"\"\n    Change the onset by an increment.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `Event`.\n    \"\"\"\n    self._onset += increment  # type: ignore\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics_more/#amads.core.basics.Clef.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Clef.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature","title":"KeySignature","text":"<pre><code>KeySignature(\n    parent: EventGroup | None = None,\n    onset: float = 0.0,\n    key_sig: int = 0,\n)\n</code></pre> <p>               Bases: <code>Event</code></p> <p>KeySignature is a zero-duration Event with key signature information.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>Always zero for this subclass.</p> </li> <li> <code>key_sig</code>               (<code>int</code>)           \u2013            <p>An integer representing the number of sharps and flats.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Display the KeySignature information.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, parent: Optional[\"EventGroup\"] = None,\n             onset: float = 0.0, key_sig: int = 0):\n    super().__init__(parent=parent, onset=onset, duration=0)\n    self.key_sig = key_sig\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time. An initial value of None might be assigned when the KeySignature is inserted into an EventGroup.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature(key_sig)","title":"<code>key_sig</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>An integer representing the number of sharps (if positive) and flats (if negative), e.g., -3 for Eb major or C minor.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature-attributes","title":"Attributes","text":""},{"location":"reference/basics_more/#amads.core.basics.KeySignature.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.basics.KeySignature.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    key_sig = abs(self.key_sig)\n    kind = \"sharps\" if self.key_sig &gt; 0 else \"flats\"\n    return f\"KeySignature({self._event_onset()}, {key_sig} {kind})\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; KeySignature\n</code></pre> <p>Display the KeySignature information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>KeySignature</code>           \u2013            <p>The KeySignature instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n         file: Optional[TextIO] = None) -&gt; \"KeySignature\":\n    \"\"\"Display the KeySignature information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    KeySignature\n        The KeySignature instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float) -&gt; Event\n</code></pre> <p>Change the onset by an increment.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>Event</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float) -&gt; \"Event\":\n    \"\"\"\n    Change the onset by an increment.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `Event`.\n    \"\"\"\n    self._onset += increment  # type: ignore\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.KeySignature.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup","title":"EventGroup","text":"<pre><code>EventGroup(\n    parent: EventGroup | None,\n    onset: float | None,\n    duration: float | None,\n    content: list[Event] | None,\n)\n</code></pre> <p>               Bases: <code>Event</code></p> <p>A collection of Event objects. (An abstract class.)</p> <p>Use one of the subclasses: Score, Part, Staff, Measure or Chord.</p> <p>Normally, you create any EventGroup (Chord, Measure, Staff, Part, Score) with no content, then add content. You can add content in bulk by simply setting the <code>content</code> attribute to a list of Events whose <code>parent</code> attributes have been set to the EventGroup. You can also add one event at a time, by calling the EventGroup's insert method. (This will change the event parent from None to the group.) It is recommended to specify all onsets and durations explicitly, including the onset of the group itself.</p> <p>Alternatively, you can provide content when the group is constructed.  Chord, Measure, Staff, Part, and Score all have <code>*args</code> parameters so that you can write something like:</p> <pre><code>Score(Part(Staff(Measure(Note(...), Note(...)),\nMeasure(Note(...), Note(...)))))\n</code></pre> <p>In this case, it is recommended that you leave the onsets of content and chord unknown (None, the default). Then, as each event or group becomes content for a parent, the onsets will be set automatically, organizing events sequentially (in Measures and Staves) or concurrently (in Chords, Parts, Scores).</p> <p>The use of unknown (None) onsets is offered as a convenience for simple cases. The main risk is that onsets are considered to be relative to the group onset if the group onset is not known. E.g. if onsets are specified within the content of an EventGroup (Chord, Measure, Staff, Part, Score) but the group onset is unknown (None), and then you assign (or a parent assigns) an onset value to the group, the content onsets (even \u201cknown\u201d ones) will all be shifted by the assigned onset. This happens only when changing an onset from None to a number. Subsequent changes to the group onset will not adjust the content onsets, which are considered absolute times once the group onset is known.</p> <p>EventGroup is subclassed to form Concurrence and Sequence. A Concurrence defaults to placing all events at onset 0, while Sequence defaults to placing events sequentially such that event inter-onset intervals are their durations. The EventGroup behaves like Concurrence, so the Concurrence implementation is minimal, while the Sequence needs several methods to override EventGroup behavior to support sequential behavior.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust the content to onsets starting with the onset parameter.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, parent: Optional[\"EventGroup\"],\n             onset: Optional[float], duration: Optional[float],\n             content: Optional[list[Event]]):\n    # pass 0 for duration because Event constructor wants a number,\n    # but we will set duration later based on duration parameter or\n    # based on content if duration is None:\n    super().__init__(parent=parent, onset=onset, duration=0)\n    if content is None:\n        content = []\n    # member_onset is the default onset for children\n    member_onset = 0 if onset is None else onset\n    prev_onset = member_onset\n    for elem in content:  # check and set parents\n        if elem.parent and elem.parent != self:\n            raise ValueError(\"Event already has a (different) parent\")\n        elem.parent = self  # type: ignore\n        if elem._onset is None:\n            elem.onset = member_onset\n        elif elem._onset &lt; prev_onset:\n            raise ValueError(\"content is not in onset time order\")\n        # # Rounding can cause notes to get re-ordered when they should\n        # # be simultaneous. This finds notes that are within 1 usec and\n        # # overwrites the onsets after the first note so they are all\n        # # equal. Then get_sorted_notes() will sort these by pitch:\n        # elif elem._onset &lt; prev_onset + 1.0e-6:\n        #     elem._onset = prev_onset\n        else:\n            prev_onset = elem._onset\n\n    if duration is None:  # compute duration from content\n        max_offset = 0\n        for elem in content:\n            max_offset = max(max_offset, elem.offset)\n        duration = max_offset\n        if onset:\n            duration = max_offset - onset\n    self.duration = duration  # type: ignore (duration is now number)\n    self.content = content\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>)           \u2013            <p>The onset (start) time.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>)           \u2013            <p>The duration in quarters or seconds.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup(content)","title":"<code>content</code>","text":"(<code>list | None</code>)           \u2013            <p>A list of Event objects to be added to the group. The parent of each Event is set to this EventGroup, and it is an error if any Event already has a parent.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup-attributes","title":"Attributes","text":""},{"location":"reference/basics_more/#amads.core.basics.EventGroup.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.basics.EventGroup.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = False) -&gt; float\n</code></pre> <p>Adjust the content to onsets starting with the onset parameter.</p> <p>By default onsets are set to <code>onset</code> and the duration of self is set to the maximum duration of the content. pack() works recursively on elements that are EventGroups. Setting sequential to True implements sequential packing, where events are placed one after another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential : bool = False) -&gt; float:\n    \"\"\"Adjust the content to onsets starting with the onset parameter.\n\n    By default onsets are set to `onset` and the duration of self is set to\n    the maximum duration of the content. pack() works recursively on\n    elements that are EventGroups. Setting sequential to True implements\n    sequential packing, where events are placed one after another.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    self.onset = onset\n    self.duration = 0\n    for elem in self.content:\n        elem.onset = onset\n        if isinstance(elem, EventGroup):   # either Sequence or Concurrence\n            elem.duration = elem.pack(onset)  #type: ignore\n        if sequential:\n            onset += elem.duration\n        else:\n            self.duration = max(self.duration, elem.duration)\n    if sequential:\n        self.duration = onset - self.onset\n    return self.duration\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"{self.__class__.__name__}({self._event_times()})\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.EventGroup.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence","title":"Sequence","text":"<pre><code>Sequence(\n    parent: EventGroup | None,\n    onset: float | None = None,\n    duration: float | None = None,\n    content: list[Event] | None = None,\n)\n</code></pre> <p>               Bases: <code>EventGroup</code></p> <p>Sequence (abstract class) represents a temporal sequence of music events.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time. None represents \u201cunknown\u201d and to be determined when this object is added to a parent.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>pack</code>             \u2013              <p>Adjust the content to be sequential.</p> </li> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, parent: Optional[EventGroup],\n             onset: Optional[float] = None,\n             duration: Optional[float] = None,\n             content: Optional[list[Event]] = None):\n    # if onset is given, we need to set all content onsets to form a\n    # sequence before running super().__init__()\n    if content is None:\n        content = []\n    prev_onset : float = 0.0\n    prev_offset : float = 0.0\n    if not onset is None:\n        prev_onset = onset\n        prev_offset = onset\n    for elem in content:\n        # parent will be set in EventGroup's constructor\n        if elem._onset is None:\n             elem.onset = prev_offset\n        elif elem.onset &lt; prev_onset:\n            raise ValueError(\"Event onsets are not in time order\")\n        prev_onset = elem.onset\n        prev_offset = elem.offset\n    # now that onset times are all set, we can run EventGroup's\n    # constructor to set parents, duration, content\n    super().__init__(parent, onset, duration, content)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The onset (start) time. None means unknown, to be set when Sequence is added to a parent.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration in quarters or seconds. (If duration is omitted or None, the duration is set so that self.offset ends at the max offset in content, or 0 if there is no content.)</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence(content)","title":"<code>content</code>","text":"(<code>list[Event] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of Event objects to be added to the group. Content events with onsets of None are set to the offset of the previous event in the sequence. The first event onset is the specified group onset, or zero if onset is None.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence-attributes","title":"Attributes","text":""},{"location":"reference/basics_more/#amads.core.basics.Sequence.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Sequence-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.basics.Sequence.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = True) -&gt; float\n</code></pre> <p>Adjust the content to be sequential.</p> <p>The resulting content will begin with the parameter <code>onset</code> (defaults to 0), and each other object will get an onset equal to the offset of the previous element. The duration of self is set to the offset of the last element.  This method essentially arranges the content to eliminate gaps. pack() works recursively on elements that are <code>EventGroups</code>.</p> <p>Be careful not to pack <code>Measures</code> (directly or through recursion) if the Measure's content durations do not add up to the intended quarters per measure.</p> <p>To override the sequential behavior, set the <code>sequential</code>  parameter to False.  In that case, pack behaves like the <code>Concurrence.pack()</code> method.</p> <p>The pack method alters self and its content in place.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential: bool = True) -&gt; float:\n    \"\"\"Adjust the content to be sequential.\n\n    The resulting content will begin with the parameter `onset`\n    (defaults to 0), and each other object will get an onset equal\n    to the offset of the previous element. The duration of self is\n    set to the offset of the last element.  This method essentially\n    arranges the content to eliminate gaps. pack() works recursively\n    on elements that are `EventGroups`.\n\n    Be careful not to pack `Measures` (directly or through\n    recursion) if the Measure's content durations do not add up to\n    the intended quarters per measure.\n\n    To override the sequential behavior, set the `sequential` \n    parameter to False.  In that case, pack behaves like the\n    `Concurrence.pack()` method.\n\n    The pack method alters self and its content in place.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    return super().pack(onset, sequential)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"{self.__class__.__name__}({self._event_times()})\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Sequence.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence","title":"Concurrence","text":"<pre><code>Concurrence(\n    parent: EventGroup | None = None,\n    onset: float | None = None,\n    duration: float | None = None,\n    content: list[Event] | None = None,\n)\n</code></pre> <p>               Bases: <code>EventGroup</code></p> <p>Concurrence (abstract class) represents a group of simultaneous children.</p> <p>However, children can have a non-zero onset to represent events organized in time).  Thus, the main distinction between Concurrence and Sequence is that a Sequence can be constructed with pack=True to force sequential timing of the content. Note that a Sequence can have overlapping or entirely simultaneous Events as well.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time. None represents \"unknown\" and to be determined when this object is added to a parent.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust the content to onsets starting with the onset parameter.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, parent: Optional[\"EventGroup\"] = None,\n             onset: Optional[float] = None,\n             duration: Optional[float] = None,\n             content: Optional[list[Event]] = None):\n    super().__init__(parent, onset, duration, content)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The onset (start) time. None means unknown, to be set when Sequence is added to a parent.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration in quarters or seconds. (If duration is omitted or None, the duration is set so that self.offset ends at the max offset in content, or 0 if there is no content.)</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence(content)","title":"<code>content</code>","text":"(<code>list[Event] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of Event objects to be added to the group. Content events with onsets of None are set to the offset of the concurrence, or zero if onset is None.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence-attributes","title":"Attributes","text":""},{"location":"reference/basics_more/#amads.core.basics.Concurrence.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.basics.Concurrence.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = False) -&gt; float\n</code></pre> <p>Adjust the content to onsets starting with the onset parameter.</p> <p>By default onsets are set to <code>onset</code> and the duration of self is set to the maximum duration of the content. pack() works recursively on elements that are EventGroups. Setting sequential to True implements sequential packing, where events are placed one after another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential : bool = False) -&gt; float:\n    \"\"\"Adjust the content to onsets starting with the onset parameter.\n\n    By default onsets are set to `onset` and the duration of self is set to\n    the maximum duration of the content. pack() works recursively on\n    elements that are EventGroups. Setting sequential to True implements\n    sequential packing, where events are placed one after another.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    self.onset = onset\n    self.duration = 0\n    for elem in self.content:\n        elem.onset = onset\n        if isinstance(elem, EventGroup):   # either Sequence or Concurrence\n            elem.duration = elem.pack(onset)  #type: ignore\n        if sequential:\n            onset += elem.duration\n        else:\n            self.duration = max(self.duration, elem.duration)\n    if sequential:\n        self.duration = onset - self.onset\n    return self.duration\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"{self.__class__.__name__}({self._event_times()})\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Concurrence.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord","title":"Chord","text":"<pre><code>Chord(\n    *args: Event,\n    parent: EventGroup | None = None,\n    onset: float | None = None,\n    duration: float | None = None\n)\n</code></pre> <p>               Bases: <code>Concurrence</code></p> <p>A collection of notes played together.</p> <p>Typically, chords represent notes that would share a stem, and note start times and durations match the start time and duration of the chord, but none of this is enforced.  The order of notes is arbitrary.</p> <p>Normally, a Chord is a member of a Measure. There is no requirement that simultaneous or overlapping notes be grouped into Chords, so the Chord class is merely an optional element of music structure representation.</p> <p>See Constructor Details.</p> <p>Representation note: An alternative representation would be to subclass Note and allow a list of pitches, which has the advantage of enforcing the shared onsets and durations. However, there can be ties connected differently to each note within the Chord, thus we use a Concurrence with Note objects as elements. Each Note.tie can be None (no tie) or tie to a Note in another Chord or Measure.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>parent</code>               (<code>EventGroup | None</code>)           \u2013            <p>The containing object or None.</p> </li> <li> <code>_onset</code>               (<code>float | None</code>)           \u2013            <p>The onset (start) time.</p> </li> <li> <code>duration</code>               (<code>float</code>)           \u2013            <p>The duration in quarters or seconds.</p> </li> <li> <code>content</code>               (<code>list[Event]</code>)           \u2013            <p>Elements contained within this collection.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>__repr__</code>             \u2013              <p>All Event subclasses inherit this to use str().</p> </li> <li> <code>set</code>             \u2013              <p>Set a named property on this Event.</p> </li> <li> <code>get</code>             \u2013              <p>Get the value of a property from this Event.</p> </li> <li> <code>has</code>             \u2013              <p>Check if the Event has a specific property.</p> </li> <li> <code>time_shift</code>             \u2013              <p>Change the onset by an increment, affecting all content.</p> </li> <li> <code>insert_copy_into</code>             \u2013              <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> </li> <li> <code>ismonophonic</code>             \u2013              <p>Determine if content is monophonic (non-overlapping notes).</p> </li> <li> <code>insert_emptycopy_into</code>             \u2013              <p>Create a deep copy of the EventGroup except for content.</p> </li> <li> <code>expand_chords</code>             \u2013              <p>Replace chords with the multiple notes they contain.</p> </li> <li> <code>find_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>get_sorted_notes</code>             \u2013              <p>Return a list of sorted notes with merged ties.</p> </li> <li> <code>has_instanceof</code>             \u2013              <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> </li> <li> <code>has_rests</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> </li> <li> <code>has_chords</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> </li> <li> <code>has_ties</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> </li> <li> <code>has_measures</code>             \u2013              <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> </li> <li> <code>inherit_duration</code>             \u2013              <p>Set the duration of this EventGroup according to maximum offset.</p> </li> <li> <code>insert</code>             \u2013              <p>Insert an event.</p> </li> <li> <code>last</code>             \u2013              <p>Retrieve the last event in the content list.</p> </li> <li> <code>list_all</code>             \u2013              <p>Find all instances of a specific type within the EventGroup.</p> </li> <li> <code>merge_tied_notes</code>             \u2013              <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> </li> <li> <code>pack</code>             \u2013              <p>Adjust the content to onsets starting with the onset parameter.</p> </li> <li> <code>quantize</code>             \u2013              <p>Align onsets and durations to a rhythmic grid.</p> </li> <li> <code>remove</code>             \u2013              <p>Remove an element from the content list. </p> </li> <li> <code>remove_rests</code>             \u2013              <p>Remove all Rest objects from content.</p> </li> <li> <code>__str__</code>             \u2013              <p>Short string representation</p> </li> <li> <code>show</code>             \u2013              <p>Print the EventGroup information.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def __init__(self, *args: Event,\n             parent: Optional[EventGroup] = None,\n             onset: Optional[float] = None,\n             duration: Optional[float] = None):\n    super().__init__(parent, onset, duration, list(args))\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord(*args)","title":"<code>*args</code>","text":"(<code>Event</code>, default:                   <code>()</code> )           \u2013            <p>The Event objects to be added to the group. Content events with onsets of None are set to the onset of the chord, or zero if onset is None.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The containing object or None. Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord(onset)","title":"<code>onset</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The onset (start) time. None means unknown, to be set when Sequence is added to a parent.  Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord(duration)","title":"<code>duration</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The duration in quarters or seconds. (If duration is omitted or None, the duration is set so that self.offset ends at the max offset of args, or 0 if there is no content.) Must be passed as a keyword parameter due to <code>*args</code>.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord-attributes","title":"Attributes","text":""},{"location":"reference/basics_more/#amads.core.basics.Chord.onset","title":"onset  <code>property</code> <code>writable</code>","text":"<pre><code>onset: float\n</code></pre> <p>Retrieve the onset (start) time.</p> <p>If the onset is None, raise an exception. (Events can have None onset times, but they must be set before retrieval. onsets that are None are automatically set when the Event is added to an EventGroup.)</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The onset (start) time.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the onset time is not set (None).</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.units_are_seconds","title":"units_are_seconds  <code>property</code>","text":"<pre><code>units_are_seconds: bool\n</code></pre> <p>Check if the times are in seconds.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in seconds. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.units_are_quarters","title":"units_are_quarters  <code>property</code>","text":"<pre><code>units_are_quarters: bool\n</code></pre> <p>Check if the times are in quarters.</p> <p>This <code>event</code> must be in a <code>Score</code> (where <code>_units_are_seconds</code> is stored).</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the event's times are in quarters. If not in a score, False is returned.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.offset","title":"offset  <code>property</code> <code>writable</code>","text":"<pre><code>offset: float\n</code></pre> <p>Retrieve the global offset (stop) time.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The global offset (stop) time.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.part","title":"part  <code>property</code>","text":"<pre><code>part: Part | None\n</code></pre> <p>Retrieve the Part containing this event.</p> <p>Returns:</p> <ul> <li> <code>Part | None</code>           \u2013            <p>The Part containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.score","title":"score  <code>property</code>","text":"<pre><code>score: Score | None\n</code></pre> <p>Retrieve the Score containing this event.</p> <p>Returns:</p> <ul> <li> <code>Score | None</code>           \u2013            <p>The Score containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.staff","title":"staff  <code>property</code>","text":"<pre><code>staff: Staff | None\n</code></pre> <p>Retrieve the Staff containing this event</p> <p>Returns:</p> <ul> <li> <code>Staff | None</code>           \u2013            <p>The Staff containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord.measure","title":"measure  <code>property</code>","text":"<pre><code>measure: Measure | None\n</code></pre> <p>Retrieve the Measure containing this event</p> <p>Returns:</p> <ul> <li> <code>Measure | None</code>           \u2013            <p>The Measure containing this event or None if not found.</p> </li> </ul>"},{"location":"reference/basics_more/#amads.core.basics.Chord-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.basics.Chord.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>All Event subclasses inherit this to use str().</p> <p>Thus, a list of Events is printed using their str methods</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"All Event subclasses inherit this to use str().\n\n    Thus, a list of Events is printed using their __str__ methods\n    \"\"\"\n    return str(self)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.set","title":"set","text":"<pre><code>set(property: str, value: Any) -&gt; Event\n</code></pre> <p>Set a named property on this Event.</p> <p>Every event can be extended with additional properties. Although Python objects are already extensible with new attributes, new attributes that are not set in <code>__init__</code> confuse type checkers and other tools, so every <code>Event</code> has an <code>info</code> attribute as a dictionary where additional, application-specific information can be stored. The <code>info</code> attribute is <code>None</code> to save space until the first property is set, so you should use <code>set</code> and <code>get</code> methods and avoid writing <code>event.info[property]</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>returns this object (self)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; note = Note()\n&gt;&gt;&gt; note.get(\"color\", \"no color\")\n'no color'\n&gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n&gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n(True, False)\n&gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n('red', 0.2)\n</code></pre> Source code in <code>amads/core/basics.py</code> <pre><code>def set(self, property : str, value : Any) -&gt; \"Event\":\n    \"\"\"Set a named property on this Event.\n\n    Every event can be extended with additional properties. Although\n    Python objects are already extensible with new attributes, new\n    attributes that are not set in `__init__` confuse type checkers\n    and other tools, so every `Event` has an `info` attribute as a\n    dictionary where additional, application-specific information can\n    be stored. The `info` attribute is `None` to save space until the\n    first property is set, so you should use `set` and `get` methods\n    and avoid writing `event.info[property]`.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to set.\n    value : Any\n        The value to assign to the property.\n\n    Returns\n    -------\n    Event\n        returns this object (self)\n\n    Examples\n    --------\n    &gt;&gt;&gt; note = Note()\n    &gt;&gt;&gt; note.get(\"color\", \"no color\")\n    'no color'\n    &gt;&gt;&gt; _ = note.set(\"color\", \"red\").set(\"harmonicity\", 0.2)\n    &gt;&gt;&gt; (note.has(\"color\"), note.has(\"shape\"))\n    (True, False)\n    &gt;&gt;&gt; (note.get(\"color\"), note.get(\"harmonicity\"))\n    ('red', 0.2)\n    \"\"\"\n    if self.info is None:\n        self.info = {}\n    self.info[property] = value\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.set(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to set.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.set(value)","title":"<code>value</code>","text":"(<code>Any</code>)           \u2013            <p>The value to assign to the property.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.get","title":"get","text":"<pre><code>get(property: str, default: Any = None) -&gt; Any\n</code></pre> <p>Get the value of a property from this Event.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Any</code>           \u2013            <p>The value of the specified property.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get(self, property : str, default : Any = None) -&gt; Any:\n    \"\"\"Get the value of a property from this Event.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str.\n        The name of the property to get.\n    default : Any\n        The default value to return if the property is not found.\n\n    Returns\n    -------\n    Any\n        The value of the specified property.\n    \"\"\"\n    if self.info is None:\n        return default\n    return self.info.get(property, default)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.get(property)","title":"<code>property</code>","text":"(<code>str.</code>)           \u2013            <p>The name of the property to get.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.get(default)","title":"<code>default</code>","text":"(<code>Any</code>, default:                   <code>None</code> )           \u2013            <p>The default value to return if the property is not found.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has","title":"has","text":"<pre><code>has(property) -&gt; bool\n</code></pre> <p>Check if the Event has a specific property.</p> <p>See set for more details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the property exists, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has(self, property) -&gt; bool:\n    \"\"\"Check if the Event has a specific property.\n\n    See [set][amads.core.basics.Event.set] for more details.\n\n    Parameters\n    ----------\n    property : str\n        The name of the property to check.\n\n    Returns\n    -------\n    bool\n        True if the property exists, False otherwise.\n    \"\"\"\n    return (self.info is not None) and (property in self.info)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has(property)","title":"<code>property</code>","text":"(<code>str</code>)           \u2013            <p>The name of the property to check.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.time_shift","title":"time_shift","text":"<pre><code>time_shift(increment: float, content_only: bool = False) -&gt; EventGroup\n</code></pre> <p>Change the onset by an increment, affecting all content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>The object. This method modifies the <code>EventGroup</code>.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def time_shift(self, increment: float,\n               content_only: bool = False) -&gt; \"EventGroup\":\n    \"\"\"\n    Change the onset by an increment, affecting all content.\n\n    Parameters\n    ----------\n    increment : float\n        The time increment (in quarters or seconds).\n    content_only: bool\n        If true, preserves this container's time and shifts only\n        the content.\n\n    Returns\n    -------\n    Event\n        The object. This method modifies the `EventGroup`.\n    \"\"\"\n    if not content_only:\n        self._onset += increment  # type: ignore (onset is now number)\n    for elem in self.content:\n        elem.time_shift(increment)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.time_shift(increment)","title":"<code>increment</code>","text":"(<code>float</code>)           \u2013            <p>The time increment (in quarters or seconds).</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.time_shift(content_only)","title":"<code>content_only</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, preserves this container's time and shifts only the content.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.insert_copy_into","title":"insert_copy_into","text":"<pre><code>insert_copy_into(parent: EventGroup | None = None) -&gt; Event\n</code></pre> <p>Make a (mostly) deep copy of the <code>Event</code> and add to a new <code>parent</code>.</p> <p><code>Pitch</code> objects are considered immutable and are shared rather than copied.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Event</code>           \u2013            <p>A deep copy (except for parent and pitch) of the Event instance.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_copy_into(self,\n                     parent: Optional[\"EventGroup\"] = None) -&gt; \"Event\":\n    \"\"\"\n    Make a (mostly) deep copy of the `Event` and add to a new `parent`.\n\n    `Pitch` objects are considered immutable and are shared rather\n    than copied.\n\n    Parameters\n    ----------\n    parent : Optional(EventGroup)\n        The copied `Event` will be a child of `parent` if not `None`.\n        The parent is modified by this operation.\n\n    Returns\n    -------\n    Event\n        A deep copy (except for parent and pitch) of the Event instance.\n    \"\"\"\n    # remove link to parent to break link going up the tree\n    # preventing deep copy from copying the entire tree\n    original_parent = self.parent\n    self.parent = None\n    c = copy.deepcopy(self)  # deep copy of this event down to leaf nodes\n    self.parent = original_parent  # restore link to parent\n    if parent:\n        parent.insert(c)\n    return c\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.insert_copy_into(parent)","title":"<code>parent</code>","text":"(<code>Optional(EventGroup)</code>, default:                   <code>None</code> )           \u2013            <p>The copied <code>Event</code> will be a child of <code>parent</code> if not <code>None</code>. The parent is modified by this operation.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic() -&gt; bool\n</code></pre> <p>Determine if content is monophonic (non-overlapping notes).</p> <p>A monophonic list of notes has no overlapping notes (e.g., chords). Serves as a helper function for <code>ismonophonic</code> and <code>parts_are_monophonic</code>.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the list of notes is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def ismonophonic(self) -&gt; bool:\n    \"\"\"\n    Determine if content is monophonic (non-overlapping notes).\n\n    A monophonic list of notes has no overlapping notes (e.g., chords).\n    Serves as a helper function for `ismonophonic` and\n    `parts_are_monophonic`.\n\n    Returns\n    -------\n    bool\n        True if the list of notes is monophonic, False otherwise.\n    \"\"\"\n    prev = None\n    notes = self.list_all(Note)\n    # Sort the notes by start time\n    notes.sort(key=lambda note: note.onset)\n    # Check for overlaps\n    for note in notes:\n        if prev:\n            # 0.01 is to prevent precision errors when comparing floats\n            if note.onset - prev.offset &lt; -0.01:\n                return False\n        prev = note\n    return True\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.insert_emptycopy_into","title":"insert_emptycopy_into","text":"<pre><code>insert_emptycopy_into(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Create a deep copy of the EventGroup except for content.</p> <p>A new parent is provided as an argument and the copy is inserted into this parent. This method is  useful for copying an EventGroup without copying its content.  See also insert_copy_into to copy an EventGroup with its content into a new parent.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with the new parent (if any) and no content.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert_emptycopy_into(self, \n            parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Create a deep copy of the EventGroup except for content.\n\n    A new parent is provided as an argument and the copy is inserted\n    into this parent. This method is  useful for copying an\n    EventGroup without copying its content.  See also\n    [insert_copy_into][amads.core.basics.Event.insert_copy_into] to\n    copy an EventGroup *with* its content into a new parent.\n\n    Parameters\n    ----------\n    parent : Optional[EventGroup]\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with the new parent\n        (if any) and no content.\n    \"\"\"\n    # rather than customize __deepcopy__, we \"hide\" the content to avoid\n    # copying it. Then we restore it after copying and fix parent.\n    original_content = self.content\n    self.content = []\n    c = self.insert_copy_into(parent)\n    self.content = original_content\n    return c  #type: ignore (c will always be an EventGroup)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.insert_emptycopy_into(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.expand_chords","title":"expand_chords","text":"<pre><code>expand_chords(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Replace chords with the multiple notes they contain.</p> <p>Returns a deep copy with no parent unless parent is provided. Normally, you will call <code>score.expand_chords()</code> which returns a deep copy of Score with notes moved from each chord to the copy of the chord's parent (a Measure or a Part). The parent parameter is  primarily for internal use when <code>expand_chords</code> is called recursively on score content.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Chord instances expanded.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def expand_chords(self,\n                  parent: Optional[\"EventGroup\"] = None) -&gt; \"EventGroup\":\n    \"\"\"Replace chords with the multiple notes they contain.\n\n    Returns a deep copy with no parent unless parent is provided.\n    Normally, you will call `score.expand_chords()` which returns a deep\n    copy of Score with notes moved from each chord to the copy of the\n    chord's parent (a Measure or a Part). The parent parameter is \n    primarily for internal use when `expand_chords` is called recursively\n    on score content.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied EventGroup into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all\n        Chord instances expanded.\n    \"\"\"\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Chord):\n            for note in item.content:  # expand chord\n                note.insert_copy_into(group)\n        if isinstance(item, EventGroup):\n            item.expand_chords(group)  # recursion for deep copy/expand\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.expand_chords(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied EventGroup into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.find_all","title":"find_all","text":"<pre><code>find_all(elem_type: Type[Event]) -&gt; Generator[Event, None, None]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type. (The first <code>elem_type</code> encountered in a depth-first enumeration is returned without looking at any children in its <code>content</code>).</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>Event</code>           \u2013            <p>Instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def find_all(self, elem_type: Type[Event]) -&gt; Generator[Event, None, None]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type. (The first `elem_type` encountered\n    in a depth-first enumeration is returned without looking at any\n    children in its `content`).\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Yields\n    -------\n    Event\n        Instances of the specified type found within the EventGroup.\n    \"\"\"\n    # Algorithm: depth-first enumeration of EventGroup content.\n    # If elem_types are nested, only the top-level elem_type is\n    # returned since it is found first, and the content is not\n    # searched. This makes it efficient, e.g., to search for\n    # Parts in a Score without enumerating all Notes within.\n    for elem in self.content:\n        if isinstance(elem, elem_type):\n            yield elem\n        elif isinstance(elem, EventGroup):\n            yield from elem.find_all(elem_type)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.find_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.get_sorted_notes","title":"get_sorted_notes","text":"<pre><code>get_sorted_notes(has_ties: bool = True) -&gt; list[Note]\n</code></pre> <p>Return a list of sorted notes with merged ties.</p> <p>This should generally be called on Parts and Scores since in all other EventGroups, Events are in time order and Notes retrieved with <code>find_all()</code> or <code>list_all()</code> are in time order. However, <code>get_sorted_notes</code> also sorts notes into increasing pitch (<code>keynum</code>) where note onsets are equal.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If has_ties is False, but a tie is encountered.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list(Note)</code>           \u2013            <p>a list of sorted notes with merged ties</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def get_sorted_notes(self, has_ties: bool = True) -&gt; List[Note]:\n    \"\"\"Return a list of sorted notes with merged ties.\n\n    This should generally be called on Parts and Scores since\n    in all other EventGroups, Events are in time order and\n    Notes retrieved with `find_all()` or `list_all()` are in\n    time order. However, `get_sorted_notes` *also* sorts notes\n    into increasing pitch (`keynum`) where note onsets are equal.\n\n    Parameters\n    ----------\n    has_ties: bool\n        If True (default), copy the score, merge the ties, and\n        return a list of these merged copies. If False, assume\n        there are no ties and return a list of original notes.\n\n    Raises\n    ------\n    ValueError\n        If has_ties is False, but a tie is encountered.\n\n    Returns\n    -------\n    list(Note)\n        a list of sorted notes with merged ties\n    \"\"\"\n    if has_ties:\n        # score will have one Part, content of which is all Notes:\n        return self.flatten(collapse=True).content[0].content  # type: ignore\n    else:\n        notes : List[Note] = cast(List[Note], self.list_all(Note))\n        for note in notes:\n            if note.tie is not None:\n                raise ValueError(\n                        \"tie found by get_sorted_notes with has_ties=False\")\n        notes.sort(key=lambda x: (x.onset, x.pitch))\n        return notes\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.get_sorted_notes(has_ties)","title":"<code>has_ties</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), copy the score, merge the ties, and return a list of these merged copies. If False, assume there are no ties and return a list of original notes.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has_instanceof","title":"has_instanceof","text":"<pre><code>has_instanceof(the_class: Type[Event]) -&gt; bool\n</code></pre> <p>Test if EventGroup contains any instances of <code>the_class</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains an instance of the_class.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_instanceof(self, the_class: Type[Event]) -&gt; bool:\n    \"\"\"Test if EventGroup contains any instances of `the_class`.\n\n    Parameters\n    ----------\n    the_class : Type[Event]\n        The class type to check for.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains an instance of the_class.\n    \"\"\"\n    instances = self.find_all(the_class)\n    # if there are no instances (of the_class), next will return \"empty\":\n    return next(instances, \"empty\") != \"empty\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has_instanceof(the_class)","title":"<code>the_class</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The class type to check for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has_rests","title":"has_rests","text":"<pre><code>has_rests() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any <code>Rest</code> objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Rest objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_rests(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any `Rest` objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Rest objects.\n    \"\"\"\n    return self.has_instanceof(Rest)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has_chords","title":"has_chords","text":"<pre><code>has_chords() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Chord objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_chords(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Chord objects.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Chord objects.\n    \"\"\"\n    return self.has_instanceof(Chord)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has_ties","title":"has_ties","text":"<pre><code>has_ties() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any tied notes.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any tied notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_ties(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any tied notes.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any tied notes.\n    \"\"\"\n    notes = self.find_all(Note)\n    for note in notes:\n        if note.tie:\n            return True\n    return False\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.has_measures","title":"has_measures","text":"<pre><code>has_measures() -&gt; bool\n</code></pre> <p>Test if EventGroup (e.g., Score, Part, ...) has any Measures.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True iff the EventGroup contains any Measure objects.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def has_measures(self) -&gt; bool:\n    \"\"\"Test if EventGroup (e.g., Score, Part, ...) has any Measures.\n\n    Returns\n    -------\n    bool\n        True iff the EventGroup contains any Measure objects.\n    \"\"\"\n    return self.has_instanceof(Measure)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.inherit_duration","title":"inherit_duration","text":"<pre><code>inherit_duration() -&gt; EventGroup\n</code></pre> <p>Set the duration of this EventGroup according to maximum offset.</p> <p>The <code>duration</code> is set to the maximum offset (end) time of the children. If the EventGroup is empty, the duration is set to 0. This method modifies this <code>EventGroup</code> instance.</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with updated duration.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def inherit_duration(self) -&gt; \"EventGroup\":\n    \"\"\"Set the duration of this EventGroup according to maximum offset.\n\n    The `duration` is set to the maximum offset (end) time of the\n    children. If the EventGroup is empty, the duration is set to 0.\n    This method modifies this `EventGroup` instance.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with updated duration.\n    \"\"\"\n    onset = 0 if self._onset == None else self._onset\n    max_offset = onset\n    for elem in self.content:\n        max_offset = max(max_offset, elem.offset)\n    self.duration = max_offset - onset\n\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.insert","title":"insert","text":"<pre><code>insert(event: Event) -&gt; EventGroup\n</code></pre> <p>Insert an event.</p> <p>Sets the <code>parent</code> of <code>event</code> to this <code>EventGroup</code> and makes <code>event</code> be a member of this <code>EventGroup.content</code>. No changes are made to <code>event.onset</code> or <code>self.duration</code>. Insert <code>event</code> in <code>content</code> just before the first element with a greater onset. The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the event inserted.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If event._onset is None (it must be a number)</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def insert(self, event: Event) -&gt; \"EventGroup\":\n    \"\"\"Insert an event.\n\n    Sets the `parent` of `event` to this `EventGroup` and makes `event`\n    be a member of this `EventGroup.content`. No changes are made to\n    `event.onset` or `self.duration`. Insert `event` in `content` just\n    before the first element with a greater onset. The method modifies\n    this object (self).\n\n    Parameters\n    ----------\n    event : Event\n        The event to be inserted.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the event inserted.\n\n    Raises\n    ------\n    ValueError\n        If event._onset is None (it must be a number)\n    \"\"\"\n    assert not event.parent\n    if event._onset is None:  # must be a number\n        raise ValueError(f\"event's _onset attribute must be a number\")\n    atend = self.last()\n    if atend and event.onset &lt; atend.onset:\n        # search in reverse from end\n        i = len(self.content) - 2\n        while i &gt;= 0 and self.content[i].onset &gt; event.onset:\n            i -= 1\n        # now i is either -1 or content[i] &lt;= event.onset, so\n        # insert event at content[i+1]\n        self.content.insert(i + 1, event)\n    else:  # simply append at the end of content:\n        self.content.append(event)\n    event.parent = self\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.insert(event)","title":"<code>event</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be inserted.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.last","title":"last","text":"<pre><code>last() -&gt; Event | None\n</code></pre> <p>Retrieve the last event in the content list.</p> <p>Because the <code>content</code> list is sorted by <code>onset</code>, the returned <code>Event</code> is simply the last element of <code>content</code>, but not necessarily the event with the greatest <code>offset</code>.</p> <p>Returns:</p> <ul> <li> <code>Event | None</code>           \u2013            <p>The last event in the content list or None if the list is empty.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def last(self) -&gt; Optional[Event]:\n    \"\"\"Retrieve the last event in the content list.\n\n    Because the `content` list is sorted by `onset`, the returned\n    `Event` is simply the last element of `content`, but not\n    necessarily the event with the greatest *`offset`*.\n\n    Returns\n    -------\n    Optional[Event]\n        The last event in the content list or None if the list is empty.\n    \"\"\"\n    return self.content[-1] if len(self.content) &gt; 0 else None\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.list_all","title":"list_all","text":"<pre><code>list_all(elem_type: Type[Event]) -&gt; list[Event]\n</code></pre> <p>Find all instances of a specific type within the EventGroup.</p> <p>Assumes that objects of type <code>elem_type</code> are not nested within other objects of the same type.  See also find_all, which returns a generator instead of a list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Event]</code>           \u2013            <p>A list of all instances of the specified type found within the EventGroup.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def list_all(self, elem_type: Type[Event]) -&gt; list[Event]:\n    \"\"\"Find all instances of a specific type within the EventGroup.\n\n    Assumes that objects of type `elem_type` are not nested within\n    other objects of the same type.  See also\n    [find_all][amads.core.basics.EventGroup.find_all], which returns\n    a generator instead of a list.\n\n    Parameters\n    ----------\n    elem_type : Type[Event]\n        The type of event to search for.\n\n    Returns\n    -------\n    list[Event]\n        A list of all instances of the specified type found\n        within the EventGroup.\n    \"\"\"\n    return list(self.find_all(elem_type))\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.list_all(elem_type)","title":"<code>elem_type</code>","text":"(<code>Type[Event]</code>)           \u2013            <p>The type of event to search for.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.merge_tied_notes","title":"merge_tied_notes","text":"<pre><code>merge_tied_notes(\n    parent: EventGroup | None = None, ignore: list[Note] = []\n) -&gt; EventGroup\n</code></pre> <p>Create a new <code>EventGroup</code> with tied notes replaced by single notes.</p> <p>If ties cross staffs, the replacement is placed in the staff of the first note in the tied sequence. Insert the new <code>EventGroup</code> into <code>parent</code>.</p> <p>Ordinarily, this method is called on a Score with no parameters. The parameters are used when <code>Score.merge_tied_notes()</code> calls this method recursively on <code>EventGroup</code>s within the Score such as <code>Part</code>s and <code>Staff</code>s.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A copy with tied notes replaced by equivalent single notes.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def merge_tied_notes(self, parent: Optional[\"EventGroup\"] = None,\n                     ignore: list[Note] = []) -&gt; \"EventGroup\":\n    \"\"\"Create a new `EventGroup` with tied notes replaced by single notes.\n\n    If ties cross staffs, the replacement is placed in the staff of the\n    first note in the tied sequence. Insert the new `EventGroup` into\n    `parent`.\n\n    Ordinarily, this method is called on a Score with no parameters. The\n    parameters are used when `Score.merge_tied_notes()` calls this method\n    recursively on `EventGroup`s within the Score such as `Part`s and\n    `Staff`s.\n\n    Parameters\n    ----------\n    parent: Optional(EventGroup)\n        Where to insert the result.\n\n    ignore: Optional(list[Note])\n        This parameter is used internally. Caller should not use\n        this parameter.\n\n    Returns\n    -------\n    EventGroup\n        A copy with tied notes replaced by equivalent single notes.\n    \"\"\"\n    # Algorithm: Find all notes, removing tied notes and updating\n    # duration when ties are found. These tied notes are added to\n    # ignore so they can be skipped when they are encountered.\n\n    group = self.insert_emptycopy_into(parent)\n    for event in self.content:\n        if isinstance(event, Note):\n            if event in ignore:  # do not copy tied notes into group;\n                if event.tie:\n                    ignore.append(event.tie)  # add tied note to ignore\n                # We will not see this note again, so\n                # we can also remove it from ignore. Removal is expensive\n                # but it could be worse for ignore to grow large when there\n                # are many ties since we have to search it entirely once\n                # per note. An alternate representation might be a set to\n                # make searching fast.\n                ignore.remove(event)\n            else:\n                if event.tie:\n                    tied_note = event.tie  # save the tied-to note\n                    event.tie = None  # block the copy\n                    ignore.append(tied_note)\n                    # copy note into group:\n                    event_copy = event.insert_copy_into(group)\n                    event.tie = tied_note  # restore original event\n                    # this is subtle: event.tied_duration (a property) will\n                    # sum up durations of all the tied notes. Since\n                    # event_copy is not tied, the sum of durations is\n                    # stored on that one event_copy:\n                    event_copy.duration = event.tied_duration\n                else:  # put the untied note into group\n                    event.insert_copy_into(group)\n        elif isinstance(event, EventGroup):\n            event.merge_tied_notes(group, ignore)\n        else:\n            event.insert_copy_into(group)  # simply copy to new parent\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.merge_tied_notes(parent)","title":"<code>parent</code>","text":"(<code>EventGroup | None</code>, default:                   <code>None</code> )           \u2013            <p>Where to insert the result.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.merge_tied_notes(ignore)","title":"<code>ignore</code>","text":"(<code>list[Note]</code>, default:                   <code>[]</code> )           \u2013            <p>This parameter is used internally. Caller should not use this parameter.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.pack","title":"pack","text":"<pre><code>pack(onset: float = 0.0, sequential: bool = False) -&gt; float\n</code></pre> <p>Adjust the content to onsets starting with the onset parameter.</p> <p>By default onsets are set to <code>onset</code> and the duration of self is set to the maximum duration of the content. pack() works recursively on elements that are EventGroups. Setting sequential to True implements sequential packing, where events are placed one after another.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>duration of self</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def pack(self, onset: float = 0.0, sequential : bool = False) -&gt; float:\n    \"\"\"Adjust the content to onsets starting with the onset parameter.\n\n    By default onsets are set to `onset` and the duration of self is set to\n    the maximum duration of the content. pack() works recursively on\n    elements that are EventGroups. Setting sequential to True implements\n    sequential packing, where events are placed one after another.\n\n    Parameters\n    ----------\n    onset : float\n        The onset (start) time for this object.\n\n    Returns\n    -------\n    float\n        duration of self\n    \"\"\"\n    self.onset = onset\n    self.duration = 0\n    for elem in self.content:\n        elem.onset = onset\n        if isinstance(elem, EventGroup):   # either Sequence or Concurrence\n            elem.duration = elem.pack(onset)  #type: ignore\n        if sequential:\n            onset += elem.duration\n        else:\n            self.duration = max(self.duration, elem.duration)\n    if sequential:\n        self.duration = onset - self.onset\n    return self.duration\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.pack(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The onset (start) time for this object.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.quantize","title":"quantize","text":"<pre><code>quantize(divisions: int) -&gt; EventGroup\n</code></pre> <p>Align onsets and durations to a rhythmic grid.</p> <p>Assumes time units are quarters. (See Score.convert_to_quarters.)</p> <p>Modify all times and durations to a multiple of divisions per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets are moved to the nearest quantized time. Any resulting duration change is less than one quantum, but not necessarily less than 0.5 quantum, since the onset and offset can round in opposite directions by up to 0.5 quantum each. Any non-zero duration that would quantize to zero duration gets a duration of one quantum since zero duration is almost certainly going to cause notation and visualization problems.</p> <p>Special cases for zero duration:</p> <ol> <li>If the original duration is zero as in metadata or possibly        grace notes, we preserve that.</li> <li>If a tied note duration quantizes to zero, we remove the        tied note entirely provided some other note in the tied        sequence has non-zero duration. If all tied notes quantize        to zero, we keep the first one and set its duration to        one quantum.</li> </ol> <p>This method modifies this EventGroup and all its content in place.</p> <p>Note that there is no way to specify \"sixteenths or eighth triplets\" because 6 would not allow sixteenths and 12 would admit sixteenth triplets. Using tuples as in Music21, e.g., (4, 3) for this problem creates another problem: if quantization is to time points 1/4, 1/3, then the difference is 1/12 or a thirty-second triplet. If the quantization is applied to durations, then you could have 1/4 + 1/3 = 7/12, and the remaining duration in a single beat would be 5/12, which is not expressible as sixteenths, eighth triplets or any tied combination.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with (modified in place)  quantized times.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def quantize(self, divisions: int) -&gt; \"EventGroup\":\n    \"\"\"Align onsets and durations to a rhythmic grid.\n\n    Assumes time units are quarters. (See [Score.convert_to_quarters](\n            basics.md#amads.core.basics.Score.convert_to_quarters).)\n\n    Modify all times and durations to a multiple of divisions\n    per quarter note, e.g., 4 for sixteenth notes. Onsets and offsets\n    are moved to the nearest quantized time. Any resulting duration\n    change is less than one quantum, but not necessarily less than\n    0.5 quantum, since the onset and offset can round in opposite\n    directions by up to 0.5 quantum each. Any non-zero duration that would\n    quantize to zero duration gets a duration of one quantum since\n    zero duration is almost certainly going to cause notation and\n    visualization problems.\n\n    Special cases for zero duration:\n\n    1. If the original duration is zero as in metadata or possibly\n           grace notes, we preserve that.\n    2. If a tied note duration quantizes to zero, we remove the\n           tied note entirely provided some other note in the tied\n           sequence has non-zero duration. If all tied notes quantize\n           to zero, we keep the first one and set its duration to\n           one quantum.\n\n    This method modifies this EventGroup and all its content in place.\n\n    Note that there is no way to specify \"sixteenths or eighth triplets\"\n    because 6 would not allow sixteenths and 12 would admit sixteenth\n    triplets. Using tuples as in Music21, e.g., (4, 3) for this problem\n    creates another problem: if quantization is to time points 1/4, 1/3,\n    then the difference is 1/12 or a thirty-second triplet. If the\n    quantization is applied to durations, then you could have 1/4 + 1/3\n    = 7/12, and the remaining duration in a single beat would be 5/12,\n    which is not expressible as sixteenths, eighth triplets or any tied\n    combination.\n\n    Parameters\n    ----------\n    divisions : int\n        The number of divisions per quarter note, e.g., 4 for\n        sixteenths, to control quantization.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with (modified in place) \n        quantized times.\n    \"\"\"\n\n    super()._quantize(divisions)\n    # iterating through content is tricky because we may delete a\n    # Note, shifting the content:\n    i = 0\n    while i &lt; len(self.content):\n        event = self.content[i]\n        event._quantize(divisions)\n        if event == self.content[i]:\n            i += 1\n        # otherwise, we deleted event so the next event to\n        # quantize is at index i; don't incremenet i\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.quantize(divisions)","title":"<code>divisions</code>","text":"(<code>int</code>)           \u2013            <p>The number of divisions per quarter note, e.g., 4 for sixteenths, to control quantization.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.remove","title":"remove","text":"<pre><code>remove(element: Event) -&gt; EventGroup\n</code></pre> <p>Remove an element from the content list. </p> <p>The method modifies this object (self).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance (self) with the element removed. The returned value is not a copy.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove(self, element: Event) -&gt; \"EventGroup\":\n    \"\"\"Remove an element from the content list. \n\n    The method modifies this object (self).\n\n    Parameters\n    ----------\n    element : Event\n        The event to be removed.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance (self) with the element removed.\n        The returned value is not a copy.\n    \"\"\"\n    self.content.remove(element)\n    element.parent = None\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.remove(element)","title":"<code>element</code>","text":"(<code>Event</code>)           \u2013            <p>The event to be removed.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.remove_rests","title":"remove_rests","text":"<pre><code>remove_rests(parent: EventGroup | None = None) -&gt; EventGroup\n</code></pre> <p>Remove all Rest objects from content.</p> <p>Returns a deep copy with no parent unless parent is provided.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>A deep copy of the EventGroup instance with all Rest objects removed.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def remove_rests(self, parent: Union[\"EventGroup\", \n                                     None] = None) -&gt; \"EventGroup\":\n    \"\"\"Remove all Rest objects from content.\n\n    Returns a deep copy with no parent unless parent is provided.\n\n    Parameters\n    ----------\n    parent : EventGroup\n        The new parent to insert the copied Event into.\n\n    Returns\n    -------\n    EventGroup\n        A deep copy of the EventGroup instance with all Rest\n        objects removed.\n    \"\"\"\n    # implementation detail: when called without argument, remove_rests\n    # makes a deep copy of the subtree and returns the copy without a\n    # parent. remove_rests calls itself recursively *with* a parameter\n    # indicating that the subtree copy should be inserted into a\n    # parent which is the new copy at the next level up. Of course,\n    # we check for and ignore Rests so they are never copied.\n    group = self.insert_emptycopy_into(parent)\n    for item in self.content:\n        if isinstance(item, Rest):\n            continue  # skip the Rests while making deep copy\n        if isinstance(item, EventGroup):\n            item.remove_rests(group)  # recursion for deep copy\n        else:\n            item.insert_copy_into(group)  # deep copy non-EventGroup\n    return group\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.remove_rests(parent)","title":"<code>parent</code>","text":"(<code>EventGroup</code>, default:                   <code>None</code> )           \u2013            <p>The new parent to insert the copied Event into.</p>"},{"location":"reference/basics_more/#amads.core.basics.Chord.__str__","title":"__str__","text":"<pre><code>__str__() -&gt; str\n</code></pre> <p>Short string representation</p> Source code in <code>amads/core/basics.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"Short string representation\n    \"\"\"\n    return f\"{self.__class__.__name__}({self._event_times()})\"\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.show","title":"show","text":"<pre><code>show(indent: int = 0, file: TextIO | None = None) -&gt; EventGroup\n</code></pre> <p>Print the EventGroup information.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The EventGroup instance itself.</p> </li> </ul> Source code in <code>amads/core/basics.py</code> <pre><code>def show(self, indent: int = 0,\n        file: Optional[TextIO] = None) -&gt; \"EventGroup\":\n    \"\"\"Print the EventGroup information.\n\n    Parameters\n    ----------\n    indent : int\n        The indentation level for display.\n\n    Returns\n    -------\n    EventGroup\n        The EventGroup instance itself.\n    \"\"\"\n    print(\" \" * indent, self, sep=\"\", file=file)\n    for elem in self.content:\n        elem.show(indent + 4, file=file)  # type: ignore (show exists)\n    return self\n</code></pre>"},{"location":"reference/basics_more/#amads.core.basics.Chord.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The indentation level for display.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap","title":"TimeMap","text":"<pre><code>TimeMap(qpm=100.0)\n</code></pre> <p>Implement the <code>time_map</code> attribute of <code>Score</code> class.</p> <p>Every <code>Score</code> has a <code>time_map</code> attribute whose value is a <code>TimeMap</code> that maintains a mapping between time in seconds and beats in quarters. A <code>TimeMap</code> encodes the information in a MIDI File tempo track as well as tempo information from a Music XML score.</p> <p>This class holds a list representing tempo changes as a list of (time, quarter) pairs, which you can think of as tempo changes. More mathematically, they are breakpoints in a piece-wise linear function that maps from time to quarter or from quarter to time.</p> <p>Since tempo is not continuous, the tempo at a breakpoint is defined to be the tempo just after the breakpoint.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>changes</code>               (<code>list of MapQuarter</code>)           \u2013            <p>List of (time, quarter) breakpoints for piece-wise linear mapping.</p> </li> <li> <code>last_tempo</code>               (<code>float</code>)           \u2013            <p>Final quarters per second (qps) for extrapolatation.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tm = TimeMap(qpm=120)\n&gt;&gt;&gt; tm.append_change(4.0, 60.0)  # change to 60 qpm at quarter 4\n&gt;&gt;&gt; tm.quarter_to_time(5.0)\n3.0\n&gt;&gt;&gt; tm.time_to_quarter(3.0)\n5.0\n</code></pre> <p>Methods:</p> <ul> <li> <code>show</code>             \u2013              <p>Print a summary of this time map.</p> </li> <li> <code>deep_copy</code>             \u2013              <p>Make a full copy of this time map.</p> </li> <li> <code>append_change</code>             \u2013              <p>Append a tempo change at a given quarter.</p> </li> <li> <code>get_time_at</code>             \u2013              <p>Get the time in seconds at a given index in the changes list.</p> </li> <li> <code>get_tempo_at</code>             \u2013              <p>Get the tempo at a given index in the changes list.</p> </li> <li> <code>quarter_to_time</code>             \u2013              <p>Convert time in quarters to time to seconds.</p> </li> <li> <code>quarter_to_tempo</code>             \u2013              <p>Get the tempo in qpm at a given quarter.</p> </li> <li> <code>time_to_quarter</code>             \u2013              <p>Convert time in seconds to quarter position.</p> </li> <li> <code>time_to_tempo</code>             \u2013              <p>Get the tempo in qpm at a given time (in seconds).</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def __init__(self, qpm=100.0):\n    self.changes = [MapQuarter(0.0, 0.0)]  # initial quarter\n    self.last_tempo = qpm / 60.0  # 100 qpm default\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap(qpm)","title":"<code>qpm</code>","text":"(<code>float</code>, default:                   <code>100.0</code> )           \u2013            <p>Initial tempo in quarters per minute (default is 100.0).</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.show","title":"show","text":"<pre><code>show(indent: int = 0, file=stdout) -&gt; None\n</code></pre> <p>Print a summary of this time map.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def show(self, indent: int = 0, file=sys.stdout) -&gt; None:\n    \"\"\"Print a summary of this time map.\n\n    Parameters\n    ----------\n    indent : int, optional\n        Number of spaces to indent (default is 0).\n    file : TextIO, optional\n        The file to print to (default is sys.stdout).\n\n    Returns\n    -------\n    None\n    \"\"\"\n    print(\" \" * indent, \"time_map: [\", sep=\"\", end=\"\", file=file)\n    col = indent + 11\n    need_blank = \"\"\n    for i, mb in enumerate(self.changes):\n        tempo = self.get_tempo_at(i)\n        mbs = f\"({mb.quarter:.2f}, {mb.time:.3f}s, {tempo:.3f}qpm)\"\n        if len(mbs) + col &gt; 79:\n            print(\"\\n\", \" \" * (indent + 10), end=\"\", file=file)\n            col = indent + 11\n        print(need_blank, mbs, sep=\"\", end=\"\", file=file)\n        col += len(mbs)\n        need_blank = \" \"\n    print(\"]\", file=file)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.show(indent)","title":"<code>indent</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Number of spaces to indent (default is 0).</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.show(file)","title":"<code>file</code>","text":"(<code>TextIO</code>, default:                   <code>stdout</code> )           \u2013            <p>The file to print to (default is sys.stdout).</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.deep_copy","title":"deep_copy","text":"<pre><code>deep_copy() -&gt; TimeMap\n</code></pre> <p>Make a full copy of this time map.</p> <p>Returns:</p> <ul> <li> <code>TimeMap</code>           \u2013            <p>A deep copy of this TimeMap instance.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def deep_copy(self) -&gt; \"TimeMap\":\n    \"\"\"Make a full copy of this time map.\n\n    Returns\n    -------\n    TimeMap\n        A deep copy of this TimeMap instance.\n    \"\"\"\n    newtm = TimeMap(qpm=self.last_tempo * 60)\n    for i in self.changes[1:]:\n        newtm.changes.append(i.copy())\n    return newtm\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.append_change","title":"append_change","text":"<pre><code>append_change(quarter: float, tempo: float) -&gt; None\n</code></pre> <p>Append a tempo change at a given quarter.</p> <p>Append a <code>MapQuarter</code> specifying a change to tempo at quarter. quarter must be at least as great as last MapQuarter's quarter. You cannot insert a tempo change before the end of the TimeMap. The <code>tempo</code> will hold forever beginning at <code>quarter</code> unless you call <code>append_change</code> again to change the tempo somewhere beyond <code>quarter</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>None</code>           \u2013            </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def append_change(self, quarter: float, tempo: float) -&gt; None:\n    \"\"\"Append a tempo change at a given quarter.\n\n    Append a `MapQuarter` specifying a change to tempo at quarter.\n    quarter must be at least as great as last MapQuarter's quarter.\n    You cannot insert a tempo change before the end of the TimeMap.\n    The `tempo` will hold forever beginning at `quarter` unless you call\n    `append_change` again to change the tempo somewhere beyond\n    `quarter`.\n\n    Parameters\n    ----------\n    quarter: float\n        The quarter measured in quarters where the tempo changes\n    tempo: float\n        The new tempo at quarter measured in quarters per minute.\n        Typically, this is the same as beats per minute (BPM),\n        but only when a beat lasts one quarter.\n\n    Returns\n    -------\n    None\n    \"\"\"\n    last_quarter = self.changes[-1].quarter  # get the last quarter\n    assert quarter &gt;= last_quarter\n    if quarter &gt; last_quarter:\n        self.changes.append(\n            MapQuarter(self.quarter_to_time(quarter), quarter)\n        )\n    self.last_tempo = tempo / 60.0  # from qpm to qps\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.append_change(quarter)","title":"<code>quarter</code>","text":"(<code>float</code>)           \u2013            <p>The quarter measured in quarters where the tempo changes</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.append_change(tempo)","title":"<code>tempo</code>","text":"(<code>float</code>)           \u2013            <p>The new tempo at quarter measured in quarters per minute. Typically, this is the same as beats per minute (BPM), but only when a beat lasts one quarter.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.get_time_at","title":"get_time_at","text":"<pre><code>get_time_at(index: int) -&gt; float\n</code></pre> <p>Get the time in seconds at a given index in the changes list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The time in seconds at the specified index.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def get_time_at(self, index: int) -&gt; float:\n    \"\"\"Get the time in seconds at a given index in the changes list.\n\n    Parameters\n    ----------\n    index : int\n        The index in the changes list.\n\n    Returns\n    -------\n    float\n        The time in seconds at the specified index.\n    \"\"\"\n    return self.changes[index].time\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.get_time_at(index)","title":"<code>index</code>","text":"(<code>int</code>)           \u2013            <p>The index in the changes list.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.get_tempo_at","title":"get_tempo_at","text":"<pre><code>get_tempo_at(index: int) -&gt; float\n</code></pre> <p>Get the tempo at a given index in the changes list.</p> <p>The tempo changes at each breakpoint. This method returns the tempo in QPM just after the breakpoint at the specified index.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The tempo in quarters per minute immediately after the specified index.</p> </li> <li> <code>The tempo at entry i is the tempo in effect JUST BEFORE entry i,</code>           \u2013            </li> </ul> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The tempo in quarters per minute (qpm) just after entry i.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def get_tempo_at(self, index: int) -&gt; float:\n    \"\"\"Get the tempo at a given index in the changes list.\n\n    The tempo changes at each breakpoint. This method returns\n    the tempo in QPM just after the breakpoint at the specified\n    index.\n\n    Parameters\n    ----------\n    index : int\n        The index in the changes list.\n\n    Returns\n    -------\n    float\n        The tempo in quarters per minute immediately after\n        the specified index.\n\n    The tempo at entry i is the tempo in effect JUST BEFORE entry i,\n\n    Parameters\n    ----------\n    index : int\n        The index in the changes list.\n\n    Returns\n    -------\n    float\n        The tempo in quarters per minute (qpm) just after entry i.\n    \"\"\"\n    # two cases here: (1) we're at or beyond the last entry, so\n    #   use last_tempo or extrapolate, OR\n    #   (2) there's only one entry, so use last_tempo or\n    #   return the default tempo\n    if index &lt; 0:\n        raise ValueError(\"Index must be non-negative\")\n    if index &gt;= len(self.changes) - 1:\n        # special case: quarter &gt;= last (time, quarter) pair\n        # so extrapolate using last_tempo if it is there\n        return self.last_tempo * 60.0\n    mb0 = self.changes[index]\n    mb1 = self.changes[index + 1]\n    time_dif = mb1.time - mb0.time\n    quarter_dif = mb1.quarter - mb0.quarter\n    return quarter_dif * 60.0 / time_dif\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.get_tempo_at(index)","title":"<code>index</code>","text":"(<code>int</code>)           \u2013            <p>The index in the changes list.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.get_tempo_at(index)","title":"<code>index</code>","text":"(<code>int</code>)           \u2013            <p>The index in the changes list.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.quarter_to_time","title":"quarter_to_time","text":"<pre><code>quarter_to_time(quarter: float) -&gt; float\n</code></pre> <p>Convert time in quarters to time to seconds.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The time in seconds corresponding to <code>quarter</code>.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def quarter_to_time(self, quarter: float) -&gt; float:\n    \"\"\"Convert time in quarters to time to seconds.\n\n    Parameters\n    ----------\n    quarter: float\n        A score position in changes.\n\n    Returns\n    -------\n    float\n        The time in seconds corresponding to `quarter`.\n    \"\"\"\n    if quarter &lt;= 0:  # there is no negative time or tempo before 0\n        return quarter  # so just pretend like tempo is 60 qpm\n    i = self._quarter_to_insert_index(quarter)\n    return self.changes[i - 1].time + (\n        quarter - self.changes[i - 1].quarter\n    ) * 60.0 / self.get_tempo_at(i - 1)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.quarter_to_time(quarter)","title":"<code>quarter</code>","text":"(<code>float</code>)           \u2013            <p>A score position in changes.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.quarter_to_tempo","title":"quarter_to_tempo","text":"<pre><code>quarter_to_tempo(quarter: float) -&gt; float\n</code></pre> <p>Get the tempo in qpm at a given quarter.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The tempo at <code>quarter</code>. If there is a tempo change here, returns the tempo on the right (after the change).</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def quarter_to_tempo(self, quarter: float) -&gt; float:\n    \"\"\"Get the tempo in qpm at a given quarter.\n\n    Parameters\n    ----------\n    quarter: float\n        A score position in changes.\n\n    Returns\n    -------\n    float\n        The tempo at `quarter`. If there is a tempo change here,\n        returns the tempo on the right (after the change).\n    \"\"\"\n    return self.get_tempo_at(self._quarter_to_insert_index(quarter) - 1)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.quarter_to_tempo(quarter)","title":"<code>quarter</code>","text":"(<code>float</code>)           \u2013            <p>A score position in changes.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.time_to_quarter","title":"time_to_quarter","text":"<pre><code>time_to_quarter(time: float) -&gt; float\n</code></pre> <p>Convert time in seconds to quarter position.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The score position in changes corresponding to <code>time</code>.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def time_to_quarter(self, time: float) -&gt; float:\n    \"\"\"Convert time in seconds to quarter position.\n\n    Parameters\n    ----------\n    time: float\n        A score time in seconds.\n\n    Returns\n    -------\n    float\n        The score position in changes corresponding to `time`.\n    \"\"\"\n    if time &lt;= 0:\n        return time\n    i = self._time_to_insert_index(time)\n    return (\n        self.changes[i - 1].quarter\n        + (time - self.changes[i - 1].time)\n        * self.get_tempo_at(i - 1)\n        / 60.0\n    )\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.time_to_quarter(time)","title":"<code>time</code>","text":"(<code>float</code>)           \u2013            <p>A score time in seconds.</p>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.time_to_tempo","title":"time_to_tempo","text":"<pre><code>time_to_tempo(time: float) -&gt; float\n</code></pre> <p>Get the tempo in qpm at a given time (in seconds).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The tempo at <code>time</code>. If there is a tempo change here, use the tempo on the right (aftr the change).</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def time_to_tempo(self, time: float) -&gt; float:\n    \"\"\"Get the tempo in qpm at a given time (in seconds).\n\n    Parameters\n    ----------\n    time: float\n        A score time in seconds.\n\n    Returns\n    -------\n    float\n        The tempo at `time`. If there is a tempo change here,\n        use the tempo on the right (aftr the change).\n    \"\"\"\n    return self.get_tempo_at(self._time_to_insert_index(time) - 1)\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.TimeMap.time_to_tempo(time)","title":"<code>time</code>","text":"(<code>float</code>)           \u2013            <p>A score time in seconds.</p>"},{"location":"reference/basics_more/#amads.core.timemap.MapQuarter","title":"MapQuarter","text":"<pre><code>MapQuarter(time: float, quarter: float)\n</code></pre> <p>Represents a (time, quarter) pair in a piece-wise linear mapping.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>time</code>               (<code>float</code>)           \u2013            <p>The time in seconds.</p> </li> <li> <code>quarter</code>               (<code>float</code>)           \u2013            <p>The corresponding quarter note position.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>copy</code>             \u2013              <p>Return a copy of the MapQuarter instance.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def __init__(self, time: float, quarter: float):\n    self.time = time\n    self.quarter = quarter\n</code></pre>"},{"location":"reference/basics_more/#amads.core.timemap.MapQuarter(time)","title":"<code>time</code>","text":"(<code>float</code>)           \u2013            <p>The time in seconds.</p>"},{"location":"reference/basics_more/#amads.core.timemap.MapQuarter(quarter)","title":"<code>quarter</code>","text":"(<code>float</code>)           \u2013            <p>The corresponding quarter note position.</p>"},{"location":"reference/basics_more/#amads.core.timemap.MapQuarter-functions","title":"Functions","text":""},{"location":"reference/basics_more/#amads.core.timemap.MapQuarter.copy","title":"copy","text":"<pre><code>copy() -&gt; MapQuarter\n</code></pre> <p>return a copy of this MapQuarter</p> <p>Returns:</p> <ul> <li> <code>MapQuarter</code>           \u2013            <p>A copy of this MapQuarter instance.</p> </li> </ul> Source code in <code>amads/core/timemap.py</code> <pre><code>def copy(self) -&gt; \"MapQuarter\":\n    \"\"\"return a copy of this MapQuarter\n\n    Returns\n    -------\n    MapQuarter\n        A copy of this MapQuarter instance.\n    \"\"\"\n    return MapQuarter(self.time, self.quarter)\n</code></pre>"},{"location":"reference/distribution/","title":"Distribution Module","text":""},{"location":"reference/distribution/#amads.core.distribution.Distribution","title":"Distribution","text":"<pre><code>Distribution(\n    name: str,\n    data: list[Any],\n    distribution_type: str,\n    dimensions: list[int],\n    x_categories: list[int | float | str],\n    x_label: str,\n    y_categories: list[int | float | str] | None,\n    y_label: str,\n)\n</code></pre> <p>Represents a probability distribution or histogram and its metadata.</p> <p>See histogram.py for Histogram1D and Histogram2D, which facilitate the computation of distributions from data.</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>same as Parameters (above)</code>           \u2013            </li> </ul> <p>Methods:</p> <ul> <li> <code>normalize</code>             \u2013              <p>Convert weights or counts to a probability distribution that sums to 1.</p> </li> <li> <code>plot</code>             \u2013              <p>Virtual plot function for Distribution.</p> </li> <li> <code>show</code>             \u2013              <p>Print information about the distribution</p> </li> <li> <code>plot_multiple</code>             \u2013              <p>Plot multiple distributions into a single Figure using vertically</p> </li> <li> <code>plot_grouped_1d</code>             \u2013              <p>Overlay multiple 1-D distributions on a single axes.</p> </li> </ul> Source code in <code>amads/core/distribution.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    data: List[Any],\n    distribution_type: str,\n    dimensions: List[int],\n    x_categories: List[Union[int, float, str]],\n    x_label: str,\n    y_categories: Optional[List[Union[int, float, str]]],\n    y_label: str,\n):\n    \"\"\"\n    Initialize a Distribution instance.\n    \"\"\"\n    self.name = name\n    self.data = data\n    self.distribution_type = distribution_type\n    self.dimensions = dimensions\n    self.x_categories = x_categories\n    self.x_label = x_label\n    self.y_categories = y_categories\n    self.y_label = y_label\n</code></pre>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The name of the distribution used for plot titles.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(data)","title":"<code>data</code>","text":"(<code>list[Any]</code>)           \u2013            <p>The data points for the distribution.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(distribution_type)","title":"<code>distribution_type</code>","text":"(<code>str</code>)           \u2013            <p>The type of distribution. Currently used values are described below. \"weights\" can mean either probabilities or raw counts.</p> <ul> <li>\"pitch_class\" - weights for 12 pitch classes, possibly weighted     by duration.</li> <li>\"interval\" - weights for pitch intervals, possibly weighted by     duration.</li> <li>\"pitch_class_interval\" - weights for pitch class intervals,     possibly weighted by duration.     (mod 12, not currently used; should there also be a     pitch_class_size based on absolute interval size mod 12?     And if so, should there be an interval_class computed from     interval mod 12? And interval_size_class based on absolute     interval size mod 12? Note that \"interval\" ignores intervals     larger than one octave.)</li> <li>\"duration\" - weights for durations</li> <li>\"interval_size\" - weights for interval sizes, possibly weighted     by duration.</li> <li>\"interval_direction\" - proportion of upward intervals for each     interval size, possibly weighted by duration.</li> <li>\"pitch_class_transition\" - weights for pitch class transitions,     possibly weighted by duration (2-dimensional distribution).</li> <li>\"interval_transition\" - weights for interval transitions,     possibly weighted by duration (2-dimensional distribution).</li> <li>\"duration_transition\" - weights for duration transitions,     possibly weighted by duration (2-dimensional distribution).</li> <li>\"key_correlation\" - weights for key correlations, generally     correlation with 12 major key profiles followed by     correlations with 12 minor key profiles.</li> <li>\"symmetric_key_profile\" - weights for symmetric key profiles.     Key profiles themselves are distributions. Symmetric keys     use the same 12 weights for all keys (e.g., Krumhansl-Kessler),     simply rotated for each key.</li> <li>\"asymmetric_key_profile\" - weights for asymmetric key profiles,     where each key has its own set of 12 weights (e.g., Bellman-Budge).</li> <li>\"root_support_weights\" - root support weights (see     <code>amads.harmony.root_finding.parncutt</code>)</li> </ul> <p>This list is open-ended and is currently just informational. The value is not used for plotting or any other purpose.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(dimensions)","title":"<code>dimensions</code>","text":"(<code>list[int]</code>)           \u2013            <p>The dimensions of the distribution, e.g. [12] for a pitch class distribution or [25, 25] for an interval_transition (intervals are from -12 to +12 and include 0 for unison, intervals larger than one octave are ignored).</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(x_categories)","title":"<code>x_categories</code>","text":"(<code>list[int | float | str]</code>)           \u2013            <p>The categories for the x-axis.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(x_label)","title":"<code>x_label</code>","text":"(<code>str</code>)           \u2013            <p>The label for the x-axis.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(y_categories)","title":"<code>y_categories</code>","text":"(<code>list[int | float | str] | None</code>)           \u2013            <p>The categories for the y-axis, if any, otherwise None.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution(y_label)","title":"<code>y_label</code>","text":"(<code>str</code>)           \u2013            <p>The label for the y-axis.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution-functions","title":"Functions","text":""},{"location":"reference/distribution/#amads.core.distribution.Distribution.normalize","title":"normalize","text":"<pre><code>normalize()\n</code></pre> <p>Convert weights or counts to a probability distribution that sums to 1.</p> Source code in <code>amads/core/distribution.py</code> <pre><code>def normalize(self):\n    \"\"\"\n    Convert weights or counts to a probability distribution that sums to 1.\n    \"\"\"\n    self.data = normalize(self.data, \"Sum\").tolist()\n    return self\n</code></pre>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot","title":"plot","text":"<pre><code>plot(\n    color: str | None = None,\n    option: str | None = None,\n    show: bool = True,\n    fig: Figure | None = None,\n    ax: Axes | None = None,\n) -&gt; Figure\n</code></pre> <p>Virtual plot function for Distribution. Allows standalone plotting of a Distribution (when fig and ax are None), while providing enough extensibility to invoke this plot function or its overwritten variants for subplotting when fig and ax are provided as arguments.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>A ValueError is raised if:</p> <ul> <li><code>ax</code> (axes) but not <code>fig</code> (Figure) is provided</li> <li><code>dims</code> is not 1 or 2</li> </ul> </li> </ul> Notes <p>Behavior to this specific plot method:</p> <ul> <li>1-D: bar (default) or line when kind is \"line\"</li> <li>2-D: heatmap</li> </ul> Source code in <code>amads/core/distribution.py</code> <pre><code>def plot(\n    self,\n    color: Optional[str] = None,\n    option: Optional[str] = None,\n    show: bool = True,\n    fig: Optional[Figure] = None,\n    ax: Optional[Axes] = None,\n) -&gt; Figure:\n    \"\"\"\n    Virtual plot function for Distribution.\n    Allows standalone plotting of a Distribution (when fig and ax are None),\n    while providing enough extensibility to invoke this plot function or its\n    overwritten variants for subplotting when fig and ax are provided as\n    arguments.\n\n    Parameters\n    ----------\n    color : Optional[str]\n        Plot color string specification. In this particular plot function,\n        it is handled in 1-D distributions and ignored in 2-D distributions.\n        None for default option (Distribution.DEFAULT_BAR_COLOR).\n    option : Optional[str]\n        Plot style string specification. In this particular plot function,\n        only {\"bar\", \"line\"} are valid string arguments that will be handled\n        in a 1-D distribution, while any argument is ignored in 2-D\n        distributions. None for default option (\"bar\").\n    show : bool\n        Whether to call ``plt.show()`` at the end.\n    fig : Figure\n        Provide existing Figure to draw on; if omitted, a new\n        figure is created.\n    ax : Axes\n        Provide existing axes to draw on; if omitted, a new\n        figure and axes are created.\n\n    Raises\n    ------\n    ValueError\n        A ValueError is raised if:\n\n        - `ax` (axes) but not `fig` (Figure) is provided\n        - `dims` is not 1 or 2\n\n    Notes\n    -----\n    Behavior to this specific plot method:\n\n    - 1-D: bar (default) or line when kind is \"line\"\n    - 2-D: heatmap\n    \"\"\"\n    dims = len(self.dimensions)\n    if dims not in (1, 2):\n        raise ValueError(\n            \"Unsupported number of dimensions for Distribution class\"\n        )\n\n    # Figure/axes handling: either both `fig` and `ax` are provided, or\n    # neither; in the latter case, create a new figure/axes pair.\n    if fig is None:\n        if ax is not None:\n            raise ValueError(\"invalid figure/axis combination\")\n        fig, ax = plt.subplots()\n    else:\n        if ax is None:\n            raise ValueError(\"invalid figure/axis combination\")\n\n    if dims == 1:\n        if color is None:\n            color = Distribution.DEFAULT_BAR_COLOR\n        if option is None:\n            option = \"bar\"\n        x = range(len(self.x_categories))\n        # 1-D distributions: draw either a bar chart or a line chart.\n        if option == \"bar\":\n            ax.bar(x, self.data, color=color)\n        elif option == \"line\":\n            ax.plot(x, self.data, color=color, marker=\"o\")\n        else:\n            raise ValueError(f\"unknown kind for 1D plot: {option}\")\n\n        ax.set_xticks(list(x))\n        ax.set_xticklabels([str(label) for label in self.x_categories])\n        ax.set_xlabel(self.x_label)\n        ax.set_ylabel(self.y_label)\n        ax.set_title(self.name)\n\n    else:  # dims == 2\n        # 2-D distributions: render as a heatmap with a colorbar.\n        data = np.asarray(self.data)\n        cax = ax.imshow(\n            data, cmap=\"gray_r\", aspect=\"auto\", interpolation=\"nearest\"\n        )\n        fig.colorbar(cax, ax=ax, label=\"Proportion\")\n\n        ax.set_xlabel(self.x_label)\n        ax.set_ylabel(self.y_label)\n        ax.set_title(self.name)\n\n        ax.set_xticks(range(len(self.x_categories)))\n        ax.set_xticklabels([str(label) for label in self.x_categories])\n        if self.y_categories is not None:\n            ax.set_yticks(range(len(self.y_categories)))\n            ax.set_yticklabels([str(label) for label in self.y_categories])\n\n        ax.invert_yaxis()\n\n    fig.tight_layout()\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot(color)","title":"<code>color</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Plot color string specification. In this particular plot function, it is handled in 1-D distributions and ignored in 2-D distributions. None for default option (Distribution.DEFAULT_BAR_COLOR).</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot(option)","title":"<code>option</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Plot style string specification. In this particular plot function, only {\"bar\", \"line\"} are valid string arguments that will be handled in a 1-D distribution, while any argument is ignored in 2-D distributions. None for default option (\"bar\").</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to call <code>plt.show()</code> at the end.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot(fig)","title":"<code>fig</code>","text":"(<code>Figure</code>, default:                   <code>None</code> )           \u2013            <p>Provide existing Figure to draw on; if omitted, a new figure is created.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot(ax)","title":"<code>ax</code>","text":"(<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>Provide existing axes to draw on; if omitted, a new figure and axes are created.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Print information about the distribution</p> Source code in <code>amads/core/distribution.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Print information about the distribution\"\"\"\n    plural = \"\" if len(self.dimensions) == 1 else \"s\"\n    print(\n        f'Distribution: \"{self.name}\" has dimension{plural} '\n        f'{self.dimensions}, x_label: \"{self.x_label}\", '\n        f'y_label: \"{self.y_label}\", '\n        f'distribution_type: \"{self.distribution_type}\"'\n    )\n</code></pre>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_multiple","title":"plot_multiple  <code>classmethod</code>","text":"<pre><code>plot_multiple(\n    dists: list[Distribution],\n    show: bool = True,\n    options: str | list[str] | None = None,\n    colors: str | list[str] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Plot multiple distributions into a single Figure using vertically stacked subplots.</p> <p>Returns:</p> <ul> <li> <code>Figure or None</code>           \u2013            <p>A matplotlib Figure when at least one distribution is plotted; otherwise None when <code>dists</code> is empty.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> Notes <ul> <li>distributions are plotted in the same order they were presented in   dists list</li> <li>as long as a Distribution or inherited class has a valid plot function   implemented, the relevant plot will be added to the figure at the   specified axes.</li> <li><code>options</code> and <code>colors</code> apply to all distributions</li> <li>Although the original plot function is only limited to   <code>option</code> and <code>color</code> being used in the 1-D case, it is not to say   that a class inheriting Distribution won't leverage these arguments.</li> <li>You can pass either a list (per-series) or a single string. When a   single string is provided, it will be broadcast to all inputs.   For example, kinds=\"line\" makes all 1-D plots line charts.</li> </ul> Source code in <code>amads/core/distribution.py</code> <pre><code>@classmethod\ndef plot_multiple(\n    cls,\n    dists: List[\"Distribution\"],\n    show: bool = True,\n    options: Optional[Union[str, List[str]]] = None,\n    colors: Optional[Union[str, List[str]]] = None,\n) -&gt; Optional[Figure]:\n    \"\"\"\n    Plot multiple distributions into a single Figure using vertically\n    stacked subplots.\n\n    Returns\n    -------\n    Figure or None\n        A matplotlib Figure when at least one distribution is plotted;\n        otherwise None when `dists` is empty.\n\n    Parameters\n    ----------\n    dists : list[Distribution]\n        Distributions to plot. 2-D are rendered as heatmaps; 1-D below them.\n    show : bool\n        Whether to call ``plt.show()`` at the end.\n    options : str | list[str] | None\n        plot style per distribution (e.g. \"bar\" or \"line\"). If a single\n        string is given, it is broadcast to all distributions. If None,\n        defaults to \"bar\".\n    colors : str | list[str] | None\n        color option per distribution. If a single string is given, it is\n        broadcast to all 1-D distributions. If None, defaults to\n        the single color Distribution.DEFAULT_BAR_COLOR.\n\n    Notes\n    -----\n    - distributions are plotted in the same order they were presented in\n      dists list\n    - as long as a Distribution or inherited class has a valid plot function\n      implemented, the relevant plot will be added to the figure at the\n      specified axes.\n    - `options` and `colors` apply to all distributions\n    - Although the original plot function is only limited to\n      `option` and `color` being used in the 1-D case, it is not to say\n      that a class inheriting Distribution won't leverage these arguments.\n    - You can pass either a list (per-series) or a single string. When a\n      single string is provided, it will be broadcast to all inputs.\n      For example, kinds=\"line\" makes all 1-D plots line charts.\n    \"\"\"\n    if not dists:\n        return None\n\n    # when single string, broadcast to all distributions\n    options = options or [\"bar\"] * len(dists)\n    colors = colors or [Distribution.DEFAULT_BAR_COLOR] * len(dists)\n    if isinstance(options, str):\n        options = [options] * len(dists)\n    if isinstance(colors, str):\n        colors = [colors] * len(dists)\n    if len(options) != len(dists) or len(colors) != len(dists):\n        raise ValueError(\n            \"kinds/colors must match number of distributions in list case\"\n        )\n\n    # Create a vertical stack of subplots sized to total count\n    fig, axes = plt.subplots(len(dists), 1, squeeze=False)\n    axes = axes.ravel()\n    # use an axes iterator here\n    ax_iter = iter(axes)\n    for d, k, c in zip(dists, options, colors):\n        ax = next(ax_iter)\n        d.plot(color=c, option=k, show=False, fig=fig, ax=ax)\n\n    fig.tight_layout()\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_multiple(dists)","title":"<code>dists</code>","text":"(<code>list[Distribution]</code>)           \u2013            <p>Distributions to plot. 2-D are rendered as heatmaps; 1-D below them.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_multiple(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to call <code>plt.show()</code> at the end.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_multiple(options)","title":"<code>options</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>plot style per distribution (e.g. \"bar\" or \"line\"). If a single string is given, it is broadcast to all distributions. If None, defaults to \"bar\".</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_multiple(colors)","title":"<code>colors</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>color option per distribution. If a single string is given, it is broadcast to all 1-D distributions. If None, defaults to the single color Distribution.DEFAULT_BAR_COLOR.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_grouped_1d","title":"plot_grouped_1d  <code>classmethod</code>","text":"<pre><code>plot_grouped_1d(\n    dists: list[Distribution],\n    show: bool = True,\n    options: str | list[str] | None = None,\n    colors: str | list[str] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Overlay multiple 1-D distributions on a single axes.</p> <p>This function draws all input 1-D distributions in one matplotlib Axes so that each category (x bin) shows a \"group\" of values\u2014one per distribution. You can mix plotting styles using the <code>kinds</code> argument (for example, some as bars and others as lines with markers. Colors are controlled via the <code>colors</code> argument.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure or None</code>           \u2013            <p>A matplotlib Figure if any distributions are plotted; None when <code>dists</code> is empty.</p> </li> </ul> Constraints <ul> <li>Only 1-D distributions are accepted. All inputs must have the same   length (number of categories) so they can be grouped per category.</li> <li>The x/y labels and category names are taken from the first   distribution in <code>dists</code>. Hence, this function does not support   overlaying 1-D distributions with different categories and labels.</li> </ul> How this differs from plot_multiple <ul> <li>plot_grouped_1d overlays all 1-D distributions on a single axes   to allow:<ol> <li>per-category (bin-by-bin) comparison intuitive and compact    for grouped bar graphs</li> <li>intuitive and compact gradient comparison for overlaid line    graphs.</li> </ol> </li> </ul> <p>Since all distributions are plotted in a single plot, we can   compare all plots within a single legend. - plot_multiple creates a vertical stack of subplots, one per   distribution, while leveraging the plot attribute of each   Distribution (and also supports 2-D heatmaps).</p> Source code in <code>amads/core/distribution.py</code> <pre><code>@classmethod\ndef plot_grouped_1d(\n    cls,\n    dists: List[\"Distribution\"],\n    show: bool = True,\n    options: Optional[Union[str, List[str]]] = None,\n    colors: Optional[Union[str, List[str]]] = None,\n) -&gt; Optional[Figure]:\n    \"\"\"Overlay multiple 1-D distributions on a single axes.\n\n    This function draws all input 1-D distributions in one matplotlib\n    Axes so that each category (x bin) shows a \"group\" of values\u2014one\n    per distribution. You can mix plotting styles using the `kinds`\n    argument (for example, some as bars and others as lines with\n    markers. Colors are controlled via the `colors` argument.\n\n    Parameters\n    ----------\n    dists : list[Distribution]\n        1-D distributions to compare in a single plot.\n    show : bool\n        Whether to call ``plt.show()`` at the end.\n    options : str | list[str] | None\n        Per-distribution plot style. Allowed values: \"bar\" or \"line\".\n        You can provide a single string to apply to all series (broadcast),\n        or a list with length `len(dists)`. If None, all series default to\n        \"bar\".\n    colors : str | list[str] | None\n        Per-distribution color list. You can provide a single string to\n        apply to all series (broadcast), or a list with length `len(dists)`.\n        If None, a distinct default color palette is applied (rcParams cycle\n        or the tab10 palette).\n\n    Returns\n    -------\n    Figure or None\n        A matplotlib Figure if any distributions are plotted; None when\n        `dists` is empty.\n\n    Constraints\n    -----------\n    - Only 1-D distributions are accepted. All inputs must have the same\n      length (number of categories) so they can be grouped per category.\n    - The x/y labels and category names are taken from the first\n      distribution in `dists`. Hence, this function does not support\n      overlaying 1-D distributions with different categories and labels.\n\n    How this differs from plot_multiple\n    -----------------------------------\n    - plot_grouped_1d overlays all 1-D distributions on a single axes\n      to allow:\n        1. per-category (bin-by-bin) comparison intuitive and compact\n           for grouped bar graphs\n        2. intuitive and compact gradient comparison for overlaid line\n           graphs.\n\n      Since all distributions are plotted in a single plot, we can\n      compare all plots within a single legend.\n    - plot_multiple creates a vertical stack of subplots, one per\n      distribution, while leveraging the plot attribute of each\n      Distribution (and also supports 2-D heatmaps).\n    \"\"\"\n    # Validate inputs\n    if not dists:\n        return None\n    if any(len(d.dimensions) != 1 for d in dists):\n        raise ValueError(\n            \"All distributions must be 1-D for grouped plotting\"\n        )\n    # number of categories for each plot in the 1d distribution\n    dimension = dists[0].dimensions[0]\n    if any(d.dimensions[0] != dimension for d in dists):\n        raise ValueError(\"All 1-D distributions must have the same length\")\n    # labels and categories will need to be the same...\n    # or else some of the data visualization for axes will be misleading\n    # since this function does not support plotting multiple axes labels\n    # and categories on the same plot\n    if any(\n        d.x_label != dists[0].x_label or d.y_label != dists[0].y_label\n        for d in dists\n    ):\n        raise ValueError(\"All 1-D distributions must have same axes labels\")\n    if any(\n        d.x_categories != dists[0].x_categories\n        or d.y_categories != dists[0].y_categories\n        for d in dists\n    ):\n        raise ValueError(\n            \"All 1-D distributions must have same axes categories\"\n        )\n\n    # when single string, broadcast to all\n    if isinstance(options, str):\n        options = [options] * len(dists)\n    if isinstance(colors, str):\n        colors = [colors] * len(dists)\n    if options is None:\n        options = [\"bar\"] * len(dists)\n    if colors is None:\n        # get the default ListedColormap; get_cmap does not always\n        # return an object with .colors, so we have to ignore the type:\n        base_colors = plt.get_cmap(\"tab10\").colors  # type: ignore\n        colors = [\n            base_colors[i % len(base_colors)] for i in range(len(dists))\n        ]\n    if len(options) != len(dists) or len(colors) != len(dists):\n        raise ValueError(\n            \"kinds and colors must match number of distributions\"\n        )\n\n    bar_graph_info = None\n    line_graph_info = None\n    # partition bar graphs and line graphs to be plotted separately\n    # (so that line graphs don't each take up a bin themselves)\n    if isinstance(options, list):\n        bar_graph_info = [\n            (dist, color)\n            for dist, kind, color in zip(dists, options, colors)\n            if kind == \"bar\"\n        ]\n        line_graph_info = [\n            (dist, color)\n            for dist, kind, color in zip(dists, options, colors)\n            if kind in (\"line\", \"plot\")\n        ]\n\n    fig, ax = plt.subplots()\n\n    # Grouped bar arithmetic (unit bar width, grouped per category)\n    # must have at least 1 bin for the line plot to be valid\n    n = max(len(bar_graph_info), 1)\n    # bar_width does not matter here, since everything in the grouped bar\n    # graph is scaled according to this variable\n    bar_width = 1\n    x_coords = np.arange(dimension) * bar_width * n\n    bottom_half, upper_half = n // 2, n - n // 2\n    width_idxes = range(-bottom_half, upper_half + 1)\n    is_even_offset = ((n + 1) % 2) * bar_width / 2\n\n    # setting plot axes\n    ax.set_xticks(x_coords)\n    ax.set_xticklabels([str(d) for d in dists[0].x_categories])\n    ax.set_xlabel(dists[0].x_label)\n    ax.set_ylabel(dists[0].y_label)\n    ax.set_title(\"Grouped Histogram Plot for 1-D Distributions\")\n\n    for width_idx, (dist, color) in zip(width_idxes, bar_graph_info):\n        x_axis = x_coords + width_idx * bar_width + is_even_offset\n        ax.bar(\n            x_axis, dist.data, width=bar_width, label=dist.name, color=color\n        )\n\n    for dist, color in line_graph_info:\n        ax.plot(\n            x_coords, dist.data, color=color, marker=\"o\", label=dist.name\n        )\n\n    ax.legend()\n    fig.tight_layout()\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_grouped_1d(dists)","title":"<code>dists</code>","text":"(<code>list[Distribution]</code>)           \u2013            <p>1-D distributions to compare in a single plot.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_grouped_1d(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to call <code>plt.show()</code> at the end.</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_grouped_1d(options)","title":"<code>options</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Per-distribution plot style. Allowed values: \"bar\" or \"line\". You can provide a single string to apply to all series (broadcast), or a list with length <code>len(dists)</code>. If None, all series default to \"bar\".</p>"},{"location":"reference/distribution/#amads.core.distribution.Distribution.plot_grouped_1d(colors)","title":"<code>colors</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Per-distribution color list. You can provide a single string to apply to all series (broadcast), or a list with length <code>len(dists)</code>. If None, a distinct default color palette is applied (rcParams cycle or the tab10 palette).</p>"},{"location":"reference/distribution/#histogram-module","title":"Histogram Module","text":""},{"location":"reference/distribution/#amads.core.histogram","title":"histogram","text":"<p>Compute histograms and distributions.</p> <p>This module provides Histogram1D and Histogram2D classes for computing one-dimensional and two-dimensional histograms, respectively. Histograms can be normalized to form probability distributions.</p> <p>The <code>bins</code> attribute can be directly assigned to the <code>data</code> attribute of the <code>Distribution</code> class in <code>core.distribution</code>.</p> <p>Histogram bins can be specified either by their centers or their boundaries. When centers are provided:</p> <ul> <li>the number of centers gives the number of bins</li> <li>if ignore_extrema is False, the first and last bins are open-ended,     counting all values below the first center and above the last center.     boundaries can be computed from centers using either linear or logarithmic     interpolation. If provided, boundaries can be of length len(centers) + 1,     in which case the first and last values are ignored (since the bins are     open-ended); otherwise, boundaries have length len(centers) - 1.</li> <li>if ignore_extrema is True, the first and last bins are closed, and values     outside the bin boundaries are ignored. In this case, boundaries must be     provided and have length len(centers) + 1.</li> </ul> <p>When centers are not provided, boundaries must be provided:</p> <ul> <li>the number of bins is len(boundaries) - 1</li> <li>bin centers can be computed as arithmetic or geometric means of boundaries.</li> <li>if ignore_extrema is False, the upper and lower boundaries are ignored,     making the first and last bins open-ended.</li> <li>if ignore_extrema is True, the first and last bins are closed, and values     outside the bin boundaries are ignored.</li> </ul> <p>Classes:</p> <ul> <li> <code>Histogram1D</code>           \u2013            <p>Class for computing one-dimensional histograms.</p> </li> <li> <code>Histogram2D</code>           \u2013            <p>Class for computing two-dimensional histograms.</p> </li> </ul> <p>Functions:</p> <ul> <li> <code>boundaries_to_centers</code>             \u2013              <p>Convert bin boundaries to bin centers.</p> </li> <li> <code>centers_to_boundaries</code>             \u2013              <p>Convert bin centers to bin boundaries.</p> </li> </ul>"},{"location":"reference/distribution/#amads.core.histogram-classes","title":"Classes","text":""},{"location":"reference/distribution/#amads.core.histogram.Histogram1D","title":"Histogram1D","text":"<pre><code>Histogram1D(\n    bin_centers: list[float] | None = None,\n    bin_boundaries: list[float] | None = None,\n    interpolation: str = \"linear\",\n    ignore_extrema: bool = False,\n    initial_value: float = 0.0,\n)\n</code></pre> <p>Class for computing one-dimensional histograms.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>bin_boundaries</code>               (<code>list of float</code>)           \u2013            <p>Boundaries of the histogram bins. If ignore_extrema is True, bin_boundaries has length len(bin_centers) + 1 and surround all bins. If ignore_extrema is False, bin_boundaries has length len(bin_centers) - 1 and the first and last bins are open-ended, so bin_boundaries are boundaries between bins only.</p> </li> <li> <code>bin_centers</code>               (<code>list of float</code>)           \u2013            <p>Centers of the histogram bins (used for plot labels)</p> </li> <li> <code>bins</code>               (<code>list of float</code>)           \u2013            <p>(weighted) counts or probability of data points in each bin.</p> </li> <li> <code>ignore_extrema</code>               (<code>bool</code>)           \u2013            <p>If True, values outside the bin boundaries are ignored.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>find_bin</code>             \u2013              <p>find the bin index for a given value such that i indexes</p> </li> <li> <code>add_point</code>             \u2013              <p>Record one count or weight update to the histogram</p> </li> <li> <code>normalize</code>             \u2013              <p>Convert the histogram into a probability distribution.</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def __init__(\n    self,\n    bin_centers: Optional[list[float]] = None,\n    bin_boundaries: Optional[list[float]] = None,\n    interpolation: str = \"linear\",\n    ignore_extrema: bool = False,\n    initial_value: float = 0.0,\n):\n    if not bin_centers and not bin_boundaries:\n        raise ValueError(\n            \"Must provide either bin_centers or \" \"bin_boundaries.\"\n        )\n    if not bin_boundaries:\n        if ignore_extrema:\n            raise ValueError(\n                \"When ignore_extrema is True, \"\n                \"bin_boundaries must be provided.\"\n            )\n        centers = cast(list[float], bin_centers)\n        bin_boundaries = centers_to_boundaries(centers, interpolation)\n    elif bin_centers:  # we have both bin_boundaries and bin_centers\n        blen = len(bin_boundaries)\n        clen = len(bin_centers)\n        if ignore_extrema:\n            if blen != clen + 1:\n                raise ValueError(\n                    \"When ignore_extrema is False, \"\n                    \"len(bin_boundaries) must be len(bin_centers) + 1\"\n                )\n        elif blen == clen + 1:  # allowed, but we trim the boundaries:\n            bin_boundaries = bin_boundaries[1:-1]\n        elif blen != clen - 1:\n            raise ValueError(\n                \"When ignore_extrema is False, \"\n                \"len(bin_boundaries) must be len(bin_centers) + 1 \"\n                \"or len(bin_centers) - 1\"\n            )\n    if not bin_centers:\n        bin_centers = boundaries_to_centers(bin_boundaries, interpolation)\n        if ignore_extrema:\n            bin_boundaries = bin_boundaries[1:-1]\n\n    # now, we need len(bin_boundaries) to respect ignore_extrema\n    blen = len(bin_boundaries)\n    clen = len(bin_centers)\n    assert (not ignore_extrema and (blen == clen - 1)) or (\n        (ignore_extrema) and (blen == clen + 1)\n    )\n\n    self.ignore_extrema = ignore_extrema\n    self.bins = [initial_value] * len(bin_centers)\n    self.bin_centers = bin_centers\n    self.bin_boundaries = bin_boundaries\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D(bin_centers)","title":"<code>bin_centers</code>","text":"(<code>list of float</code>, default:                   <code>None</code> )           \u2013            <p>Centers of the histogram bins.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D(bin_boundaries)","title":"<code>bin_boundaries</code>","text":"(<code>list of float</code>, default:                   <code>None</code> )           \u2013            <p>boundaries of the histogram bins.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D(interpolation)","title":"<code>interpolation</code>","text":"(<code>str</code>, default:                   <code>'linear'</code> )           \u2013            <p>Interpolation method for missing bin_centers or bin_boundaries. \"linear\" to use the average of neighboring values, \"log\" for geometric mean.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D(ignore_extrema)","title":"<code>ignore_extrema</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, values below the lowest bin edge and above the highest bin edge are ignored. If False, they are counted in the first and last bins, respectively. Default is False.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D(initial_value)","title":"<code>initial_value</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The initial bin values are all set to this value (default is 0). This avoids a divide-by-a-zero-total problem when normalizing bins that are all zero. This can also avoid zero-probability bins by giving all bins a non-zero \"prior.\" The divide-by-zero problem is avoided in any case: When normalizing and all bins are zero, the bin values are left at zero.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D-functions","title":"Functions","text":""},{"location":"reference/distribution/#amads.core.histogram.Histogram1D.find_bin","title":"find_bin","text":"<pre><code>find_bin(value: float)\n</code></pre> <p>find the bin index for a given value such that i indexes the next boundary above value. If the value is greater or equal to the highest boundary, len(bin_boundaries) is returned.</p> Source code in <code>amads/core/histogram.py</code> <pre><code>def find_bin(self, value: float):\n    \"\"\"\n    find the bin index for a given value such that i indexes\n    the next boundary above value. If the value is greater or\n    equal to the highest boundary, len(bin_boundaries) is returned.\n    \"\"\"\n    i = 0  # for the strange case of len(bin_boundaries) == 0\n    for i in range(len(self.bin_boundaries)):\n        if self.bin_boundaries[i] &gt; value:\n            return i\n    return len(self.bin_boundaries)\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D.add_point","title":"add_point","text":"<pre><code>add_point(data: float, weight: float = 1.0)\n</code></pre> <p>Record one count or weight update to the histogram</p> <p>Parameters:</p> <ul> <li> <code>data</code> \u00b6              (<code>float</code>)           \u2013            <p>value to be recorded in the histogram</p> </li> <li> <code>weight</code> \u00b6              (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>weight to add to the appropriate bin (default is 1.0)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>bin number where the data point was recorded or None if data was out of bounds</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def add_point(self, data: float, weight: float = 1.0):\n    \"\"\"Record one count or weight update to the histogram\n    Parameters\n    ----------\n    data : float\n        value to be recorded in the histogram\n    weight : float\n        weight to add to the appropriate bin (default is 1.0)\n\n    Returns\n    -------\n    Optional[int]\n        bin number where the data point was recorded or\n        None if data was out of bounds\n    \"\"\"\n    # prevent a Histogram2D from using this method:\n    if isinstance(self.bins[0], list):\n        raise ValueError(\"Histogram2D must use add_point_2d method\")\n    i = self.find_bin(data)\n    if self.ignore_extrema:\n        if i == 0 or i == len(self.bins):\n            return None  # out of bounds\n        else:\n            i -= 1  # bin[0] corresponds to bounds[1:2]\n    self.bins[i] += weight\n    return i\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram1D.normalize","title":"normalize","text":"<pre><code>normalize()\n</code></pre> <p>Convert the histogram into a probability distribution. If all bins are zero, the resulting bins remain at zero.</p> Source code in <code>amads/core/histogram.py</code> <pre><code>def normalize(self):\n    \"\"\"\n    Convert the histogram into a probability distribution.\n    If all bins are zero, the resulting bins remain at zero.\n    \"\"\"\n    total = sum(self.bins)\n    if total &gt; 0:\n        self.bins = [b / total for b in self.bins]\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D","title":"Histogram2D","text":"<pre><code>Histogram2D(\n    bin_centers: list[float] | None = None,\n    bin_boundaries: list[float] | None = None,\n    interpolation: str = \"linear\",\n    ignore_extrema: bool = False,\n    initial_value: float = 0.0,\n)\n</code></pre> <p>               Bases: <code>Histogram1D</code></p> <p>Class for computing two-dimensional histograms.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>bin_boundaries</code>               (<code>list of float</code>)           \u2013            <p>Boundaries of the histogram bins.</p> </li> <li> <code>bin_centers</code>               (<code>list of float</code>)           \u2013            <p>Centers of the histogram bins (used for plot labels)</p> </li> <li> <code>bins</code>               (<code>list of float</code>)           \u2013            <p>(weighted) counts or probability of data points in each bin.</p> </li> <li> <code>ignore_extrema</code>               (<code>bool</code>)           \u2013            <p>If True, values outside the bin boundaries are ignored.</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>add_point_2d</code>             \u2013              <p>Record one count or weight update to the histogram</p> </li> <li> <code>find_bin</code>             \u2013              <p>find the bin index for a given value such that i indexes</p> </li> <li> <code>add_point</code>             \u2013              <p>Record one count or weight update to the histogram</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def __init__(\n    self,\n    bin_centers: Optional[list[float]] = None,\n    bin_boundaries: Optional[list[float]] = None,\n    interpolation: str = \"linear\",\n    ignore_extrema: bool = False,\n    initial_value: float = 0.0,\n):\n    # Histogram1D takes care of the messy establishment of\n    # centers and boundaries, which are the same for 2D:\n    super().__init__(\n        bin_centers, bin_boundaries, interpolation, ignore_extrema\n    )\n    # now we just have to fix bins to be 2D:\n    self.bins = [\n        [initial_value] * len(self.bins) for _ in range(len(self.bins))\n    ]\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D(bin_centers)","title":"<code>bin_centers</code>","text":"(<code>list of float</code>, default:                   <code>None</code> )           \u2013            <p>Centers of the histogram bins.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D(bin_boundaries)","title":"<code>bin_boundaries</code>","text":"(<code>list of float</code>, default:                   <code>None</code> )           \u2013            <p>boundaries of the histogram bins.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D(interpolation)","title":"<code>interpolation</code>","text":"(<code>str</code>, default:                   <code>'linear'</code> )           \u2013            <p>Interpolation method for missing bin_centers or bin_boundaries. \"linear\" to use the average of neighboring values, \"log\" for geometric mean.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D(ignore_extrema)","title":"<code>ignore_extrema</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, values below the lowest bin edge and above the highest bin edge are ignored. If False, they are counted in the first and last bins, respectively. Default is False.</p>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D-functions","title":"Functions","text":""},{"location":"reference/distribution/#amads.core.histogram.Histogram2D.add_point_2d","title":"add_point_2d","text":"<pre><code>add_point_2d(\n    data1: float | None,\n    data2: float,\n    weight: float = 1.0,\n    prev: int | None = None,\n)\n</code></pre> <p>Record one count or weight update to the histogram</p> <p>A typical use is to record consecutive elements of a sequence as data1 along with the next element as data2. In this case, data2 will become data1 in the next call, so the returned bin index for data2 can be provided as prev in the next call to avoid re-compmuting the bin index for data1.</p> <p>To further support this use case, if data1 is None, the histogram is not changed, but the bin index for data2 is still computed and returned. Thus, you can pass None for data1 and the first element as data2 to get things started.</p> <p>If the histogram is not updated (because data1 is None or because data1 or data2 are out of bounds and ignore_extrema is True), None is returned, in which case data1 should be passed as None in the next call as if starting a new sequence.</p> <p>Parameters:</p> <ul> <li> <code>data1</code> \u00b6              (<code>float</code>)           \u2013            <p>value for dimension 1 (or None to skip)</p> </li> <li> <code>data2</code> \u00b6              (<code>float</code>)           \u2013            <p>value for dimension 2</p> </li> <li> <code>weight</code> \u00b6              (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>weight to add to the appropriate bin (default is 1.0)</p> </li> <li> <code>prev</code> \u00b6              (<code>Optional(int)</code>, default:                   <code>None</code> )           \u2013            <p>optional previous bin index for data1; if provided, this value is used instead of recomputing the bin index for data1.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>bin number for data2 if data were used to add to the histogram, else None (which means the bin must be calculated).</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def add_point_2d(\n    self,\n    data1: Optional[float],\n    data2: float,\n    weight: float = 1.0,\n    prev: Optional[int] = None,\n):\n    \"\"\"Record one count or weight update to the histogram\n\n    A typical use is to record consecutive elements of a sequence\n    as data1 along with the next element as data2. In this case, data2\n    will become data1 in the next call, so the returned bin index for\n    data2 can be provided as prev in the next call to avoid re-compmuting\n    the bin index for data1.\n\n    To further support this use case, if data1 is None, the histogram\n    is not changed, but the bin index for data2 is still computed and\n    returned. Thus, you can pass None for data1 and the first element\n    as data2 to get things started.\n\n    If the histogram is not updated (because data1 is None or because\n    data1 or data2 are out of bounds and ignore_extrema is True),\n    None is returned, in which case data1 should be passed as None in\n    the next call as if starting a new sequence.\n\n    Parameters\n    ----------\n    data1 : float\n        value for dimension 1 (or None to skip)\n    data2 : float\n        value for dimension 2\n    weight : float\n        weight to add to the appropriate bin (default is 1.0)\n    prev : Optional(int)\n        optional previous bin index for data1; if provided, this\n        value is used instead of recomputing the bin index for data1.\n\n    Returns\n    -------\n    int\n        bin number for data2 if data were used to add to\n        the histogram, else None (which means the bin must\n        be calculated).\n    \"\"\"\n    i = None  # index for data1\n    if data1 is not None:\n        if prev:\n            i = prev\n        else:\n            i = self.find_bin(data1)\n            if i == 0 or i == len(self.bins):\n                if self.ignore_extrema:\n                    return None  # out of bounds\n\n    j = self.find_bin(data2)  # index for data2\n    if j == 0 or j == len(self.bins) + 1:\n        if self.ignore_extrema:\n            return None\n\n    if i is not None:\n        self.bins[i][j] += weight\n    return j\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D.find_bin","title":"find_bin","text":"<pre><code>find_bin(value: float)\n</code></pre> <p>find the bin index for a given value such that i indexes the next boundary above value. If the value is greater or equal to the highest boundary, len(bin_boundaries) is returned.</p> Source code in <code>amads/core/histogram.py</code> <pre><code>def find_bin(self, value: float):\n    \"\"\"\n    find the bin index for a given value such that i indexes\n    the next boundary above value. If the value is greater or\n    equal to the highest boundary, len(bin_boundaries) is returned.\n    \"\"\"\n    i = 0  # for the strange case of len(bin_boundaries) == 0\n    for i in range(len(self.bin_boundaries)):\n        if self.bin_boundaries[i] &gt; value:\n            return i\n    return len(self.bin_boundaries)\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.Histogram2D.add_point","title":"add_point","text":"<pre><code>add_point(data: float, weight: float = 1.0)\n</code></pre> <p>Record one count or weight update to the histogram</p> <p>Parameters:</p> <ul> <li> <code>data</code> \u00b6              (<code>float</code>)           \u2013            <p>value to be recorded in the histogram</p> </li> <li> <code>weight</code> \u00b6              (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>weight to add to the appropriate bin (default is 1.0)</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int | None</code>           \u2013            <p>bin number where the data point was recorded or None if data was out of bounds</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def add_point(self, data: float, weight: float = 1.0):\n    \"\"\"Record one count or weight update to the histogram\n    Parameters\n    ----------\n    data : float\n        value to be recorded in the histogram\n    weight : float\n        weight to add to the appropriate bin (default is 1.0)\n\n    Returns\n    -------\n    Optional[int]\n        bin number where the data point was recorded or\n        None if data was out of bounds\n    \"\"\"\n    # prevent a Histogram2D from using this method:\n    if isinstance(self.bins[0], list):\n        raise ValueError(\"Histogram2D must use add_point_2d method\")\n    i = self.find_bin(data)\n    if self.ignore_extrema:\n        if i == 0 or i == len(self.bins):\n            return None  # out of bounds\n        else:\n            i -= 1  # bin[0] corresponds to bounds[1:2]\n    self.bins[i] += weight\n    return i\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram-functions","title":"Functions","text":""},{"location":"reference/distribution/#amads.core.histogram.boundaries_to_centers","title":"boundaries_to_centers","text":"<pre><code>boundaries_to_centers(\n    boundaries: list[float], interpolation: str = \"linear\"\n) -&gt; list[float]\n</code></pre> <p>Convert bin boundaries to bin centers.</p> <p>The lower and upper boundaries are only used to compute the centers of the bins in between, so the returned list has length len(boundaries) - 1, so the lower bin will count all values below boundaries[1], and the upper bin will count all values above boundaries[-2].</p> <p>If interpolation is linear, the center between two boundaries x1 and x2 is (x1 + x2) / 2. If interpolation is 'log', the center is sqrt(x1 * x2).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>List of bin centers.</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def boundaries_to_centers(\n    boundaries: list[float], interpolation: str = \"linear\"\n) -&gt; list[float]:\n    \"\"\"\n    Convert bin boundaries to bin centers.\n\n    The lower and upper boundaries are only used to compute the\n    centers of the bins in between, so the returned list has length\n    len(boundaries) - 1, so the lower bin will count all values\n    below boundaries[1], and the upper bin will count all values\n    above boundaries[-2].\n\n    If interpolation is linear, the center between two boundaries x1\n    and x2 is (x1 + x2) / 2. If interpolation is 'log', the center is\n    sqrt(x1 * x2).\n\n    Parameters\n    ----------\n    boundaries: list[float]\n        List of bin boundaries.\n    interpolation: str\n        \"linear\" for arithmetic mean, \"log\" for geometric mean.\n\n    Returns\n    -------\n    list[float]\n        List of bin centers.\n    \"\"\"\n    if interpolation == \"linear\":\n        centers = [\n            (boundaries[i] + boundaries[i + 1]) / 2\n            for i in range(len(boundaries) - 1)\n        ]\n    elif interpolation == \"log\":\n        centers = [\n            math.sqrt(boundaries[i] * boundaries[i + 1])\n            for i in range(len(boundaries) - 1)\n        ]\n    else:\n        raise ValueError(\"interpolation must be 'linear' or 'log'\")\n    return centers\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.boundaries_to_centers(boundaries)","title":"<code>boundaries</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of bin boundaries.</p>"},{"location":"reference/distribution/#amads.core.histogram.boundaries_to_centers(interpolation)","title":"<code>interpolation</code>","text":"(<code>str</code>, default:                   <code>'linear'</code> )           \u2013            <p>\"linear\" for arithmetic mean, \"log\" for geometric mean.</p>"},{"location":"reference/distribution/#amads.core.histogram.centers_to_boundaries","title":"centers_to_boundaries","text":"<pre><code>centers_to_boundaries(\n    centers: list[float], interpolation: str = \"linear\"\n) -&gt; list[float]\n</code></pre> <p>Convert bin centers to bin boundaries.</p> <p>The returned list has length len(centers) - 1, with the first and last bins being open-ended.</p> <p>To get a closed interval around upper or lower centers, simply add an additional center below or above and ignore the resulting values. In the case of a distribution, to truly throw out the outliers, you will need to extract the desired sub-vector or sub-matrix and re-normalize.</p> <p>If interpolation is \"linear\", the boundary between two centers x1 and x2 is (x1 + x2) / 2. If interpolation is \"log\", the boundary is sqrt(x1 * x2).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>List of bin boundaries.</p> </li> </ul> Source code in <code>amads/core/histogram.py</code> <pre><code>def centers_to_boundaries(\n    centers: list[float], interpolation: str = \"linear\"\n) -&gt; list[float]:\n    \"\"\"\n    Convert bin centers to bin boundaries.\n\n    The returned list has length len(centers) - 1, with the first and\n    last bins being open-ended.\n\n    To get a closed interval around upper or lower centers, simply add an\n    additional center below or above and ignore the resulting values. In\n    the case of a distribution, to truly throw out the outliers, you will\n    need to extract the desired sub-vector or sub-matrix and re-normalize.\n\n    If interpolation is \"linear\", the boundary between two centers\n    x1 and x2 is (x1 + x2) / 2. If interpolation is \"log\", the boundary\n    is sqrt(x1 * x2).\n\n    Parameters\n    ----------\n    centers : list[float]\n        List of bin centers.\n    interpolation : str\n        \"linear\" for arithmetic mean, \"log\" for geometric mean.\n\n    Returns\n    -------\n    list[float]\n        List of bin boundaries.\n    \"\"\"\n    # strangely, this is the same function as boundaries_to_centers:\n    return boundaries_to_centers(centers, interpolation)\n</code></pre>"},{"location":"reference/distribution/#amads.core.histogram.centers_to_boundaries(centers)","title":"<code>centers</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of bin centers.</p>"},{"location":"reference/distribution/#amads.core.histogram.centers_to_boundaries(interpolation)","title":"<code>interpolation</code>","text":"(<code>str</code>, default:                   <code>'linear'</code> )           \u2013            <p>\"linear\" for arithmetic mean, \"log\" for geometric mean.</p>"},{"location":"reference/io/","title":"Input and Output","text":""},{"location":"reference/io/#input","title":"Input","text":"<p>The main function for input is readscore.read_score described below. It calls upon various file readers to read Standard MIDI Files and Music XML files. Much of the work is done by various subsystems including Music21, Partitura, and pretty_midi. Use <code>read_score</code> to get the recommended implementation automatically.</p>"},{"location":"reference/io/#amads.io.readscore","title":"readscore","text":"<p>Functions for music data input.</p> <p>Functions:</p> <ul> <li> <code>set_preferred_midi_reader</code>             \u2013              <p>Set a (new) preferred MIDI reader.</p> </li> <li> <code>set_preferred_xml_reader</code>             \u2013              <p>Set a (new) preferred XML reader.</p> </li> <li> <code>set_reader_warning_level</code>             \u2013              <p>Set the warning level for <code>readscore</code> functions.</p> </li> <li> <code>import_xml</code>             \u2013              <p>Use Partitura or music21 to import a MusicXML file.</p> </li> <li> <code>import_midi</code>             \u2013              <p>Use music21 or pretty_midi to import a Standard MIDI file.</p> </li> <li> <code>read_score</code>             \u2013              <p>Read a file with the given format, <code>'xml'</code>, <code>'midi'</code>, <code>'kern'</code>, <code>'mei'</code>.</p> </li> <li> <code>last_used_reader</code>             \u2013              <p>Return the name of the last used reader function.</p> </li> </ul>"},{"location":"reference/io/#amads.io.readscore-functions","title":"Functions","text":""},{"location":"reference/io/#amads.io.readscore.set_preferred_midi_reader","title":"set_preferred_midi_reader","text":"<pre><code>set_preferred_midi_reader(reader: str) -&gt; str\n</code></pre> <p>Set a (new) preferred MIDI reader.</p> <p>Returns the previous reader preference. The current preference is stored in <code>amads.io.reader.preferred_midi_reader</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The previous name of the preferred MIDI reader.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid reader is provided.</p> </li> </ul> Source code in <code>amads/io/readscore.py</code> <pre><code>def set_preferred_midi_reader(reader: str) -&gt; str:\n    \"\"\"\n    Set a (new) preferred MIDI reader.\n\n    Returns the previous reader preference. The current preference is stored\n    in `amads.io.reader.preferred_midi_reader`.\n\n    Parameters\n    ----------\n    reader : str\n        The name of the preferred MIDI reader. Can be \"music21\" or \"pretty_midi\".\n\n    Returns\n    -------\n    str\n        The previous name of the preferred MIDI reader.\n\n    Raises\n    ------\n    ValueError\n        If an invalid reader is provided.\n    \"\"\"\n    global preferred_midi_reader\n    allowed = [\"music21\", \"pretty_midi\"]\n    if reader not in allowed:\n        raise ValueError(f\"Invalid MIDI reader. Must be one of {allowed}\")\n\n    previous = preferred_midi_reader\n    preferred_midi_reader = reader\n    return previous\n</code></pre>"},{"location":"reference/io/#amads.io.readscore.set_preferred_midi_reader(reader)","title":"<code>reader</code>","text":"(<code>str</code>)           \u2013            <p>The name of the preferred MIDI reader. Can be \"music21\" or \"pretty_midi\".</p>"},{"location":"reference/io/#amads.io.readscore.set_preferred_xml_reader","title":"set_preferred_xml_reader","text":"<pre><code>set_preferred_xml_reader(reader: str) -&gt; str\n</code></pre> <p>Set a (new) preferred XML reader.</p> <p>Returns the previous reader preference. The current preference is stored in <code>amads.io.reader.preferred_xml_reader</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The previous name of the preferred XML reader.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid reader is provided.</p> </li> </ul> Source code in <code>amads/io/readscore.py</code> <pre><code>def set_preferred_xml_reader(reader: str) -&gt; str:\n    \"\"\"\n    Set a (new) preferred XML reader.\n\n    Returns the previous reader preference. The current preference is stored\n    in `amads.io.reader.preferred_xml_reader`.\n\n    Parameters\n    ----------\n    reader : str\n        The name of the preferred XML reader. Can be \"music21\" or \"partitura\".\n\n    Returns\n    -------\n    str\n        The previous name of the preferred XML reader.\n\n    Raises\n    ------\n    ValueError\n        If an invalid reader is provided.\n    \"\"\"\n    global preferred_xml_reader\n    allowed = [\"music21\", \"partitura\"]\n    if reader not in allowed:\n        raise ValueError(f\"Invalid XML reader. Must be one of {allowed}\")\n\n    previous = preferred_xml_reader\n    preferred_xml_reader = reader\n    return previous\n</code></pre>"},{"location":"reference/io/#amads.io.readscore.set_preferred_xml_reader(reader)","title":"<code>reader</code>","text":"(<code>str</code>)           \u2013            <p>The name of the preferred XML reader. Can be \"music21\" or \"partitura\".</p>"},{"location":"reference/io/#amads.io.readscore.set_reader_warning_level","title":"set_reader_warning_level","text":"<pre><code>set_reader_warning_level(level: str) -&gt; str\n</code></pre> <p>Set the warning level for <code>readscore</code> functions.</p> <p>The translation from music data files to AMADS is not always well-defined and may involve intermediate representations using Music21, Partitura or others. Usually, warnings are produced when there is possible data loss or ambiguity, but these can be more annoying than informative. The warning level can be controlled using this function, which applies to all file formats.</p> <p>The current warning level is stored in <code>amads.io.reader.reader_warning_level</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Previous warning level.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid warning level is provided.</p> </li> </ul> Source code in <code>amads/io/readscore.py</code> <pre><code>def set_reader_warning_level(level: str) -&gt; str:\n    \"\"\"\n    Set the warning level for `readscore` functions.\n\n    The translation from music data files to AMADS is not always well-defined\n    and may involve intermediate representations using Music21, Partitura or\n    others. Usually, warnings are produced when there is possible data loss or\n    ambiguity, but these can be more annoying than informative. The warning\n    level can be controlled using this function, which applies to all file\n    formats.\n\n    The current warning level is stored in\n    `amads.io.reader.reader_warning_level`.\n\n    Parameters\n    ----------\n    level : str\n        The warning level to set.\n        Options are \"none\", \"low\", \"default\", \"high\".\n\n        - \"none\" will suppress all warnings during `read_score()`\n          and also suppresses notice of reader subsystem and file name.\n        - \"low\" will print one notice if there are any warnings.\n        - \"default\" will obey environment settings to control warnings.\n        - \"high\" will print all warnings during `read_score()`, overriding\n            environment settings.\n\n    Returns\n    -------\n    str\n        Previous warning level.\n\n    Raises\n    ------\n    ValueError\n        If an invalid warning level is provided.\n    \"\"\"\n    global reader_warning_level\n    allowed = [\"none\", \"low\", \"default\", \"high\"]\n    if level not in allowed:\n        raise ValueError(f\"Invalid warning level. Must be one of {allowed}\")\n\n    previous = reader_warning_level\n    reader_warning_level = level\n    return previous\n</code></pre>"},{"location":"reference/io/#amads.io.readscore.set_reader_warning_level(level)","title":"<code>level</code>","text":"(<code>str</code>)           \u2013            <p>The warning level to set. Options are \"none\", \"low\", \"default\", \"high\".</p> <ul> <li>\"none\" will suppress all warnings during <code>read_score()</code>   and also suppresses notice of reader subsystem and file name.</li> <li>\"low\" will print one notice if there are any warnings.</li> <li>\"default\" will obey environment settings to control warnings.</li> <li>\"high\" will print all warnings during <code>read_score()</code>, overriding     environment settings.</li> </ul>"},{"location":"reference/io/#amads.io.readscore.import_xml","title":"import_xml","text":"<pre><code>import_xml(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Use Partitura or music21 to import a MusicXML file.</p> <p>In Music21, the first measure may be a partial measure containing an anacrusis (\u201cpickup\u201d). This is somewhat ambiguous and does not translate well to MIDI which is less expressive than MusicXML.</p> <p>Therefore, if the first measure read with Music21 is not a full measure, a rest is inserted and the remainder is shifted to form a full measure according to its time signature.</p> <p>Author: Roger B. Dannenberg</p> Source code in <code>amads/io/readscore.py</code> <pre><code>def import_xml(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"Use Partitura or music21 to import a MusicXML file.\n\n    In Music21, the first measure may be a partial measure containing\n    an anacrusis (\u201cpickup\u201d). This is somewhat ambiguous and does not\n    translate well to MIDI which is less expressive than MusicXML.\n\n    Therefore, if the first measure read with Music21 is not a full\n    measure, a rest is inserted and the remainder is shifted to\n    form a full measure according to its time signature.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n    \"\"\"\n    global _last_used_reader\n    import_xml_fn = _check_for_subsystem(\"xml\")\n    if import_xml_fn is not None:\n        _last_used_reader = import_xml_fn\n        if reader_warning_level != \"none\":\n            print(\n                f\"Reading {filename} using MusicXML reader \"\n                f\"file={import_xml_fn.__name__}.\"\n            )\n        return import_xml_fn(\n            filename, flatten, collapse, show, group_by_instrument\n        )\n    else:\n        raise Exception(\n            \"Could not find a MusicXML import function. \"\n            f\"Preferred subsystem is {preferred_xml_reader}\"\n        )\n</code></pre>"},{"location":"reference/io/#amads.io.readscore.import_midi","title":"import_midi","text":"<pre><code>import_midi(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Use music21 or pretty_midi to import a Standard MIDI file.</p> <p>Author: Roger B. Dannenberg</p> Notes <p>Each Standard MIDI File track corresponds to a Staff when creating a full AMADS Score. Everything is combined into one part when <code>flatten</code> and <code>collapse</code> are specified.</p> <p>AMADS assumes that instruments (midi program numbers) are fixed for each Staff (or Part in flat scores), and MIDI channels are not represented. The use of program change messages within a track to change the program are ignored, but may generate warnings.</p> <p>In general, AMADS instrument name corresponds to the MIDI track name, and MIDI program numbers are stored as <code>\"midi_program\"</code> in the <code>info</code> attribute of the Staff or Part corresponding to the track.</p> <p>MIDI files do not have a Part/Staff structure, but you can write multiple tracks with the same name. Both the <code>\"music21\"</code> and <code>\"pretty_midi\"</code> readers will group tracks with matching names as Staffs in a single Part. This may result in an unexpected Part/Staff hierarchy if tracks are not named or if tracks are named something like \"Piano-Treble\" and \"Piano-Bass\", which would produce two Parts as different instruments as opposed to one Part with two Staffs.</p> <p>Unless <code>flatten</code> or <code>collapse</code>, the MIDI file time signature information will be used to form Measures with Staffs, and Notes will be broken where they cross measure boundaries and then tied.  The default time signature is 4/4.</p> Pretty MIDI Import Notes <p>If there is no program change in a file, the <code>\"pretty_midi\"</code> reader will use 0, and 0 will be stored as <code>\"midi_program\"</code> in the Part or Staff's <code>info</code> (see get and set).</p> <p>If there is no track name, the <code>Part.instrument</code> is derived from the track program number (defaults to zero).</p> <p>If the MIDI file track name is <code>\"Unknown\"</code>, the <code>Part.instrument</code> is set to None. This is because when the <code>\"pretty_midi\"</code> writer writes a part where <code>Part.instrument is None</code>, the name <code>\"Unknown\"</code> is used instead. Therefore, the reader will recreate the AMADS Part where <code>Part.instrument is None</code>.</p> <p>Pretty MIDI will not insert any KeySignature unless key signature meta-events are found.</p> Music21 MIDI Import Notes <p>Music21 may infer a Clef and KeySignature even though MIDI does not even have a meta-event for clefs, and even if the MIDI file has no key signature meta-event.</p> Source code in <code>amads/io/readscore.py</code> <pre><code>def import_midi(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"Use music21 or pretty_midi to import a Standard MIDI file.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Notes\n    -----\n    Each Standard MIDI File track corresponds to a Staff when\n    creating a full AMADS Score. Everything is combined into one\n    part when `flatten` and `collapse` are specified.\n\n    AMADS assumes that instruments (midi program numbers) are fixed\n    for each Staff (or Part in flat scores), and MIDI channels are\n    not represented. The use of program change messages within a\n    track to change the program are ignored, but may generate warnings.\n\n    In general, AMADS instrument name corresponds to the MIDI track\n    name, and MIDI program numbers are stored as `\"midi_program\"`\n    in the `info` attribute of the Staff or Part corresponding to\n    the track.\n\n    MIDI files do not have a Part/Staff structure, but you can\n    write multiple tracks with the same name. Both the `\"music21\"`\n    and `\"pretty_midi\"` readers will group tracks with matching\n    names as Staffs in a single Part. This may result in an\n    unexpected Part/Staff hierarchy if tracks are not named or\n    if tracks are named something like \"Piano-Treble\" and\n    \"Piano-Bass\", which would produce two Parts as different\n    instruments as opposed to one Part with two Staffs.\n\n    Unless `flatten` or `collapse`, the MIDI file time signature\n    information will be used to form Measures with Staffs, and\n    Notes will be broken where they cross measure boundaries and\n    then tied.  The default time signature is 4/4.\n\n    Pretty MIDI Import Notes\n    ------------------------\n    If there is no program change in a file, the `\"pretty_midi\"`\n    reader will use 0, and 0 will be stored as `\"midi_program\"`\n    in the Part or Staff's `info` (see\n    [get][amads.core.basics.Event.get] and\n    [set][amads.core.basics.Event.set]).\n\n    If there is no track name, the `Part.instrument` is derived\n    from the track program number (defaults to zero).\n\n    If the MIDI file track name is `\"Unknown\"`, the `Part.instrument`\n    is set to None. This is because when the `\"pretty_midi\"` writer\n    writes a part where `Part.instrument is None`, the name `\"Unknown\"`\n    is used instead. Therefore, the reader will recreate the AMADS\n    Part where `Part.instrument is None`.\n\n    Pretty MIDI will not insert any KeySignature unless key signature\n    meta-events are found.\n\n    Music21 MIDI Import Notes\n    -------------------------\n    Music21 may infer a Clef and KeySignature even though MIDI\n    does not even have a meta-event for clefs, and even if the\n    MIDI file has no key signature meta-event.\n    \"\"\"\n    global _last_used_reader\n    import_midi_fn = _check_for_subsystem(\"midi\")\n    if import_midi_fn is not None:\n        _last_used_reader = import_midi_fn\n        if reader_warning_level != \"none\":\n            print(\n                f\"Reading {filename} using MIDI reader \"\n                f\"{import_midi_fn.__name__}.\"\n            )\n        return import_midi_fn(\n            filename, flatten, collapse, show, group_by_instrument\n        )\n    else:\n        raise Exception(\n            \"Could not find a MIDI file import function. \"\n            f\"Preferred subsystem is {preferred_midi_reader}\"\n        )\n</code></pre>"},{"location":"reference/io/#amads.io.readscore.read_score","title":"read_score","text":"<pre><code>read_score(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    format: str | None = None,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Read a file with the given format, <code>'xml'</code>, <code>'midi'</code>, <code>'kern'</code>, <code>'mei'</code>.</p> <p>If format is None (default), the format is based on the filename extension, which can be <code>'xml'</code>, <code>'mid'</code>, <code>'midi'</code>, <code>'smf'</code>, <code>'kern'</code>, or <code>'mei'</code>. (Valid extensions are in <code>amads.io.readscore.valid_score_extensions</code>.)</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The imported score</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the format is unknown or not implemented.</p> </li> </ul> Source code in <code>amads/io/readscore.py</code> <pre><code>def read_score(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    format: Optional[str] = None,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"Read a file with the given format, `'xml'`, `'midi'`, `'kern'`, `'mei'`.\n\n    If format is None (default), the format is based on the filename\n    extension, which can be `'xml'`, `'mid'`, `'midi'`, `'smf'`, `'kern'`,\n    or `'mei'`. (Valid extensions are in\n    `amads.io.readscore.valid_score_extensions`.)\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    filename : str\n        The path (relative or absolute) to the music file.\n        Can also be an URL.\n    flatten : bool\n        The returned score will be flat (Score, Parts, Notes).\n    collapse: bool\n        If collapse and flatten, the parts will be merged into one.\n    show : bool\n        Print a text representation of the data.\n    format: string\n        One from among limited standard options (e.g.,\n        `'xml'`, `'midi'`, `'kern'`, `'mei'`)\n    group_by_instrument : bool\n        If True (default), when the underlying reader (e.g. for \"pretty_midi\",\n        \"music21\" or \"partitura\") reads Parts with the same instrument, their\n        content will be grouped into a single part. This means that if\n        `flatten`, then parts with the same instrument will be merged into a\n        single part. If `flatten` is False, then the staffs of parts with the\n        same instrument will be grouped within a single part.\n        If `group_by_instrument` is False, the parts read in by the underlying\n        reader will be preserved as separate parts. `group_by_instrument` is\n        True by default so that when reading Piano scores with separate treble\n        and bass staffs, the resulting AMADS Score will generally have a single\n        Piano part with two staffs. A score for Piano and Violin will generally\n        have two parts, one for Piano and one for Violin, as opposed to three\n        parts (Piano-Treble, Piano-Bass, Violin). On the other hand, a score for\n        two Violins might be represented a one part with two staffs by default,\n        but setting `group_by_instrument` to False will more likely keep the\n        two Violin parts separate. Unfortunately, exact behavior depends on the\n        underlying reader, MIDI track names, and/or MusicXML structure and\n        naming.\n\n    Returns\n    -------\n    Score\n        The imported score\n\n    Raises\n    ------\n    ValueError\n        If the format is unknown or not implemented.\n    \"\"\"\n    if filename.startswith(\"http\") or \"://\" in filename:\n        with tempfile.NamedTemporaryFile(\n            suffix=pathlib.Path(filename).suffix or \".tmp\", delete=False\n        ) as tmp_file:\n            urllib.request.urlretrieve(filename, tmp_file.name)\n            filename = tmp_file.name\n\n    if format is None:\n        ext = pathlib.Path(filename).suffix.lower()\n        if ext in [\".xml\", \".musicxml\", \".mxl\"]:\n            format = \"xml\"\n        elif ext in [\".mid\", \".midi\", \".smf\"]:\n            format = \"midi\"\n        elif ext == \".kern\":\n            format = \"kern\"\n        elif ext == \".mei\":\n            format = \"mei\"\n        else:\n            raise ValueError(\n                f\"Unsupported file extension: {ext}. \"\n                f\"Valid extensions: {valid_score_extensions}\"\n            )\n\n    # File format handling\n    with warnings.catch_warnings(record=True) as w:\n        if reader_warning_level == \"none\":\n            warnings.simplefilter(\"ignore\")\n        else:\n            warnings.simplefilter(\"always\")\n\n        if format == \"xml\":\n            score = import_xml(\n                filename,\n                flatten,\n                collapse,\n                show,\n                group_by_instrument=group_by_instrument,\n            )\n        elif format == \"midi\":\n            score = import_midi(\n                filename,\n                flatten,\n                collapse,\n                show,\n                group_by_instrument=group_by_instrument,\n            )\n        elif format == \"kern\":\n            raise ValueError(\n                \"Kern format input not implemented yet. \"\n                \"Consider using the `kernr` package.\"\n            )\n        elif format == \"mei\":\n            raise ValueError(\n                \"MEI format input not implemented yet. \"\n                \"Consider using the `mei` package.\"\n            )\n        else:\n            raise ValueError(f\"{format} format specification is unknown\")\n\n        # Warning handling\n        if reader_warning_level == \"low\":\n            if len(w) &gt; 0:\n                print(\n                    f\"Warning: {len(w)} warnings were generated in \"\n                    f\"read_score({filename}).\\n\"\n                    \"  Use amads.io.readscore.set_reader_warning_level() \"\n                    \"for more details.\"\n                )\n        else:  # \"none\", \"default\", or \"high\"\n            for warning in w:\n                print(\n                    f\"{warning.filename}:{warning.lineno}: \"\n                    f\"{warning.category.__name__}: {warning.message}\"\n                )\n\n        return score\n</code></pre>"},{"location":"reference/io/#amads.io.readscore.read_score(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The path (relative or absolute) to the music file. Can also be an URL.</p>"},{"location":"reference/io/#amads.io.readscore.read_score(flatten)","title":"<code>flatten</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>The returned score will be flat (Score, Parts, Notes).</p>"},{"location":"reference/io/#amads.io.readscore.read_score(collapse)","title":"<code>collapse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If collapse and flatten, the parts will be merged into one.</p>"},{"location":"reference/io/#amads.io.readscore.read_score(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Print a text representation of the data.</p>"},{"location":"reference/io/#amads.io.readscore.read_score(format)","title":"<code>format</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>One from among limited standard options (e.g., <code>'xml'</code>, <code>'midi'</code>, <code>'kern'</code>, <code>'mei'</code>)</p>"},{"location":"reference/io/#amads.io.readscore.read_score(group_by_instrument)","title":"<code>group_by_instrument</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), when the underlying reader (e.g. for \"pretty_midi\", \"music21\" or \"partitura\") reads Parts with the same instrument, their content will be grouped into a single part. This means that if <code>flatten</code>, then parts with the same instrument will be merged into a single part. If <code>flatten</code> is False, then the staffs of parts with the same instrument will be grouped within a single part. If <code>group_by_instrument</code> is False, the parts read in by the underlying reader will be preserved as separate parts. <code>group_by_instrument</code> is True by default so that when reading Piano scores with separate treble and bass staffs, the resulting AMADS Score will generally have a single Piano part with two staffs. A score for Piano and Violin will generally have two parts, one for Piano and one for Violin, as opposed to three parts (Piano-Treble, Piano-Bass, Violin). On the other hand, a score for two Violins might be represented a one part with two staffs by default, but setting <code>group_by_instrument</code> to False will more likely keep the two Violin parts separate. Unfortunately, exact behavior depends on the underlying reader, MIDI track names, and/or MusicXML structure and naming.</p>"},{"location":"reference/io/#amads.io.readscore.last_used_reader","title":"last_used_reader","text":"<pre><code>last_used_reader() -&gt; str | None\n</code></pre> <p>Return the name of the last used reader function.</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>The name of the actual function used in the last call to <code>read_score</code>, or None if no reader has been used yet.</p> </li> </ul> Source code in <code>amads/io/readscore.py</code> <pre><code>def last_used_reader() -&gt; Optional[str]:\n    \"\"\"Return the name of the last used reader function.\n\n    Returns\n    -------\n    Optional[str]\n        The name of the actual function used in the last call to `read_score`,\n        or None if no reader has been used yet.\n    \"\"\"\n    if _last_used_reader is not None:\n        return _last_used_reader.__name__\n    return None\n</code></pre>"},{"location":"reference/io/#output","title":"Output","text":"<p>Similar to input functions, you should use writescore.write_score described below to write an AMADS Score to a file. </p>"},{"location":"reference/io/#amads.io.writescore","title":"writescore","text":"<p>functions for file output</p> <p>Functions:</p> <ul> <li> <code>set_preferred_midi_writer</code>             \u2013              <p>Set a (new) preferred MIDI writer.</p> </li> <li> <code>set_preferred_xml_writer</code>             \u2013              <p>Set a (new) preferred XML writer.</p> </li> <li> <code>set_writer_warning_level</code>             \u2013              <p>Set the warning level for writescore functions.</p> </li> <li> <code>export_xml</code>             \u2013              <p>Use Partitura or music21 to export a MusicXML file.</p> </li> <li> <code>export_midi</code>             \u2013              <p>Use music21 or pretty_midi to export a Standard MIDI file.</p> </li> <li> <code>write_score</code>             \u2013              <p>Write a file with the given format, <code>'xml'</code>, <code>'midi'</code>, <code>'kern'</code>, <code>'mei'</code>.</p> </li> </ul>"},{"location":"reference/io/#amads.io.writescore-functions","title":"Functions","text":""},{"location":"reference/io/#amads.io.writescore.set_preferred_midi_writer","title":"set_preferred_midi_writer","text":"<pre><code>set_preferred_midi_writer(writer: str) -&gt; str\n</code></pre> <p>Set a (new) preferred MIDI writer.</p> <p>Returns the previous writer preference. The current preference is stored in <code>amads.io.writer.preferred_midi_writer</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The previous name of the preferred MIDI writer.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid writer is provided.</p> </li> </ul> Source code in <code>amads/io/writescore.py</code> <pre><code>def set_preferred_midi_writer(writer: str) -&gt; str:\n    \"\"\"Set a (new) preferred MIDI writer.\n\n    Returns the previous writer preference. The current preference is stored\n    in `amads.io.writer.preferred_midi_writer`.\n\n    Parameters\n    ----------\n    writer : str\n        The name of the preferred MIDI writer. Can be \"music21\" or \"pretty_midi\".\n\n    Returns\n    -------\n    str\n        The previous name of the preferred MIDI writer.\n\n    Raises\n    ------\n    ValueError\n        If an invalid writer is provided.\n\n    \"\"\"\n    global preferred_midi_writer\n    previous_writer = preferred_midi_writer\n    if writer in [\"music21\", \"partitura\", \"pretty_midi\"]:\n        preferred_midi_writer = writer\n    else:\n        raise ValueError(\n            \"Invalid MIDI writer. Choose 'music21', 'partitura', or \"\n            \"'pretty_midi'.\"\n        )\n    return previous_writer\n</code></pre>"},{"location":"reference/io/#amads.io.writescore.set_preferred_midi_writer(writer)","title":"<code>writer</code>","text":"(<code>str</code>)           \u2013            <p>The name of the preferred MIDI writer. Can be \"music21\" or \"pretty_midi\".</p>"},{"location":"reference/io/#amads.io.writescore.set_preferred_xml_writer","title":"set_preferred_xml_writer","text":"<pre><code>set_preferred_xml_writer(writer: str) -&gt; str\n</code></pre> <p>Set a (new) preferred XML writer.</p> <p>Returns the previous writer preference. The current preference is stored in <code>amads.io.writer.preferred_xml_writer</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The previous name of the preferred XML writer.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid writer is provided.</p> </li> </ul> Source code in <code>amads/io/writescore.py</code> <pre><code>def set_preferred_xml_writer(writer: str) -&gt; str:\n    \"\"\"\n    Set a (new) preferred XML writer.\n\n    Returns the previous writer preference. The current preference is stored\n    in `amads.io.writer.preferred_xml_writer`.\n\n\n    Parameters\n    ----------\n    writer : str\n        The name of the preferred XML writer. Can be \"music21\" or \"partitura\".\n\n    Returns\n    -------\n    str\n        The previous name of the preferred XML writer.\n\n    Raises\n    ------\n    ValueError\n        If an invalid writer is provided.\n    \"\"\"\n    global preferred_xml_writer\n    previous_writer = preferred_xml_writer\n    if writer in [\"music21\", \"partitura\"]:\n        preferred_xml_writer = writer\n    else:\n        raise ValueError(\"Invalid XML writer. Choose 'music21' or 'partitura'.\")\n    return previous_writer\n</code></pre>"},{"location":"reference/io/#amads.io.writescore.set_preferred_xml_writer(writer)","title":"<code>writer</code>","text":"(<code>str</code>)           \u2013            <p>The name of the preferred XML writer. Can be \"music21\" or \"partitura\".</p>"},{"location":"reference/io/#amads.io.writescore.set_writer_warning_level","title":"set_writer_warning_level","text":"<pre><code>set_writer_warning_level(level: str) -&gt; str\n</code></pre> <p>Set the warning level for writescore functions.</p> <p>The translation from AMADS to music data files is not always well-defined and may involve intermediate representations using Music21, Partitura or others. Usually, warnings are produced when there is possible data loss or ambiguity, but these can be more annoying than informative. The warning level can be controlled using this function, which applies to all file formats.</p> <p>The current warning level is stored in <code>amads.io.writer.writer_warning_level</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Previous warning level.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If an invalid warning level is provided.</p> </li> </ul> Source code in <code>amads/io/writescore.py</code> <pre><code>def set_writer_warning_level(level: str) -&gt; str:\n    \"\"\"\n    Set the warning level for writescore functions.\n\n    The translation from AMADS to music data files is not always well-defined\n    and may involve intermediate representations using Music21, Partitura or\n    others. Usually, warnings are produced when there is possible data loss or\n    ambiguity, but these can be more annoying than informative. The warning\n    level can be controlled using this function, which applies to all file\n    formats.\n\n    The current warning level is stored in\n    `amads.io.writer.writer_warning_level`.\n\n    Parameters\n    ----------\n    level : str\n        The warning level to set. Can be \"none\", \"low\", \"default\", \"high\".\n\n        - \"none\" - will suppress all warnings during write_score().\n        - \"low\" - will show print one notice if there are any warnings.\n        - \"default\" - will obey environment settings to control warnings.\n        - \"high\" - will print all warnings during write_score(), overriding\n            environment settings.\n\n    Returns\n    -------\n    str\n        Previous warning level.\n\n    Raises\n    -------\n    ValueError\n        If an invalid warning level is provided.\n    \"\"\"\n    global writer_warning_level\n    previous_level = writer_warning_level\n    if level in [\"none\", \"low\", \"default\", \"high\"]:\n        writer_warning_level = level\n    else:\n        raise ValueError(\n            \"Invalid warning level. Choose 'none', 'low', 'default', or 'high'.\"\n        )\n    return previous_level\n</code></pre>"},{"location":"reference/io/#amads.io.writescore.set_writer_warning_level(level)","title":"<code>level</code>","text":"(<code>str</code>)           \u2013            <p>The warning level to set. Can be \"none\", \"low\", \"default\", \"high\".</p> <ul> <li>\"none\" - will suppress all warnings during write_score().</li> <li>\"low\" - will show print one notice if there are any warnings.</li> <li>\"default\" - will obey environment settings to control warnings.</li> <li>\"high\" - will print all warnings during write_score(), overriding     environment settings.</li> </ul>"},{"location":"reference/io/#amads.io.writescore.export_xml","title":"export_xml","text":"<pre><code>export_xml(score: Score, filename: str, show: bool = False) -&gt; None\n</code></pre> <p>Use Partitura or music21 to export a MusicXML file.</p> <p>Partitura does not seem to support per-staff key signatures, so key signatures from AMADS are simply added to Partitura parts. When there are multiple staffs, there could be duplicate key signatures (to be tested).</p> <p>Author: Roger B. Dannenberg</p> Source code in <code>amads/io/writescore.py</code> <pre><code>def export_xml(\n    score: Score,\n    filename: str,\n    show: bool = False,\n) -&gt; None:\n    \"\"\"Use Partitura or music21 to export a MusicXML file.\n\n    Partitura does not seem to support per-staff key signatures,\n    so key signatures from AMADS are simply added to Partitura\n    parts. When there are multiple staffs, there could be\n    duplicate key signatures (to be tested).\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n    \"\"\"\n    export_xml_fn = _check_for_subsystem(\"xml\")\n    if export_xml_fn is not None:\n        if writer_warning_level != \"none\":\n            print(\n                f\"Exporting {filename} using MusicXML writer\"\n                f\" {export_xml_fn.__name__}.\"\n            )\n        export_xml_fn(score, filename, show)\n    else:\n        raise Exception(\n            \"Could not find a MusicXML export function. \"\n            \"Preferred subsystem is \" + str(preferred_xml_writer)\n        )\n</code></pre>"},{"location":"reference/io/#amads.io.writescore.export_midi","title":"export_midi","text":"<pre><code>export_midi(score: Score, filename: str, show: bool = False) -&gt; None\n</code></pre> <p>Use music21 or pretty_midi to export a Standard MIDI file.</p> <p>Author: Roger B. Dannenberg</p> Notes <p>AMADS assumes that instruments (midi program numbers) are fixed for each Staff (or Part in flat scores), and MIDI channels are not represented. This corresponds to some DAWs such as LogicPro, which represents channels but ignores them when tracks are synthesized in software by a single instrument. The MIDI program is stored as info (see get and set) under key <code>\"midi_program\"</code> on the Staff, or if there is no Staff or no <code>\"midi_program\"</code> on the Staff, under key <code>\"midi_program\"</code> on the Part.</p> <p>Parts also have an <code>instrument</code> attribute, which is stored as the MIDI track name. (Therefore, if a Part has two Staffs, there will be two tracks with the same name.)  If there is no MIDI program for the track, the <code>'pretty_midi'</code> writer will use <code>pretty_midi.instrument_name_to_program</code> to determine a program number since a program number is required. (As opposed to Standard MIDI Files, which need not have any MIDI program message at all.) If <code>pretty_midi.instrument_name_to_program</code> fails, the program is set to 0 (\u201cAcoustic Grand Piano\u201d).</p> <p>Pretty MIDI also requires an instrument name. If the AMADS Part <code>instrument</code> attribute is <code>None</code>, then <code>\"Unknown\"</code> is used. The Pretty MIDI reader will convert <code>\"Unknown\"</code> back to <code>None</code>.</p> Source code in <code>amads/io/writescore.py</code> <pre><code>def export_midi(\n    score: Score,\n    filename: str,\n    show: bool = False,\n) -&gt; None:\n    \"\"\"Use music21 or pretty_midi to export a Standard MIDI file.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Notes\n    -----\n    AMADS assumes that instruments (midi program numbers) are fixed\n    for each Staff (or Part in flat scores), and MIDI channels are\n    not represented. This corresponds to some DAWs such as LogicPro,\n    which represents channels but ignores them when tracks are\n    synthesized in software by a single instrument. The MIDI program\n    is stored as info (see [get][amads.core.basics.Event.get] and\n    [set][amads.core.basics.Event.set]) under key `\"midi_program\"`\n    on the Staff, or if there is no Staff or no `\"midi_program\"` on\n    the Staff, under key `\"midi_program\"` on the Part.\n\n    Parts also have an `instrument` attribute, which is stored as\n    the MIDI track name. (Therefore, if a Part has two Staffs, there\n    will be two tracks with the same name.)  If there is no MIDI\n    program for the track, the `'pretty_midi'` writer will use\n    `pretty_midi.instrument_name_to_program` to determine a program\n    number since a program number is required. (As opposed to Standard\n    MIDI Files, which need not have any MIDI program message at all.)\n    If `pretty_midi.instrument_name_to_program` fails, the program is\n    set to 0 (\u201cAcoustic Grand Piano\u201d).\n\n    Pretty MIDI also requires an instrument name. If the AMADS Part\n    `instrument` attribute is `None`, then `\"Unknown\"` is used. The\n    Pretty MIDI reader will convert `\"Unknown\"` back to `None`.\n    \"\"\"\n    export_midi_fn = _check_for_subsystem(\"midi\")\n    if export_midi_fn is not None:\n        if writer_warning_level != \"none\":\n            print(\n                f\"Exporting {filename} using MIDI writer\"\n                f\" {export_midi_fn.__name__}.\"\n            )\n        export_midi_fn(score, filename, show)\n    else:\n        raise Exception(\n            \"Could not find a MIDI file export function. \"\n            \"Preferred subsystem is \" + str(preferred_midi_writer)\n        )\n</code></pre>"},{"location":"reference/io/#amads.io.writescore.write_score","title":"write_score","text":"<pre><code>write_score(\n    score: Score, filename: str, show: bool = False, format=None\n) -&gt; None\n</code></pre> <p>Write a file with the given format, <code>'xml'</code>, <code>'midi'</code>, <code>'kern'</code>, <code>'mei'</code>.</p> <p>If format is None (default), the format is based on the filename extension, which can be <code>'xml'</code>, <code>'mid'</code>, <code>'midi'</code>, <code>'smf'</code>, <code>'kern'</code>, or <code>'mei'</code></p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if format is unknown</p> </li> </ul> Note <p>See individual export methods, e.g. midi_export, xml_export, etc., for details on how they handle various features like instrument, MIDI metadata, etc.</p> Source code in <code>amads/io/writescore.py</code> <pre><code>def write_score(\n    score: Score,\n    filename: str,\n    show: bool = False,\n    format=None,\n) -&gt; None:\n    \"\"\"Write a file with the given format, `'xml'`, `'midi'`, `'kern'`, `'mei'`.\n\n    If format is None (default), the format is based on the filename\n    extension, which can be `'xml'`, `'mid'`, `'midi'`, `'smf'`, `'kern'`,\n    or `'mei'`\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        the score to write\n    filename : str\n        the path (relative or absolute) to the music file\n    show : bool\n        print a text representation of the data\n    format: string\n        one of `'xml'`, `'midi'`, `'kern'`, `'mei'`\n\n    Raises\n    ------\n    ValueError\n        if format is unknown\n\n    Note\n    ----\n    See individual export methods, e.g. midi_export, xml_export, etc.,\n    for details on how they handle various features like instrument,\n    MIDI metadata, etc.\n    \"\"\"\n    with warnings.catch_warnings(record=True) as w:\n        if writer_warning_level == \"none\":\n            warnings.simplefilter(\"ignore\")\n        else:\n            warnings.simplefilter(\"always\")\n\n        if format is None:\n            ext = pathlib.Path(filename).suffix\n            if ext == \".xml\":\n                format = \"xml\"\n            elif ext == \".mid\" or ext == \".midi\" or ext == \".smf\":\n                format = \"midi\"\n            elif ext == \".kern\":\n                format = \"kern\"\n            elif ext == \".mei\":\n                format = \"mei\"\n        if format == \"xml\":\n            export_xml(score, filename, show)\n        elif format == \"midi\":\n            export_midi(score, filename, show)\n        elif format == \"kern\":\n            raise ValueError(\"Kern format output not implemented\")\n        elif format == \"mei\":\n            raise ValueError(\"MEI format output not implemented\")\n        else:\n            raise ValueError(str(format) + \" format specification is unknown\")\n\n        if writer_warning_level == \"low\":\n            if len(w) &gt; 0:\n                print(\n                    f\"Warning: {len(w)} warnings were generated in\"\n                    f\" write_score({filename}). Use\"\n                    \" amads.io.writescore.set_writer_warning_level() for\"\n                    \" more details.\"\n                )\n        else:  # \"none\", \"default\", or \"high\"\n            for warning in w:\n                formatted = warnings.formatwarning(\n                    warning.message,\n                    warning.category,\n                    warning.filename,\n                    warning.lineno,\n                )\n                print(formatted, end=\"\")\n</code></pre>"},{"location":"reference/io/#amads.io.writescore.write_score(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>the score to write</p>"},{"location":"reference/io/#amads.io.writescore.write_score(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>the path (relative or absolute) to the music file</p>"},{"location":"reference/io/#amads.io.writescore.write_score(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>print a text representation of the data</p>"},{"location":"reference/io/#amads.io.writescore.write_score(format)","title":"<code>format</code>","text":"\u2013            <p>one of <code>'xml'</code>, <code>'midi'</code>, <code>'kern'</code>, <code>'mei'</code></p>"},{"location":"reference/io/#piano-roll-display","title":"Piano Roll Display","text":""},{"location":"reference/io/#amads.io.pianoroll","title":"pianoroll","text":"<p>Ports <code>pianoroll</code> Function</p> <p>Original Doc: https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=82</p> <p>Functions:</p> <ul> <li> <code>pianoroll</code>             \u2013              <p>Converts a Score to a piano roll display of a musical score.</p> </li> </ul>"},{"location":"reference/io/#amads.io.pianoroll-functions","title":"Functions","text":""},{"location":"reference/io/#amads.io.pianoroll.pianoroll","title":"pianoroll","text":"<pre><code>pianoroll(\n    score: Score,\n    title: str = \"Piano Roll\",\n    y_label: str = \"name\",\n    x_label: str = \"quarter\",\n    color: str = \"skyblue\",\n    accidental: str = \"sharp\",\n    show: bool = True,\n) -&gt; Figure\n</code></pre> <p>Converts a Score to a piano roll display of a musical score.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>A matplotlib.figure.Figure of a pianoroll diagram.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If there are invalid input arguments</p> </li> </ul> Source code in <code>amads/io/pianoroll.py</code> <pre><code>def pianoroll(\n    score: Score,\n    title: str = \"Piano Roll\",\n    y_label: str = \"name\",\n    x_label: str = \"quarter\",\n    color: str = \"skyblue\",\n    accidental: str = \"sharp\",\n    show: bool = True,\n) -&gt; figure.Figure:\n    \"\"\"Converts a Score to a piano roll display of a musical score.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to display\n    title : str, optional\n        The title of the plot. Defaults to \"Piano Roll\".\n    y_label : str, optional\n        Determines whether the y-axis is\n        labeled with note names or MIDI numbers.\n        Valid Input: 'name' (default) or 'num'.\n    x_label : str, optional\n        Determines whether the x-axis is labeled with quarters or\n        seconds. Valid input: 'quarter' (default) or 'sec'.\n    color : str, optional\n        The color of the note rectangles. Defaults to 'skyblue'.\n    accidental : str, optional\n        Determines whether the y-axis is\n        labeled with sharps or flats. Only useful if argument\n        y_label is 'name'. Raises exception on inputs that's not\n        'sharp', 'flat', or 'both'. Defaults to 'sharp', which is\n        what is done in miditoolbox. 'both' means use AMADS defaults\n        which are C#, Eb, F#, G#, Bb.\n    show : bool, optional\n        If True (default), the plot is displayed.\n\n    Returns\n    -------\n    Figure\n        A matplotlib.figure.Figure of a pianoroll diagram.\n\n    Raises\n    ------\n    ValueError\n        If there are invalid input arguments\n    \"\"\"\n\n    # remove ties and make a sorted list of all notes:\n    score = score.flatten(collapse=True)\n    # Check for correct x_label input argument\n    if x_label != \"quarter\" and x_label != \"sec\":\n        raise ValueError(\"Invalid x_label type\")\n\n    # Check for correct accidental input argument\n    if accidental != \"sharp\" and accidental != \"flat\" and accidental != \"both\":\n        raise ValueError(\"Invalid accidental type\")\n\n    fig, ax = plt.subplots()\n\n    min_note, max_note = 127.0, 0.0\n    max_time = 1  # plot at least 1 second or beat\n    # now score has one part that is all notes\n    for note in cast(Part, next(score.find_all(Part))).content:\n        note = cast(Note, note)\n        onset_time = note.onset\n        offset_time = note.offset\n        pitch = note.key_num - 0.5  # to center note rectangle\n\n        # Conditionally converts beat to sec\n        if x_label == \"sec\" and score.units_are_quarters:\n            onset_time = score.time_map.quarter_to_time(onset_time)\n            offset_time = score.time_map.quarter_to_time(offset_time)\n        elif x_label == \"quarter\" and score.units_are_seconds:\n            onset_time = score.time_map.time_to_quarter(onset_time)\n            offset_time = score.time_map.time_to_quarter(offset_time)\n        # Stores min and max note for y_axis labeling\n        if pitch &lt; min_note:\n            min_note = pitch\n        if pitch &gt; max_note:\n            max_note = pitch\n\n        # Stores max note start time + note duration for x_axis limit\n        if offset_time &gt; max_time:\n            max_time = offset_time\n\n        # Draws the note\n        rect = patches.Rectangle(\n            (onset_time, pitch),\n            offset_time - onset_time,\n            1,\n            edgecolor=\"black\",\n            facecolor=color,\n        )\n        ax.add_patch(rect)\n\n    # Determines correct axis labels\n    if min_note == 127 and max_note == 0:  # \"fake\" better axes:\n        min_note = 59\n        max_note = 59\n\n    midi_numbers = list(range(int(min_note), int(max_note + 2)))\n\n    match y_label:\n        case \"num\":\n            notes = midi_numbers\n            y_label = \"MIDI Key (Pitch) Number\"\n        case \"name\":\n            if accidental == \"both\":\n                accidental = \"default\"  # for simplest_enharmonic\n            notes = [\n                Pitch(mn).simplest_enharmonic(accidental).name_with_octave\n                for mn in midi_numbers\n            ]\n            y_label = \"Pitch Name\"\n        case _:\n            raise ValueError(\"Invalid y_label type\")\n\n    # Plots the graph\n    ax.set_title(title)\n\n    ax.set_xlabel(\"Quarters\" if x_label == \"quarter\" else \"Seconds\")\n    ax.set_ylabel(y_label)\n\n    ax.set_yticks(midi_numbers)\n    ax.set_yticklabels([str(note) for note in notes])\n\n    ax.set_xlim(0, max_time)\n    ax.set_ylim(min(midi_numbers), max(midi_numbers) + 1)\n\n    ax.grid(True)\n\n    if show:\n        plt.show()\n\n    return fig\n</code></pre>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to display</p>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(title)","title":"<code>title</code>","text":"(<code>str</code>, default:                   <code>'Piano Roll'</code> )           \u2013            <p>The title of the plot. Defaults to \"Piano Roll\".</p>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(y_label)","title":"<code>y_label</code>","text":"(<code>str</code>, default:                   <code>'name'</code> )           \u2013            <p>Determines whether the y-axis is labeled with note names or MIDI numbers. Valid Input: 'name' (default) or 'num'.</p>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(x_label)","title":"<code>x_label</code>","text":"(<code>str</code>, default:                   <code>'quarter'</code> )           \u2013            <p>Determines whether the x-axis is labeled with quarters or seconds. Valid input: 'quarter' (default) or 'sec'.</p>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(color)","title":"<code>color</code>","text":"(<code>str</code>, default:                   <code>'skyblue'</code> )           \u2013            <p>The color of the note rectangles. Defaults to 'skyblue'.</p>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(accidental)","title":"<code>accidental</code>","text":"(<code>str</code>, default:                   <code>'sharp'</code> )           \u2013            <p>Determines whether the y-axis is labeled with sharps or flats. Only useful if argument y_label is 'name'. Raises exception on inputs that's not 'sharp', 'flat', or 'both'. Defaults to 'sharp', which is what is done in miditoolbox. 'both' means use AMADS defaults which are C#, Eb, F#, G#, Bb.</p>"},{"location":"reference/io/#amads.io.pianoroll.pianoroll(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default), the plot is displayed.</p>"},{"location":"reference/io/#low-level-input-functions","title":"Low-Level Input Functions","text":""},{"location":"reference/io/#amads.io.m21_midi_import.music21_midi_import","title":"music21_midi_import","text":"<pre><code>music21_midi_import(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Use music21 to import a MIDI file and convert it to a Score.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The converted AMADS Score object.</p> </li> </ul> Source code in <code>amads/io/m21_midi_import.py</code> <pre><code>def music21_midi_import(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"Use music21 to import a MIDI file and convert it to a Score.\n\n    Parameters\n    ----------\n    filename : str\n        The path to the MIDI file.\n    flatten : bool, optional\n        If True, flatten the score structure.\n    collapse : bool, optional\n        If True and flatten is true, also collapse parts.\n    show : bool, optional\n        If True, print the music21 score structure for debugging.\n    group_by_instrument: bool, optional\n        If True, group parts by instrument name into staffs. Defaults to True.\n        See `music21_to_score` for details.\n\n    Returns\n    -------\n    Score\n        The converted AMADS Score object.\n    \"\"\"\n    # Load the MIDI file using music21\n    m21score = converter.parse(\n        filename, format=\"midi\", forceSource=True, quantizePost=False\n    )\n    m21score = cast(m21Score, m21score)\n    score = music21_to_score(\n        m21score,\n        flatten,\n        collapse,\n        show,\n        filename,\n        group_by_instrument=group_by_instrument,\n    )\n    return score\n</code></pre>"},{"location":"reference/io/#amads.io.m21_midi_import.music21_midi_import(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The path to the MIDI file.</p>"},{"location":"reference/io/#amads.io.m21_midi_import.music21_midi_import(flatten)","title":"<code>flatten</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, flatten the score structure.</p>"},{"location":"reference/io/#amads.io.m21_midi_import.music21_midi_import(collapse)","title":"<code>collapse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True and flatten is true, also collapse parts.</p>"},{"location":"reference/io/#amads.io.m21_midi_import.music21_midi_import(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print the music21 score structure for debugging.</p>"},{"location":"reference/io/#amads.io.m21_midi_import.music21_midi_import(group_by_instrument)","title":"<code>group_by_instrument</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, group parts by instrument name into staffs. Defaults to True. See <code>music21_to_score</code> for details.</p>"},{"location":"reference/io/#amads.io.pm_midi_import.pretty_midi_midi_import","title":"pretty_midi_midi_import","text":"<pre><code>pretty_midi_midi_import(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Use PrettyMIDI to import a MIDI file and convert it to a Score.</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The converted Score object containing the imported MIDI data.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from amads.io.pm_midi_import import pretty_midi_midi_import\n&gt;&gt;&gt; from amads.music import example\n&gt;&gt;&gt; score = pretty_midi_midi_import(                     example.fullpath(\"midi/sarabande.mid\"),                     flatten=True)  # show=True to see PrettyMIDI data\n</code></pre> Source code in <code>amads/io/pm_midi_import.py</code> <pre><code>def pretty_midi_midi_import(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"\n    Use PrettyMIDI to import a MIDI file and convert it to a Score.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    filename : Union(str, PosixPath)\n        The path to the MIDI file to import.\n    flatten : bool, optional\n        If True, create a flat score where notes are direct children of\n        parts. Defaults to collapse, which defaults to False.\n    collapse : bool, optional\n        If True, merge all parts into a single part. Implies flatten=True.\n        Defaults to False.\n    show : bool, optional\n        If True, print the PrettyMIDI score structure for debugging.\n        Defaults to False.\n    group_by_instrument : bool, optional\n        If True, group parts by instrument name into staffs. Defaults to True.\n        See read_midi() for more details.\n\n    Returns\n    -------\n    Score\n        The converted Score object containing the imported MIDI data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from amads.io.pm_midi_import import pretty_midi_midi_import\n    &gt;&gt;&gt; from amads.music import example\n    &gt;&gt;&gt; score = pretty_midi_midi_import( \\\n                    example.fullpath(\"midi/sarabande.mid\"), \\\n                    flatten=True)  # show=True to see PrettyMIDI data\n    \"\"\"\n    flatten = flatten or collapse  # collapse implies flatten\n\n    # Load the MIDI file using PrettyMidi\n    filename = str(filename)\n    pmscore = PrettyMIDI(filename)\n    if show:\n        from amads.io.pm_show import pretty_midi_show\n\n        pretty_midi_show(pmscore, filename)\n\n    # Create an empty Score object\n    time_map = _time_map_from_tick_scales(\n        pmscore._tick_scales, pmscore.resolution\n    )\n    score = Score(time_map=time_map)\n    score.convert_to_seconds()  # convert to seconds for PrettyMIDI\n\n    # Iterate over instruments of the PrettyMIDI score and build parts and notes\n    # Then if collapse, merge and sort the notes\n    # Then if not flatten, remove each part content, and staff and measures,\n    # and move notes into measures, creating ties where they cross\n\n    # This helps orgainize parts by instrument name. Parts with the same\n    # instrument name are grouped together as staffs in a single Part.\n    instrument_groups: dict[str, list[Part]] = {}\n\n    # Iterate over instruments of the PrettyMIDI score and build parts and notes\n    duration = 0\n    no_name_id = 1\n    for ins in pmscore.instruments:\n        name = ins.name\n        if not ins.name:\n            name = program_to_instrument_name(ins.program)\n        if name == \"Unknown\":  # AMADS uses \"Unknown\" to represent None.\n            # Of course, if a user really names an instrument \"Unknown\",\n            # that particular name will not be stored in the Part.\n            name = None\n\n        part = Part(parent=score, onset=0.0, instrument=name)\n\n        # now that we've put the name in the Part, change None to a unique name\n        # so that we can make the part a named instrument group. If we are not\n        # grouping by instrument, we want each part in its own group, so we\n        # give each part a unique name in that case too.\n        if name is None or not group_by_instrument:\n            name = f\"_None~@_{no_name_id}\"  # something unlikely to be a name\n            no_name_id += 1\n        group = instrument_groups.get(name, [])\n        group.append(part)\n        instrument_groups[name] = group\n\n        for note in ins.notes:\n            # Create a Note object and associate it with the Part\n            Note(\n                parent=part,\n                onset=note.start,\n                duration=note.get_duration(),\n                pitch=Pitch(note.pitch),\n                dynamic=note.velocity,\n            )\n            duration = max(duration, note.end)\n        assert not has_staff(\n            part\n        ), \"Part should not have Staffs before flattening\"\n\n    score.duration = duration\n    for part in score.content:\n        part.duration = duration  # all parts get same max duration\n        assert not has_staff(part), \"Part should not have Staffs\"\n\n    # Then if collapse, merge and sort the notes\n    if collapse:\n        score = score.flatten(collapse=True)\n\n    score.convert_to_quarters()  # we want to return with quarters as time unit\n\n    # TODO: remove this block\n    for groups in instrument_groups.values():\n        for part in groups:\n            assert not has_staff(part), \"Part should not have Staffs 2\"\n\n    # Then if not flatten, remove each part content, and staff and measures,\n    # and move notes into measures, creating ties where they cross. This maybe\n    # does some extra work if not grouping by instrument, because we already\n    # have the right set of parts, but the real work here is creating the staffs\n    # and measures, and moving notes into measures with ties, so we have\n    # eliminated the small extra work of copying parts when not grouping.\n    if not flatten:\n        score.content.clear()  # remove parts from score\n        for group in instrument_groups.values():\n            new_part = group[0].insert_emptycopy_into(score)\n            new_part = cast(Part, new_part)\n            new_part.duration = score.duration\n            for old_part in group:\n                assert not has_staff(\n                    old_part\n                ), \"Part should not have Staffs before creating staffs\"\n                old_part = cast(Part, old_part)\n                notes = old_part.content\n                # now notes have part as parent, but parent does not have notes\n                staff = Staff(\n                    parent=new_part, onset=0.0, duration=new_part.duration\n                )\n                # in principle we could do this once for the first staff and\n                # then copy the created staff with measures for any other\n                # staff, but then we would have to save off the notes and\n                # write another loop to insert each note list to a corresponding\n                # staff. Besides, _create_measures might even be faster than\n                # calling deepcopy on a Staff to copy the measures.\n                _create_measures(staff, score.time_map, pmscore)\n                notes = cast(\n                    list[Note], notes\n                )  # tell type checker notes is list of Note\n                _add_notes_to_measures(\n                    notes,\n                    cast(list[Measure], staff.content),\n                    pmscore.resolution,\n                )\n                old_part.content.clear()  # clean up\n\n    return score\n</code></pre>"},{"location":"reference/io/#amads.io.pm_midi_import.pretty_midi_midi_import(filename)","title":"<code>filename</code>","text":"(<code>Union(str, PosixPath)</code>)           \u2013            <p>The path to the MIDI file to import.</p>"},{"location":"reference/io/#amads.io.pm_midi_import.pretty_midi_midi_import(flatten)","title":"<code>flatten</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, create a flat score where notes are direct children of parts. Defaults to collapse, which defaults to False.</p>"},{"location":"reference/io/#amads.io.pm_midi_import.pretty_midi_midi_import(collapse)","title":"<code>collapse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, merge all parts into a single part. Implies flatten=True. Defaults to False.</p>"},{"location":"reference/io/#amads.io.pm_midi_import.pretty_midi_midi_import(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print the PrettyMIDI score structure for debugging. Defaults to False.</p>"},{"location":"reference/io/#amads.io.pm_midi_import.pretty_midi_midi_import(group_by_instrument)","title":"<code>group_by_instrument</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, group parts by instrument name into staffs. Defaults to True. See read_midi() for more details.</p>"},{"location":"reference/io/#amads.io.m21_xml_import.music21_xml_import","title":"music21_xml_import","text":"<pre><code>music21_xml_import(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Use music21 to import a MusicXML file and convert it to a Score.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The converted AMADS Score object.</p> </li> </ul> Source code in <code>amads/io/m21_xml_import.py</code> <pre><code>def music21_xml_import(\n    filename: str,\n    flatten: bool = False,\n    collapse: bool = False,\n    show: bool = False,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"\n    Use music21 to import a MusicXML file and convert it to a Score.\n\n    Parameters\n    ----------\n    filename : str\n        The path to the MusicXML file.\n    flatten : bool, optional\n        If True, flatten the score structure.\n    collapse : bool, optional\n        If True and flatten is true, also collapse parts.\n    show : bool, optional\n        If True, print the music21 score structure for debugging.\n    group_by_instrument : bool, optional\n        If True, group parts by instrument name into staffs. Defaults to True.\n        See music21_to_score() for more details.\n\n    Returns\n    -------\n    Score\n        The converted AMADS Score object.\n    \"\"\"\n    # Load the MusicXML file using music21\n    m21score = converter.parse(filename, format=\"xml\")\n\n    # m21score can be an Opus, but this is checked in music21_to_score, so we\n    # can ignore the type error here:\n    score = music21_to_score(\n        m21score,\n        flatten,\n        collapse,\n        show,  # type: ignore\n        group_by_instrument=group_by_instrument,\n    )\n    return score\n</code></pre>"},{"location":"reference/io/#amads.io.m21_xml_import.music21_xml_import(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The path to the MusicXML file.</p>"},{"location":"reference/io/#amads.io.m21_xml_import.music21_xml_import(flatten)","title":"<code>flatten</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, flatten the score structure.</p>"},{"location":"reference/io/#amads.io.m21_xml_import.music21_xml_import(collapse)","title":"<code>collapse</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True and flatten is true, also collapse parts.</p>"},{"location":"reference/io/#amads.io.m21_xml_import.music21_xml_import(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print the music21 score structure for debugging.</p>"},{"location":"reference/io/#amads.io.m21_xml_import.music21_xml_import(group_by_instrument)","title":"<code>group_by_instrument</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, group parts by instrument name into staffs. Defaults to True. See music21_to_score() for more details.</p>"},{"location":"reference/io/#amads.io.pt_xml_import.partitura_xml_import","title":"partitura_xml_import","text":"<pre><code>partitura_xml_import(\n    filename,\n    flatten=False,\n    collapse=False,\n    show=False,\n    group_by_instrument: bool = True,\n) -&gt; Score\n</code></pre> <p>Use Partitura to import a MusicXML file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>The imported Score</p> </li> <li> <code>&lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;</code>           \u2013            </li> </ul> Source code in <code>amads/io/pt_xml_import.py</code> <pre><code>def partitura_xml_import(\n    filename,\n    flatten=False,\n    collapse=False,\n    show=False,\n    group_by_instrument: bool = True,\n) -&gt; Score:\n    \"\"\"Use Partitura to import a MusicXML file.\n\n    Parameters\n    ----------\n    filename : str\n        The path (relative or absolute) to the music file.\n    flatten : bool = False\n        Returns a flat score (see `amads.core.basics.Part.flatten`)\n    collapse : bool = False\n        If `flatten` is True, all Notes are merged (collapsed) into\n        a single Part in the resulting Score.\n    show : bool = False\n        Print a text representation of the data.\n    group_by_instrument : bool = True\n        This parameter is ignored by Partitura, which automatically\n        produces parts with multiple staffs. The Partitura grouping\n        is respected, and `group_by_instrument` is ignored.\n\n    Returns\n    -------\n    Score\n        The imported Score\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n    \"\"\"\n    if filename is None:\n        filename = pt.EXAMPLE_MUSICXML\n\n    # Partitura.load_score claims to accept a file-like object, but\n    # it has been problematic for us in the past, so we use a string filename.\n    filename = str(filename)\n\n    ptscore = pt.load_score(filename)\n    if show:\n        print(f\"Partitura score structure from {filename}:\")\n        for ptpart in ptscore:\n            print(ptpart.pretty())\n    score = Score()\n    for ptpart in ptscore.parts:\n        partitura_convert_part(ptpart, score)\n    score.inherit_duration()\n    if flatten or collapse:\n        score = score.flatten(collapse=collapse)\n    return score\n</code></pre>"},{"location":"reference/io/#amads.io.pt_xml_import.partitura_xml_import(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The path (relative or absolute) to the music file.</p>"},{"location":"reference/io/#amads.io.pt_xml_import.partitura_xml_import(flatten)","title":"<code>flatten</code>","text":"(<code>bool = False</code>, default:                   <code>False</code> )           \u2013            <p>Returns a flat score (see <code>amads.core.basics.Part.flatten</code>)</p>"},{"location":"reference/io/#amads.io.pt_xml_import.partitura_xml_import(collapse)","title":"<code>collapse</code>","text":"(<code>bool = False</code>, default:                   <code>False</code> )           \u2013            <p>If <code>flatten</code> is True, all Notes are merged (collapsed) into a single Part in the resulting Score.</p>"},{"location":"reference/io/#amads.io.pt_xml_import.partitura_xml_import(show)","title":"<code>show</code>","text":"(<code>bool = False</code>, default:                   <code>False</code> )           \u2013            <p>Print a text representation of the data.</p>"},{"location":"reference/io/#amads.io.pt_xml_import.partitura_xml_import(group_by_instrument)","title":"<code>group_by_instrument</code>","text":"(<code>bool = True</code>, default:                   <code>True</code> )           \u2013            <p>This parameter is ignored by Partitura, which automatically produces parts with multiple staffs. The Partitura grouping is respected, and <code>group_by_instrument</code> is ignored.</p>"},{"location":"reference/io/#low-level-output-functions","title":"Low-Level Output Functions","text":""},{"location":"reference/io/#amads.io.m21_midi_export.music21_midi_export","title":"music21_midi_export","text":"<pre><code>music21_midi_export(\n    score: Score, filename: str, show: bool = False\n) -&gt; None\n</code></pre> <p>Save a Score to a file in MIDI format using music21.</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> Source code in <code>amads/io/m21_midi_export.py</code> <pre><code>def music21_midi_export(\n    score: Score,\n    filename: str,\n    show: bool = False,\n) -&gt; None:\n    \"\"\"Save a Score to a file in MIDI format using music21.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The Score to export.\n    filename : str\n        The name of the file to save the MIDI data.\n    show : bool, optional\n        If True, print the music21 score structure for debugging.\n    \"\"\"\n    m21score = score_to_music21(score, show, filename)\n    m21score.write(\"midi\", filename)\n</code></pre>"},{"location":"reference/io/#amads.io.m21_midi_export.music21_midi_export(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The Score to export.</p>"},{"location":"reference/io/#amads.io.m21_midi_export.music21_midi_export(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The name of the file to save the MIDI data.</p>"},{"location":"reference/io/#amads.io.m21_midi_export.music21_midi_export(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print the music21 score structure for debugging.</p>"},{"location":"reference/io/#amads.io.pm_midi_export.pretty_midi_midi_export","title":"pretty_midi_midi_export","text":"<pre><code>pretty_midi_midi_export(\n    score: Score, filename: str, show: bool = False\n) -&gt; None\n</code></pre> <p>Export a Score as a standard MIDI file using PrettyMIDI library.</p> <p>Parameters:</p> Source code in <code>amads/io/pm_midi_export.py</code> <pre><code>def pretty_midi_midi_export(\n    score: Score, filename: str, show: bool = False\n) -&gt; None:\n    \"\"\"\n    Export a Score as a standard MIDI file using PrettyMIDI library.\n\n    Parameters\n    ----------\n    score : Score\n        The Score object to export.\n    filename : str\n        The path to the output MIDI file.\n    show : bool\n        Print a text representation of the data.\n    \"\"\"\n    global tied_to_notes  # helps to merge tied notes\n    tied_to_notes = {}\n\n    score.convert_to_seconds()\n    score.merge_tied_notes()\n\n    # 600 gives 1 ms resolution at 100 bpm\n    pmscore = pm.PrettyMIDI(resolution=600)\n\n    # Create tempo changes from TimeMap\n    tm = score.time_map\n    if tm is not None:\n        tick_scales = []\n        for i in range(len(tm.changes)):\n            bpm = tm.get_tempo_at(i)\n            resolution = pmscore.resolution\n            # form breakpoints with units of (ticks, seconds/tick)\n            tick_scale = 60.0 / (bpm * resolution)\n            tick_scales.append(\n                (int(tm.changes[i].quarter * resolution), tick_scale)\n            )\n        pmscore._tick_scales = tick_scales\n\n    # We want to write every Part or Staff as a separate PrettyMIDI Instrument\n    # Gather the EventGroups to write. Note that the reader may reconstruct\n    # The Part/Staff hierarchy if all Parts have different instruments and\n    # read_score is invoked with the default group_by_instrument=True.\n    evgroups: list[Part | Staff] = []\n    for part in score.find_all(Part):  # type: ignore\n        # search Part for any Notes at the top level\n        part = cast(Part, part)\n        if any(isinstance(ev, Note) for ev in part.content):\n            evgroups.append(part)\n        # search for Staffs within Part\n        for staff in part.find_all(Staff):\n            staff = cast(Staff, staff)\n            evgroups.append(staff)\n    key_signatures = []  # Collect key signatures for pmscore\n\n    # Create instruments and add notes\n    for evgroup in evgroups:\n        # determine a name for the pm.Instrument\n        if isinstance(evgroup, Part):\n            part: Part = evgroup\n        else:\n            part = evgroup.part  # type: ignore\n        name = part.instrument\n        program = part.get(\"midi_program\")\n        if name is not None and program is None:\n            try:\n                program = pm.instrument_name_to_program(name)\n            except Exception:\n                program = None\n        if program is None:\n            program = 0  # Acoustic Grand Piano as default\n        instrument = pm.Instrument(\n            program, name=name if name is not None else \"Unknown\"\n        )\n\n        add_eventgroup_to_instrument(evgroup, instrument, key_signatures)\n        pmscore.instruments.append(instrument)\n\n    # Create time signature changes\n    for ts in score.time_signatures:\n        # Convert onset (in quarters) to seconds using time_map\n        time_in_seconds = score.time_map.quarter_to_time(ts.time)\n        pm_ts = pm.TimeSignature(\n            numerator=int(ts.upper),\n            denominator=int(ts.lower),\n            time=time_in_seconds,\n        )\n        pmscore.time_signature_changes.append(pm_ts)\n\n    # Add key signatures to pmscore\n    pmscore.key_signature_changes = key_signatures\n\n    # Force pretty_midi to use custom _tick_scales before writing:\n    _ = pmscore.get_end_time()\n\n    if show:\n        from amads.io.pm_show import pretty_midi_show\n\n        pretty_midi_show(pmscore, filename)\n\n    # Write to MIDI file\n    pmscore.write(filename)\n    tied_to_notes = None  # clear global variable after use\n</code></pre>"},{"location":"reference/io/#amads.io.pm_midi_export.pretty_midi_midi_export(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The Score object to export.</p>"},{"location":"reference/io/#amads.io.pm_midi_export.pretty_midi_midi_export(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The path to the output MIDI file.</p>"},{"location":"reference/io/#amads.io.pm_midi_export.pretty_midi_midi_export(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Print a text representation of the data.</p>"},{"location":"reference/io/#amads.io.m21_xml_export.music21_xml_export","title":"music21_xml_export","text":"<pre><code>music21_xml_export(\n    score: Score, filename: str, show: bool = False\n) -&gt; None\n</code></pre> <p>Save a Score to a file in musicxml format using music21.</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> Source code in <code>amads/io/m21_xml_export.py</code> <pre><code>def music21_xml_export(\n    score: Score,\n    filename: str,\n    show: bool = False,\n) -&gt; None:\n    \"\"\"Save a Score to a file in musicxml format using music21.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The Score to export.\n    filename : str\n        The name of the file to save the MusicXML data.\n    show : bool, optional\n        If True, print the music21 score structure for debugging.\n\n    \"\"\"\n    m21score = score_to_music21(score, show, filename)\n\n    # Export as text and fix part id's\n    exporter = musicxml.m21ToXml.GeneralObjectExporter(m21score)\n    musicxml_bytes = exporter.parse()\n    musicxml_str = musicxml_bytes.decode(\"utf-8\")\n    fixed_xml = fix_part_ids(musicxml_str)\n\n    # Finally, write the file\n    with open(filename, \"w\") as f:\n        f.write(fixed_xml)\n</code></pre>"},{"location":"reference/io/#amads.io.m21_xml_export.music21_xml_export(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The Score to export.</p>"},{"location":"reference/io/#amads.io.m21_xml_export.music21_xml_export(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The name of the file to save the MusicXML data.</p>"},{"location":"reference/io/#amads.io.m21_xml_export.music21_xml_export(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print the music21 score structure for debugging.</p>"},{"location":"reference/io/#amads.io.pt_xml_export.partitura_xml_export","title":"partitura_xml_export","text":"<pre><code>partitura_xml_export(\n    score: Score, filename: str, show: bool = False\n) -&gt; None\n</code></pre> <p>Save a Score to a file in musicxml format using Partitura.</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> Source code in <code>amads/io/pt_xml_export.py</code> <pre><code>def partitura_xml_export(\n    score: Score,\n    filename: str,\n    show: bool = False,\n) -&gt; None:\n    \"\"\"Save a Score to a file in musicxml format using Partitura.\n\n    &lt;small&gt;**Author**: Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The Score to export.\n    filename : str\n        The name of the file to save the MusicXML data.\n    show : bool, optional\n        If True, print the partitura score structure for debugging.\n\n    \"\"\"\n    ptscore = score_to_partitura(score, filename, show)\n    save_musicxml(ptscore, filename)\n</code></pre>"},{"location":"reference/io/#amads.io.pt_xml_export.partitura_xml_export(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The Score to export.</p>"},{"location":"reference/io/#amads.io.pt_xml_export.partitura_xml_export(filename)","title":"<code>filename</code>","text":"(<code>str</code>)           \u2013            <p>The name of the file to save the MusicXML data.</p>"},{"location":"reference/io/#amads.io.pt_xml_export.partitura_xml_export(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, print the partitura score structure for debugging.</p>"},{"location":"reference/io/#built-in-scores","title":"Built-In Scores","text":""},{"location":"reference/io/#amads.music.example","title":"example","text":"<p>Functions:</p> <ul> <li> <code>fullpath</code>             \u2013              <p>Construct a full path name for an example file.</p> </li> </ul>"},{"location":"reference/io/#amads.music.example-functions","title":"Functions","text":""},{"location":"reference/io/#amads.music.example.fullpath","title":"fullpath","text":"<pre><code>fullpath(example: str) -&gt; str | None\n</code></pre> <p>Construct a full path name for an example file. For example, fullpath(\"midi/sarabande.mid\") returns a path to a readable file from this package.  This uses importlib so that we can read files even from compressed packages (we hope).</p> Source code in <code>amads/music/example.py</code> <pre><code>def fullpath(example: str) -&gt; str | None:\n    \"\"\"Construct a full path name for an example file.\n    For example, fullpath(\"midi/sarabande.mid\") returns a path to a\n    readable file from this package.  This uses importlib so that\n    we can read files even from compressed packages (we hope).\n    \"\"\"\n\n    def trim_path(full: str) -&gt; str:\n        \"\"\"remove first part of path to construct valid parameter value\"\"\"\n        first_part = \"amads/music/\"\n        index = full.find(first_part)\n        return full if index == -1 else full[index + len(first_part) :]\n\n    path = str(resources.files(\"amads\").joinpath(\"music/\" + example))\n\n    if os.path.isfile(path) and os.access(path, os.R_OK):\n        return path\n\n    print(\"In amads.example.fullpath(\" + example + \"):\")\n    print(\"    File was not found. Try one of these:\")\n\n    spec = util.find_spec(\"amads\")\n    if spec is None:\n        print(\"Error: Package amads not found\")\n        return None\n    if spec.submodule_search_locations is None:\n        print(\"Error: Package amads has no submodule search locations\")\n        return None\n    package_path = spec.submodule_search_locations[0]\n\n    # Walk through the directory hierarchy\n    for root, dirs, files in os.walk(package_path):\n        for file in files:\n            for ext in music_extensions:\n                if file.endswith(ext):\n                    parameter_option = trim_path(os.path.join(root, file))\n                    print(f'   \"{parameter_option}\"')\n    return None\n</code></pre>"},{"location":"reference/pitch/","title":"Pitch","text":""},{"location":"reference/pitch/#amads.core.pitch.Pitch","title":"Pitch","text":"<pre><code>Pitch(\n    pitch: Pitch | int | float | str | None = 60,\n    alt: int | float | None = None,\n    octave: int | None = None,\n    accidental_chars: str | None = None,\n)\n</code></pre> <p>Represents a symbolic musical pitch.</p> <p>A pitch is represented by a <code>key_num</code> and an <code>alt</code>. The <code>key_num</code> is a number that corresponds to the MIDI convention where C4 is 60, C# is 61, etc., but generalized to floats (60.5 would be C4-quarter-tone-sharp). The <code>alt</code> is an alteration, where +1 represents a sharp and -1 represents a flat. Alterations can also be, for example, 2 (double-sharp) or -0.5 (quarter-tone flat). The symbolic note name is derived by subtracting <code>alt</code> from <code>key_num</code>.</p> <p>E.g., C#4 has <code>key_num=61</code>, <code>alt=1</code>, so 61-1 gives us 60, corresponding to note name C. A Db has the same <code>key_num=61</code>, but alt=-1, and 61-(-1) gives us 62, corresponding to note name D. There is no representation for the \u201cnatural sign\u201d (other than <code>alt=0</code>, which could imply no accidental) or \u201ccourtesy accidentals.\u201d  Because accidentals normally \u201cstick\u201d within a measure or are implied by key signatures, accidentals are often omitted in the score presentation. Nonetheless, these implied accidentals are encoded in the <code>alt</code> attribute and <code>key_num</code> is the intended pitch with the accidental applied.</p> <p>Author: Roger B. Dannenberg</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>key_num</code>               (<code>float</code>)           \u2013            <p>MIDI key number, e.g., C4 = 60, generalized to float.</p> </li> <li> <code>alt</code>               (<code>float</code>)           \u2013            <p>Alteration, e.g., flat = -1.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; p = Pitch(64)\n&gt;&gt;&gt; p\nPitch(name='E4', key_num=64)\n</code></pre> <pre><code>&gt;&gt;&gt; p.octave\n4\n</code></pre> <pre><code>&gt;&gt;&gt; p = Pitch(\"E4\")\n&gt;&gt;&gt; p.octave\n4\n</code></pre> <pre><code>&gt;&gt;&gt; p = Pitch(\"F#################2\")\n&gt;&gt;&gt; p.alt\n17\n</code></pre> <pre><code>&gt;&gt;&gt; p.octave\n2\n</code></pre> <pre><code>&gt;&gt;&gt; p = Pitch(\"E--------------------4\")\n&gt;&gt;&gt; p.alt\n-20\n</code></pre> <pre><code>&gt;&gt;&gt; p.octave\n4\n</code></pre> <pre><code>&gt;&gt;&gt; p.register\n2\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(61.5, alt=1.5)\nPitch(name='C?4', key_num=61.5)\n</code></pre> <pre><code>&gt;&gt;&gt; # key_num - alt must be a diatonic pitch number. If not, key_num\n&gt;&gt;&gt; # gets priority and alt is adjusted to the smallest valid value.\n&gt;&gt;&gt; # Here, alt is adjusted to 0, which preserves key_num 60:\n&gt;&gt;&gt; Pitch(60, alt=1.4)\nPitch(name='C4', key_num=60)\n</code></pre> <p>Methods:</p> <ul> <li> <code>as_tuple</code>             \u2013              <p>Return a tuple representation of the <code>Pitch</code> instance.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Check equality of other to a Pitch instance.</p> </li> <li> <code>__hash__</code>             \u2013              <p>Return a hash value for the Pitch instance.</p> </li> <li> <code>__lt__</code>             \u2013              <p>Check if this Pitch instance is less than another Pitch instance.</p> </li> <li> <code>from_name</code>             \u2013              <p>Converts a string like \"Bb\" to a (pitch, alt) tuple.</p> </li> <li> <code>get_name</code>             \u2013              <p>Return string name including accidentals (# or b) but no octave.</p> </li> <li> <code>get_name_with_octave</code>             \u2013              <p>Return string name with octave, e.g., C4, B#3, etc.</p> </li> <li> <code>enharmonic</code>             \u2013              <p>Construct an enharmonic equivalent.</p> </li> <li> <code>simplest_enharmonic</code>             \u2013              <p>Create Pitch object with the simplest enharmonic representation.</p> </li> <li> <code>upper_enharmonic</code>             \u2013              <p>Return the enharmonic based on the note name above.</p> </li> <li> <code>lower_enharmonic</code>             \u2013              <p>Return the enharmonic based on the note name below.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def __init__(self,\n             pitch: Union[\"Pitch\", int, float, str, None] = 60,\n             alt: Union[int, float, None] = None,\n             octave: Union[int, None] = None,\n             accidental_chars: Optional[str] = None):\n    if isinstance(pitch, str):\n        if alt is not None:\n            raise ValueError(\"If pitch is a string, alt must be None\")\n        self.key_num, self.alt = Pitch.from_name(pitch, octave, \n                                                 accidental_chars)\n    elif isinstance(pitch, Pitch):\n        self.key_num = pitch.key_num\n        self.alt = pitch.alt\n    elif pitch is None:\n        self.key_num = None  # type: ignore (None is allowed, but if we put\n        # that in the type annotation, we have to annotate every use of\n        # arithmetic on key_num.)\n        self.alt = (0 if alt is None else alt)\n    else:  # pitch is a number (int or float)\n        # this will raise a ValueError if pitch is not some kind of number:\n        pitch = float(pitch)  # converts numpy.int64, nympy.floating, etc.\n        if pitch.is_integer():  # for nicer printing\n            pitch = int(pitch)  # pitch numbers as integers.\n        self.key_num = pitch\n        self.alt = (0 if alt is None else alt)\n        self._fix_alteration()\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch(pitch)","title":"<code>pitch</code>","text":"(<code>int | float | str | None</code>, default:                   <code>60</code> )           \u2013            <p>Optional MIDI key_num or string Pitch name. Syntax is A-G followed by accidentals (see <code>accidental_chars</code> below) followed by octave number. (Defaults to 60)</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch(alt)","title":"<code>alt</code>","text":"(<code>int | float | None</code>, default:                   <code>None</code> )           \u2013            <p>If pitch is a number, alt is an optional alteration (Defaults to 0). If <code>pitch - alt</code> does not result in a diatonic pitch number, alt is adjusted, normally choosing spellings C#, Eb, F#, Ab, and Bb. If pitch is a string, alt must be None.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch(octave)","title":"<code>octave</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If pitch is a string without an octave specification and <code>octave</code> is an int, then <code>octave</code> is used to specify the octave, where 4 denotes the <code>key_num</code> range 60 through 71. <code>octave</code> defaults defaults to -1, which yields pitch class <code>key_num</code>s 0-11).</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch(accidental_chars)","title":"<code>accidental_chars</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Allows parsing of pitch names with customized accidental characters. The value is a tuple or list consisting of a string of flat characters and a string of sharp characters, e.g. `[\"fb\", \"s#\"]. (Defaults to None, which admits '\u266d', 'b' or '-' for flat, and '\u266f', '#', and '+' for sharp, but does not accept 'f' and 's'.)</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch-attributes","title":"Attributes","text":""},{"location":"reference/pitch/#amads.core.pitch.Pitch.step","title":"step  <code>property</code>","text":"<pre><code>step: str\n</code></pre> <p>The diatonic name of the pitch: A, B, C, D, E, F, or G.</p> <p>The diatonic name corresponds to letter name without accidentals.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The name of the pitch, a letter in \"A\" through \"G\".</p> </li> </ul>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.name","title":"name  <code>property</code>","text":"<pre><code>name: str\n</code></pre> <p>The string name including accidentals (# or b).</p> <p>The octave number is omitted. If alt is not an integer, return the step name concatenated with \"?\". See also get_name, which accepts a parameter to specify accidental characters.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.name_with_octave","title":"name_with_octave  <code>property</code>","text":"<pre><code>name_with_octave: str\n</code></pre> <p>The string name with octave, e.g., \"C4\", \"B#3\", etc.</p> <p>The octave number is calculated by</p> <pre><code>(key_num - alteration) // 12 + 1  # (integer division)\n</code></pre> <p>and refers to the pitch before alteration, e.g., C4 is enharmonic to B#3 and represents the same (more or less) pitch even though the written octave numbers differ.</p> <p>See also get_name_with_octave, which accepts a parameter to specify custom characters to represent accidentals.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.octave","title":"octave  <code>property</code>","text":"<pre><code>octave: int\n</code></pre> <p>The octave number of the note name.</p> <p>The note name is based on <code>key_num - alt</code>, e.g., C4 has octave 4 while B#3 has octave 3.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.pitch_class","title":"pitch_class  <code>property</code>","text":"<pre><code>pitch_class: int\n</code></pre> <p>The pitch class of the note, e.g., 0, 1, 2, ..., 11.</p> <p>The pitch class is the <code>key_num modulo 12</code>, which gives the class of this pitch in the range 0-11. If the <code>key_num</code> is non-integer, it is rounded.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The pitch class of the note.</p> </li> </ul>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.register","title":"register  <code>property</code>","text":"<pre><code>register: int\n</code></pre> <p>Returns the absolute octave number based on <code>floor(key_num)</code>.</p> <p>Both C4 and B#3 have register 4.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch-functions","title":"Functions","text":""},{"location":"reference/pitch/#amads.core.pitch.Pitch.as_tuple","title":"as_tuple","text":"<pre><code>as_tuple()\n</code></pre> <p>Return a tuple representation of the <code>Pitch</code> instance.</p> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple containing the <code>key_num</code> and <code>alt</code> values.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def as_tuple(self):\n    \"\"\"Return a tuple representation of the `Pitch` instance.\n\n    Returns\n    -------\n    tuple\n        A tuple containing the `key_num` and `alt` values.\n    \"\"\"\n    return (self.key_num, self.alt)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Check equality of other to a Pitch instance.</p> <p>Pitches are equal if they are both Pitches, and both <code>key_num</code> and <code>alt</code> are equal. Enharmonics are therefore not equal, but enharmonic equivalence can be written simply as <code>p1.key_num == p2.key_num</code></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the <code>key_num</code> and <code>alt</code> values are equal, False otherwise.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Check equality of other to a Pitch instance.\n\n    Pitches are equal if they are both Pitches, and\n    both `key_num` and `alt` are equal. Enharmonics are therefore\n    not equal, but enharmonic equivalence can be written simply as\n    `p1.key_num == p2.key_num`\n\n    Parameters\n    ----------\n    other : Pitch\n        The other Pitch instance to compare with.\n\n    Returns\n    -------\n    bool\n        True if the `key_num` and `alt` values are equal, False otherwise.\n    \"\"\"\n    return isinstance(other, Pitch) and self.as_tuple() == other.as_tuple()\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.__eq__(other)","title":"<code>other</code>","text":"(<code>Pitch</code>)           \u2013            <p>The other Pitch instance to compare with.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.__hash__","title":"__hash__","text":"<pre><code>__hash__() -&gt; int\n</code></pre> <p>Return a hash value for the Pitch instance.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>A hash value representing the Pitch instance.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def __hash__(self) -&gt; int:\n    \"\"\"Return a hash value for the Pitch instance.\n\n    Returns\n    -------\n    int\n        A hash value representing the Pitch instance.\n    \"\"\"\n    return hash(self.as_tuple())\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.__lt__","title":"__lt__","text":"<pre><code>__lt__(other) -&gt; bool\n</code></pre> <p>Check if this Pitch instance is less than another Pitch instance. Pitches are compared first by <code>key_num</code> and then by <code>alt</code>. Pitches with sharps (i.e. positive alt) are considered lower because their letter names are lower in the musical alphabet.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if this Pitch instance is less than the other, False otherwise.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def __lt__(self, other) -&gt; bool:\n    \"\"\"Check if this Pitch instance is less than another Pitch instance.\n    Pitches are compared first by `key_num` and then by `alt`. Pitches\n    with sharps (i.e. positive alt) are considered lower because\n    their letter names are lower in the musical alphabet.\n\n    Parameters\n    ----------\n    other : Pitch\n        The other Pitch instance to compare with.\n\n    Returns\n    -------\n    bool\n        True if this Pitch instance is less than the other, False otherwise.\n    \"\"\"\n    return (self.key_num, -self.alt) &lt; (other.key_num, -other.alt)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.__lt__(other)","title":"<code>other</code>","text":"(<code>Pitch</code>)           \u2013            <p>The other Pitch instance to compare with.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(\n    name: str,\n    octave: float | None = -1,\n    accidental_chars: str | None = None,\n) -&gt; tuple[float, float]\n</code></pre> <p>Converts a string like \"Bb\" to a (pitch, alt) tuple.</p> <p>For example, converts \"Bb\" to (10, -1). If the string has an octave number or octave is given, the octave will be applied, e.g., \"C4\" yields (60, 0). <code>octave</code> takes effect if it is a number and name does not include an octave. If both <code>name</code> has no octave and <code>octave</code> is None, the octave is -1, yielding pitch class numbers 0-11.</p> <p>The first character must be one of the unmodified base pitch names: C, D, E, F, G, A, B (not case-sensitive).</p> <p>Subsequent characters must indicate a single accidental type: one of '\u266d', 'b' or '-' for flat, and '\u266f', '#', and '+' for sharp, unless accidental_chars specified exactly the acceptable flat and sharp chars, e.g., \"fs\" indicates 'f' for flat, 's' for sharp.</p> <p>Note that 's' is not a default accidental type as it is ambiguous: 'Fs' probably indicates F#, but Es is more likely Eb (German).</p> <p>Also unsupported are: mixtures of sharps and flats (e.g., B#b); symbols for double sharps, quarter sharps, naturals, etc.; any other characters (except space, tab and underscore, which are allowed but ignored).</p> <p>Following accidentals (if any) is an optional single-digit octave number. Note that MIDI goes below C0; if the octave number is omitted, the octave will be -1, which corresponds to pitch class numbers 0-11 and octave -1 (which you can also specify as octave).</p> <p>Instructive error messages are given for invalid input.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float]</code>           \u2013            <p>A tuple containing the <code>key_num</code> and <code>alt</code> values.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>@classmethod\ndef from_name(cls, name: str,\n              octave: Optional[float] = -1,\n              accidental_chars: Optional[str] = None\n              ) -&gt; Tuple[float, float]:\n    \"\"\"\n    Converts a string like \"Bb\" to a (pitch, alt) tuple.\n\n    For example, converts \"Bb\" to (10, -1).\n    If the string has an octave number or octave is given, the\n    octave will be applied, e.g., \"C4\" yields (60, 0). `octave` takes\n    effect if it is a number and name does not include an octave.\n    If both `name` has no octave and `octave` is None, the octave is\n    -1, yielding pitch class numbers 0-11.\n\n    The first character must be one of the unmodified base pitch names:\n    C, D, E, F, G, A, B (not case-sensitive).\n\n    Subsequent characters must indicate a single accidental type:\n    one of '\u266d', 'b' or '-' for flat, and '\u266f', '#', and '+' for sharp,\n    unless accidental_chars specified exactly the acceptable flat\n    and sharp chars, e.g., \"fs\" indicates 'f' for flat, 's' for sharp.\n\n    Note that 's' is not a default accidental type as it is ambiguous:\n    'Fs' probably indicates F#, but Es is more likely Eb (German).\n\n    Also unsupported are:\n    mixtures of sharps and flats (e.g., B#b);\n    symbols for double sharps, quarter sharps, naturals, etc.;\n    any other characters (except space, tab and underscore,\n    which are allowed but ignored).\n\n    Following accidentals (if any) is an optional single-digit octave\n    number. Note that MIDI goes below C0; if the octave number is\n    omitted, the octave will be -1, which corresponds to pitch class\n    numbers 0-11 and octave -1 (which you can also specify as octave).\n\n    Instructive error messages are given for invalid input.\n\n    Parameters\n    ----------\n    name : str\n        The string representation of the pitch name.\n    octave : Optional[float], optional\n        The octave number if not specified in the name.\n        (Defaults to -1)\n    accidental_chars : Optional[str], optional\n        The characters to use for flat and sharp accidentals.\n        (Defaults to None, which admits '\u266d', 'b' or '-' for flat, and\n        '\u266f', '#', and '+' for sharp.)\n\n    Returns\n    -------\n    Tuple[float, float]\n        A tuple containing the `key_num` and `alt` values.\n    \"\"\"\n    name = name.replace(\" \", \"\").replace(\"\\t\", \"\").replace(\"_\", \"\")\n    if name == \"\":\n        return 60, 0\n    pitch_base = name[0].upper()  # error if non-string\n    if pitch_base not in \"ABCDEFG\":\n        raise ValueError(\"Invalid first character: must be one of ABCDEFG\")\n    pitch_class = LETTER_TO_NUMBER[pitch_base]\n\n    name = name[1:]  # trim the note letter\n    if len(name) &gt; 0:\n        if name[-1].isdigit():  # final character indicates octave\n            octave = int(name[-1])  # overrides octave parameter\n            name = name[:-1]  # remove octave from working\n    if octave is None:  # no octave given in name or 2nd parameter\n        octave = -1\n\n    # parse the accidentals, if any\n    if accidental_chars:\n        flat_chars = [accidental_chars[0]]\n        sharp_chars = [accidental_chars[1]]\n    else:\n        flat_chars = [\"\u266d\", \"b\", \"-\"]\n        sharp_chars = [\"\u266f\", \"#\", \"+\"]\n    if all(x in flat_chars for x in name):  # flats\n        alteration = -len(name)\n    elif all(x in sharp_chars for x in name):  # sharps\n        alteration = len(name)\n    else:\n        raise ValueError(\"Invalid accidentals: must be only \" +\n                         f\"{flat_chars} or {sharp_chars}.\")\n\n    # note that octave applies to pitch_class before alteration, so B#3=C4\n    return pitch_class + 12 * (octave + 1) + alteration, alteration\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.from_name(name)","title":"<code>name</code>","text":"(<code>str</code>)           \u2013            <p>The string representation of the pitch name.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.from_name(octave)","title":"<code>octave</code>","text":"(<code>float | None</code>, default:                   <code>-1</code> )           \u2013            <p>The octave number if not specified in the name. (Defaults to -1)</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.from_name(accidental_chars)","title":"<code>accidental_chars</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The characters to use for flat and sharp accidentals. (Defaults to None, which admits '\u266d', 'b' or '-' for flat, and '\u266f', '#', and '+' for sharp.)</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.get_name","title":"get_name","text":"<pre><code>get_name(accidental_chars: str = 'b#') -&gt; str\n</code></pre> <p>Return string name including accidentals (# or b) but no octave.</p> <p>See the <code>name</code> property for details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The string representation of the pitch name, including accidentals.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def get_name(self, accidental_chars: str = \"b#\") -&gt; str:\n    \"\"\"Return string name including accidentals (# or b) but no octave.\n\n    See the `name` property for details.\n\n    Parameters\n    ----------\n    accidental_chars : str, optional\n        The characters to use for flat and sharp accidentals.\n        (Defaults to \"b#\")\n\n    Returns\n    -------\n    str\n        The string representation of the pitch name, including accidentals.\n    \"\"\"\n    accidentals = \"?\"\n    sharp_char = (accidental_chars[1] if len(accidental_chars) &gt; 1 else \"#\")\n    if round(self.alt) == self.alt:  # an integer value\n        if self.alt &gt; 0:\n            accidentals = sharp_char * round(self.alt)\n        elif self.alt &lt; 0:\n            accidentals = accidental_chars[0] * round(-self.alt)\n        else:\n            accidentals = \"\"  # natural\n    return self.step + accidentals\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.get_name(accidental_chars)","title":"<code>accidental_chars</code>","text":"(<code>str</code>, default:                   <code>'b#'</code> )           \u2013            <p>The characters to use for flat and sharp accidentals. (Defaults to \"b#\")</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.get_name_with_octave","title":"get_name_with_octave","text":"<pre><code>get_name_with_octave(accidental_chars: str = 'b#') -&gt; str\n</code></pre> <p>Return string name with octave, e.g., C4, B#3, etc.</p> <p>See the name_with_octave property for details.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>The string representation of the pitch name with octave.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def get_name_with_octave(self, accidental_chars: str = \"b#\") -&gt; str:\n    \"\"\"Return string name with octave, e.g., C4, B#3, etc.\n\n    See the [name_with_octave][amads.core.pitch.Pitch.name_with_octave]\n    property for details.\n\n    Parameters\n    ----------\n    accidental_chars : str, optional\n        The characters to use for flat and sharp accidentals.\n        (Defaults to \"b#\")\n\n    Returns\n    -------\n    str\n        The string representation of the pitch name with octave.\n    \"\"\"\n    return (\"unpitched\" if self.key_num is None\n                        else self.name + str(self.octave))\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.get_name_with_octave(accidental_chars)","title":"<code>accidental_chars</code>","text":"(<code>str</code>, default:                   <code>'b#'</code> )           \u2013            <p>The characters to use for flat and sharp accidentals. (Defaults to \"b#\")</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.enharmonic","title":"enharmonic","text":"<pre><code>enharmonic() -&gt; Pitch\n</code></pre> <p>Construct an enharmonic equivalent.</p> <p>If <code>alt</code> is non-zero, return a Pitch where <code>alt</code> is zero or has the opposite sign and where <code>alt</code> is minimized. E.g. enharmonic(Cbb) is A# (not Bb). If alt is zero, return a Pitch with alt of +1 or -1 if possible. Otherwise, return a Pitch with alt of -2 (Ebb, Abb or Bbb). Note the difference between this and <code>simplest_enharmonic</code>.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A new Pitch object representing the enharmonic equivalent.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Pitch(\"C4\").enharmonic()\nPitch(name='B#3', key_num=60)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"B3\").enharmonic()\nPitch(name='Cb4', key_num=59)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"B#3\").enharmonic()\nPitch(name='C4', key_num=60)\n</code></pre> <pre><code>&gt;&gt;&gt; bds = Pitch(\"B##3\")\n&gt;&gt;&gt; bds.enharmonic() # change of direction\nPitch(name='Db4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; bds.upper_enharmonic()  # note the difference\nPitch(name='C#4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"Dbb4\").enharmonic()\nPitch(name='C4', key_num=60)\n</code></pre> Source code in <code>amads/core/pitch.py</code> <pre><code>def enharmonic(self) -&gt; \"Pitch\":\n    \"\"\"Construct an enharmonic equivalent.\n\n    If `alt` is non-zero, return a Pitch where `alt` is zero\n    or has the opposite sign and where `alt` is minimized. E.g.\n    enharmonic(Cbb) is A# (not Bb). If alt is zero, return a\n    Pitch with alt of +1 or -1 if possible. Otherwise, return\n    a Pitch with alt of -2 (Ebb, Abb or Bbb).\n    Note the difference between this and `simplest_enharmonic`.\n\n    Returns\n    -------\n    Pitch\n        A new Pitch object representing the enharmonic equivalent.\n\n    Examples\n    --------\n    &gt;&gt;&gt; Pitch(\"C4\").enharmonic()\n    Pitch(name='B#3', key_num=60)\n\n    &gt;&gt;&gt; Pitch(\"B3\").enharmonic()\n    Pitch(name='Cb4', key_num=59)\n\n    &gt;&gt;&gt; Pitch(\"B#3\").enharmonic()\n    Pitch(name='C4', key_num=60)\n\n    &gt;&gt;&gt; bds = Pitch(\"B##3\")\n    &gt;&gt;&gt; bds.enharmonic() # change of direction\n    Pitch(name='Db4', key_num=61)\n\n    &gt;&gt;&gt; bds.upper_enharmonic()  # note the difference\n    Pitch(name='C#4', key_num=61)\n\n    &gt;&gt;&gt; Pitch(\"Dbb4\").enharmonic()\n    Pitch(name='C4', key_num=60)\n    \"\"\"\n    alt = self.alt\n    unaltered = round(self.key_num - alt)\n    if alt &lt; 0:\n        while alt &lt; 0 or (unaltered % 12) not in [0, 2, 4, 5, 7, 9, 11]:\n            unaltered -= 1\n            alt += 1\n    elif alt &gt; 0:\n        while alt &gt; 0 or (unaltered % 12) not in [0, 2, 4, 5, 7, 9, 11]:\n            unaltered += 1\n            alt -= 1\n    else:  # alt == 0\n        unaltered = unaltered % 12\n        if unaltered in [0, 5]:  # C-&gt;B#, F-&gt;E#\n            alt = 1\n        elif unaltered in [11, 4]:  # B-&gt;Cb, E-&gt;Fb\n            alt = -1\n        else:  # A-&gt;Bbb, D-&gt;Ebb, G-&gt;Abb\n            alt = -2\n    return Pitch(self.key_num, alt)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.simplest_enharmonic","title":"simplest_enharmonic","text":"<pre><code>simplest_enharmonic(sharp_or_flat: str | None = 'default') -&gt; Pitch\n</code></pre> <p>Create Pitch object with the simplest enharmonic representation.</p> <p>I.e., if there exists an enharmonic-equivalent pitch with no alterations, then use that. If the Pitch is already in simplest form (e.g., C4), it is simply returned. If an alteration is needed, then use sharps or flats depending on <code>sharp_or_flat</code>. If <code>sharp_or_flat</code> is omitted, the same enharmonic choice as the Pitch constructor is used (C#, Eb, F#, Ab, and Bb).</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bds = Pitch(\"B##3\")\n&gt;&gt;&gt; bds.simplest_enharmonic()\nPitch(name='C#4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; bds.simplest_enharmonic(sharp_or_flat=\"flat\")\nPitch(name='Db4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"C4\").simplest_enharmonic()\nPitch(name='C4', key_num=60)\n</code></pre> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the enharmonic equivalent.</p> </li> </ul> Source code in <code>amads/core/pitch.py</code> <pre><code>def simplest_enharmonic(self,\n        sharp_or_flat: Optional[str] = 'default') -&gt; \"Pitch\":\n    \"\"\"\n    Create Pitch object with the simplest enharmonic representation.\n\n    I.e., if there exists an enharmonic-equivalent pitch with no\n    alterations, then use that. If the Pitch is already in simplest\n    form (e.g., C4), it is simply returned. If an alteration is\n    needed, then use sharps or flats depending on `sharp_or_flat`.\n    If `sharp_or_flat` is omitted, the same enharmonic choice\n    as the Pitch constructor is used (C#, Eb, F#, Ab, and Bb).\n\n    Parameters\n    ----------\n    sharp_or_flat: str\n        This is only relevant if the pitch needs an alteration, otherwise\n        it is unused. The value can be \"sharp\" (use sharps), \"flat\" (use\n        flats), and otherwise use the same enharmonic choice as the Pitch\n        constructor.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; bds = Pitch(\"B##3\")\n    &gt;&gt;&gt; bds.simplest_enharmonic()\n    Pitch(name='C#4', key_num=61)\n\n    &gt;&gt;&gt; bds.simplest_enharmonic(sharp_or_flat=\"flat\")\n    Pitch(name='Db4', key_num=61)\n\n    &gt;&gt;&gt; Pitch(\"C4\").simplest_enharmonic()\n    Pitch(name='C4', key_num=60)\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the enharmonic equivalent.\n    \"\"\"\n    if self.alt in [None, 0]:\n        return self\n\n    if self.pitch_class in [0, 2, 4, 5, 7, 9, 11]:  # C, D, E, F, G, A, B\n        return Pitch(self.key_num)\n    elif sharp_or_flat == \"sharp\":  # unaltered in 1, 3, 6, 8, 10\n        return Pitch(self.key_num, 1)\n    elif sharp_or_flat == \"flat\":\n        return Pitch(self.key_num, -1)\n    else:  # let Pitch figure out which enharmonic spelling (alt) to use:\n        return Pitch(self.key_num)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.simplest_enharmonic(sharp_or_flat)","title":"<code>sharp_or_flat</code>","text":"(<code>str | None</code>, default:                   <code>'default'</code> )           \u2013            <p>This is only relevant if the pitch needs an alteration, otherwise it is unused. The value can be \"sharp\" (use sharps), \"flat\" (use flats), and otherwise use the same enharmonic choice as the Pitch constructor.</p>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.upper_enharmonic","title":"upper_enharmonic","text":"<pre><code>upper_enharmonic() -&gt; Pitch\n</code></pre> <p>Return the enharmonic based on the note name above.</p> <p>The result will have the next higher diatonic name with <code>alt</code> accordingly decreased by 1 or 2, e.g., C#-&gt;Db, C##-&gt;D, Cb-&gt;Dbbb.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the upper enharmonic equivalent.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bds = Pitch(\"B##3\")\n&gt;&gt;&gt; bds\nPitch(name='B##3', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; cis = bds.upper_enharmonic()\n&gt;&gt;&gt; cis\nPitch(name='C#4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; des = cis.upper_enharmonic()\n&gt;&gt;&gt; des\nPitch(name='Db4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; des.upper_enharmonic()\nPitch(name='Ebbb4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"D4\").upper_enharmonic()\nPitch(name='Ebb4', key_num=62)\n</code></pre> Source code in <code>amads/core/pitch.py</code> <pre><code>def upper_enharmonic(self) -&gt; \"Pitch\":\n    \"\"\"\n    Return the enharmonic based on the note name above.\n\n    The result will have the next higher diatonic name\n    with `alt` accordingly decreased by 1 or 2, e.g.,\n    C#-&gt;Db, C##-&gt;D, Cb-&gt;Dbbb.\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the upper enharmonic equivalent.\n\n\n    Examples\n    --------\n    &gt;&gt;&gt; bds = Pitch(\"B##3\")\n    &gt;&gt;&gt; bds\n    Pitch(name='B##3', key_num=61)\n\n    &gt;&gt;&gt; cis = bds.upper_enharmonic()\n    &gt;&gt;&gt; cis\n    Pitch(name='C#4', key_num=61)\n\n    &gt;&gt;&gt; des = cis.upper_enharmonic()\n    &gt;&gt;&gt; des\n    Pitch(name='Db4', key_num=61)\n\n    &gt;&gt;&gt; des.upper_enharmonic()\n    Pitch(name='Ebbb4', key_num=61)\n\n    &gt;&gt;&gt; Pitch(\"D4\").upper_enharmonic()\n    Pitch(name='Ebb4', key_num=62)\n\n    \"\"\"\n    alt = self.alt\n    unaltered = round(self.key_num - alt) % 12\n    if unaltered in [0, 2, 5, 7, 9]:  # C-&gt;D, D-&gt;E, F-&gt;G, G-&gt;A, A-&gt;B\n        alt -= 2\n    else:  # E-&gt;F, B-&gt;C\n        alt -= 1\n    return Pitch(self.key_num, alt)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.Pitch.lower_enharmonic","title":"lower_enharmonic","text":"<pre><code>lower_enharmonic() -&gt; Pitch\n</code></pre> <p>Return the enharmonic based on the note name below.</p> <p>The result will have the next lower diatonic name with <code>alt</code> accordingly increased by 1 or 2, e.g., Db-&gt;C#, D-&gt;C##, D#-&gt;C###.</p> <p>Returns:</p> <ul> <li> <code>Pitch</code>           \u2013            <p>A Pitch object representing the lower enharmonic equivalent.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; Pitch(\"Db4\").lower_enharmonic()\nPitch(name='C#4', key_num=61)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"D4\").lower_enharmonic()\nPitch(name='C##4', key_num=62)\n</code></pre> <pre><code>&gt;&gt;&gt; Pitch(\"C#4\").lower_enharmonic()\nPitch(name='B##3', key_num=61)\n</code></pre> Source code in <code>amads/core/pitch.py</code> <pre><code>def lower_enharmonic(self) -&gt; \"Pitch\":\n    \"\"\"Return the enharmonic based on the note name below.\n\n    The result will have the next lower diatonic name\n    with `alt` accordingly increased by 1 or 2, e.g.,\n    Db-&gt;C#, D-&gt;C##, D#-&gt;C###.\n\n    Returns\n    -------\n    Pitch\n        A Pitch object representing the lower enharmonic equivalent.\n\n    Examples\n    --------\n    &gt;&gt;&gt; Pitch(\"Db4\").lower_enharmonic()\n    Pitch(name='C#4', key_num=61)\n\n    &gt;&gt;&gt; Pitch(\"D4\").lower_enharmonic()\n    Pitch(name='C##4', key_num=62)\n\n    &gt;&gt;&gt; Pitch(\"C#4\").lower_enharmonic()\n    Pitch(name='B##3', key_num=61)\n\n    \"\"\"\n    alt = self.alt\n    unaltered = round(self.key_num - alt) % 12\n    if unaltered in [2, 4, 7, 9, 11]:  # D-&gt;C, E-&gt;D, G-&gt;F, A-&gt;G, B-&gt;A\n        alt += 2\n    else:  # F-&gt;E, C-&gt;B\n        alt += 1\n    return Pitch(self.key_num, alt)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection","title":"PitchCollection  <code>dataclass</code>","text":"<pre><code>PitchCollection(pitches: list[Pitch])\n</code></pre> <p>Combined representations of more than one pitch. Differs from Chord which has onset, duration, and contains Notes, not Pitches.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>pitches</code>               (<code>list[Pitch]</code>)           \u2013            <p>A list of Pitch instances.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_case = ['G#4', 'G#4', 'B4', 'D4', 'F4', 'Ab4']  \n&gt;&gt;&gt; pitches = [Pitch(p) for p in test_case]  \n&gt;&gt;&gt; pitches_gathered = PitchCollection(pitches)\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_gathered.pitch_name_multiset  \n['G#4', 'G#4', 'B4', 'D4', 'F4', 'Ab4']\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_gathered.pitch_num_multiset  \n[68, 68, 71, 62, 65, 68]\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_gathered.pitch_class_multiset  \n[2, 5, 8, 8, 8, 11]\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_gathered.pitch_class_set  \n[2, 5, 8, 11]\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_gathered.pitch_class_vector  \n(0, 0, 1, 0, 0, 1, 0, 0, 3, 0, 0, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_gathered.pitch_class_indicator_vector\n(0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1)\n</code></pre>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection(pitches)","title":"<code>pitches</code>","text":"(<code>list[Pitch]</code>)           \u2013            <p>A list of Pitch instances.</p>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection-attributes","title":"Attributes","text":""},{"location":"reference/pitch/#amads.core.pitch.PitchCollection.pitch_num_multiset","title":"pitch_num_multiset  <code>property</code>","text":"<pre><code>pitch_num_multiset\n</code></pre> <p>Return a list of pitch numbers from the pitches in the collection.</p>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection.pitch_name_multiset","title":"pitch_name_multiset  <code>property</code>","text":"<pre><code>pitch_name_multiset\n</code></pre> <p>Return a list of pitch names with octaves from the pitches in the collection.</p>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection.pitch_class_multiset","title":"pitch_class_multiset  <code>property</code>","text":"<pre><code>pitch_class_multiset\n</code></pre> <p>Return a sorted list of pitch classes from the pitches in the collection, including duplicates.</p>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection.pitch_class_set","title":"pitch_class_set  <code>property</code>","text":"<pre><code>pitch_class_set\n</code></pre> <p>Return a sorted list of pitch classes from the pitches in the collection without duplicates.</p>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection.pitch_class_vector","title":"pitch_class_vector  <code>property</code>","text":"<pre><code>pitch_class_vector\n</code></pre> <p>Return a pitch class vector (12-dimensional) representing the count of each pitch class in the collection.</p>"},{"location":"reference/pitch/#amads.core.pitch.PitchCollection.pitch_class_indicator_vector","title":"pitch_class_indicator_vector  <code>property</code>","text":"<pre><code>pitch_class_indicator_vector\n</code></pre> <p>Return a pitch class indicator vector (12-dimensional) representing the presence (1) or absence (0) of each pitch class in the collection.</p>"},{"location":"reference/schema/","title":"Schemata","text":""},{"location":"reference/schema/#amads.schema","title":"schema","text":"<p>Modules:</p> <ul> <li> <code>partimenti</code>           \u2013            <p>Partimenti from the literature (broadly Gjerdingen)</p> </li> </ul>"},{"location":"reference/schema/#amads.schema.partimenti","title":"partimenti","text":"<p>Partimenti from the literature (broadly Gjerdingen)</p> <p>Organized in simple dicts with keys for:</p> <ul> <li><code>\"name\"</code>: e.g., <code>\"Romanesca\"</code>,</li> <li><code>\"when\"</code>: e.g., <code>\"Opening\"</code>,</li> <li><code>\"strong_first\"</code>: bool. True if the pattern starts strong-weak, False for the opposite. (They all alternate)</li> <li><code>\"melody\"</code>: the melodic part expressed in scale degrees (int 1--7).</li> <li><code>\"bass\"</code>: the bass part expressed in scale degrees (int 1--7).</li> <li><code>\"figures\"</code>: harmony as expressed in figured bass (see toolkit issue #8).</li> <li><code>\"note\"</code>: optional.</li> </ul> <p>Ongoing considerations for the encoding: - figure numbers: encoding figures is a very pervasive issue. This \"X,Y\" format is interoperable with some libraries. - rhythmic differences between components. This \"X-Y\" preserves the N stages and metrical sides.</p> <p>Author: Mark Gotham, 2019</p> <p>Attributes:</p> <ul> <li> <code>__author__</code>           \u2013            </li> <li> <code>romanesca</code>           \u2013            </li> <li> <code>do_re_mi</code>           \u2013            </li> <li> <code>sol_fa_mi</code>           \u2013            </li> <li> <code>meyer</code>           \u2013            </li> <li> <code>aprile</code>           \u2013            </li> <li> <code>jupiter</code>           \u2013            </li> <li> <code>pastorella</code>           \u2013            </li> <li> <code>prinner</code>           \u2013            </li> <li> <code>modulating_prinner</code>           \u2013            </li> <li> <code>fonte</code>           \u2013            </li> <li> <code>monte</code>           \u2013            </li> <li> <code>ponte</code>           \u2013            </li> <li> <code>fenaroli</code>           \u2013            </li> <li> <code>indugio</code>           \u2013            </li> <li> <code>passo_indietro</code>           \u2013            </li> <li> <code>deceptive</code>           \u2013            </li> <li> <code>evaded</code>           \u2013            </li> <li> <code>cadenza_semplice</code>           \u2013            </li> <li> <code>cadenza_composta</code>           \u2013            </li> <li> <code>cadenza_doppia</code>           \u2013            </li> <li> <code>complete</code>           \u2013            </li> <li> <code>comma</code>           \u2013            </li> <li> <code>converging</code>           \u2013            </li> <li> <code>quiescenza</code>           \u2013            </li> <li> <code>all</code>           \u2013            </li> </ul>"},{"location":"reference/schema/#amads.schema.partimenti-attributes","title":"Attributes","text":""},{"location":"reference/schema/#amads.schema.partimenti.__author__","title":"__author__  <code>module-attribute</code>","text":"<pre><code>__author__ = 'Mark Gotham'\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.romanesca","title":"romanesca  <code>module-attribute</code>","text":"<pre><code>romanesca = {\n    \"name\": \"Romanesca\",\n    \"when\": \"Opening\",\n    \"strong_first\": True,\n    \"melody\": [1, 5, 1, 1],\n    \"bass\": [1, 7, 6, 3],\n    \"figures\": [5, 6, 5, 6],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.do_re_mi","title":"do_re_mi  <code>module-attribute</code>","text":"<pre><code>do_re_mi = {\n    \"name\": \"Do-Re-Mi\",\n    \"when\": \"Opening\",\n    \"strong_first\": True,\n    \"melody\": [1, 2, 3],\n    \"bass\": [1, 7, 1],\n    \"figures\": [5, 6, 5],\n    \"note\": \"invertible\",\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.sol_fa_mi","title":"sol_fa_mi  <code>module-attribute</code>","text":"<pre><code>sol_fa_mi = {\n    \"name\": \"Sol-Fa-Mi\",\n    \"when\": \"Opening\",\n    \"strong_first\": False,\n    \"melody\": [5, 4, 4, 3],\n    \"bass\": [1, 2, 7, 1],\n    \"figures\": [5, 5, \"6,5\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.meyer","title":"meyer  <code>module-attribute</code>","text":"<pre><code>meyer = {\n    \"name\": \"Meyer\",\n    \"when\": \"Opening\",\n    \"strong_first\": False,\n    \"melody\": [1, 7, 4, 3],\n    \"bass\": [1, 2, 7, 1],\n    \"figures\": [5, \"6,4,3\", \"6,5\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.aprile","title":"aprile  <code>module-attribute</code>","text":"<pre><code>aprile = {\n    \"name\": \"Aprile\",\n    \"when\": \"Opening\",\n    \"strong_first\": True,\n    \"melody\": [1, 7, 2, 1],\n    \"bass\": [1, 2, 7, 1],\n    \"figures\": [5, \"6,4,3\", \"6,5\", 5],\n    \"note\": \"Happy birthday!\",\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.jupiter","title":"jupiter  <code>module-attribute</code>","text":"<pre><code>jupiter = {\n    \"name\": \"Jupiter\",\n    \"when\": \"Opening\",\n    \"strong_first\": True,\n    \"melody\": [1, 2, 4, 3],\n    \"bass\": [1, 7, 5, 1],\n    \"figures\": [5, 6, 5, 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.pastorella","title":"pastorella  <code>module-attribute</code>","text":"<pre><code>pastorella = {\n    \"name\": \"Pastorella\",\n    \"when\": \"Opening\",\n    \"strong_first\": True,\n    \"melody\": [3, 2, 4, 3],\n    \"bass\": [1, 5, 5, 1],\n    \"figures\": [5, 6, 5, 5],\n    \"note\": \"Thirds\",\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.prinner","title":"prinner  <code>module-attribute</code>","text":"<pre><code>prinner = {\n    \"name\": \"Prinner\",\n    \"when\": \"Answer/Process/Transition\",\n    \"strong_first\": True,\n    \"melody\": [6, 5, 4, 3],\n    \"bass\": [4, 3, 2, 1],\n    \"figures\": [5, 6, \"7-6\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.modulating_prinner","title":"modulating_prinner  <code>module-attribute</code>","text":"<pre><code>modulating_prinner = {\n    \"name\": \"Modulating Prinner\",\n    \"when\": \"Answer/Process/Transition, e.g. end of A\",\n    \"strong_first\": True,\n    \"melody\": [3, 2, 1, 7],\n    \"bass\": [8, 7, 6, 5],\n    \"figures\": [5, 6, \"7-#6\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.fonte","title":"fonte  <code>module-attribute</code>","text":"<pre><code>fonte = {\n    \"name\": \"Fonte\",\n    \"when\": \"Answer/Process/Transition, e.g. start of B\",\n    \"strong_first\": False,\n    \"melody\": [5, 4, 4, 3],\n    \"bass\": [\"#1\", 2, 7, 1],\n    \"figures\": [\"6,5\", 5, \"6,5\", 5],\n    \"note\": \"Cycle of 5ths. 6,5 due to melody\",\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.monte","title":"monte  <code>module-attribute</code>","text":"<pre><code>monte = {\n    \"name\": \"Monte\",\n    \"when\": \"Answer/Process/Transition, e.g. start of B\",\n    \"strong_first\": False,\n    \"melody\": [\"1-b7\", \"6\", \"2-1\", \"7\"],\n    \"bass\": [3, 4, \"#4\", 5],\n    \"figures\": [6, 5, 6, 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.ponte","title":"ponte  <code>module-attribute</code>","text":"<pre><code>ponte = {\n    \"name\": \"Ponte\",\n    \"when\": \"Answer/Process/Transition\",\n    \"strong_first\": True,\n    \"melody\": [5, 7, 2],\n    \"bass\": [5, 5, 5],\n    \"figures\": [5, 7, 7],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.fenaroli","title":"fenaroli  <code>module-attribute</code>","text":"<pre><code>fenaroli = {\n    \"name\": \"Fenaroli\",\n    \"when\": \"Pre-Cadential\",\n    \"strong_first\": True,\n    \"melody\": [4, 3, 7, 1],\n    \"bass\": [7, 1, 2, 3],\n    \"figures\": [6, 5, 6, 6],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.indugio","title":"indugio  <code>module-attribute</code>","text":"<pre><code>indugio = {\n    \"name\": \"Indugio\",\n    \"when\": \"Pre-Cadential\",\n    \"strong_first\": True,\n    \"melody\": [2, 4, 6, 1, 7],\n    \"bass\": [4, 4, 4, \"4#\", 5],\n    \"figures\": [\"6,5\", \"6,5\", \"6,5\", \"6,5\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.passo_indietro","title":"passo_indietro  <code>module-attribute</code>","text":"<pre><code>passo_indietro = {\n    \"name\": \"Passo Indietro\",\n    \"when\": \"Pre-Cadential\",\n    \"strong_first\": True,\n    \"melody\": [7, 1],\n    \"bass\": [4, 3],\n    \"figures\": [\"6,4,2\", 6],\n    \"note\": \"Step back, before a significant cadence\",\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.deceptive","title":"deceptive  <code>module-attribute</code>","text":"<pre><code>deceptive = {\n    \"name\": \"Deceptive Cadence\",\n    \"when\": \"Pre-Cadential\",\n    \"strong_first\": False,\n    \"melody\": [1, 2, 2, 1],\n    \"bass\": [3, 4, 5, 6],\n    \"figures\": [6, \"6,5\", 5, 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.evaded","title":"evaded  <code>module-attribute</code>","text":"<pre><code>evaded = {\n    \"name\": \"Evaded Cadence\",\n    \"when\": \"Pre-Cadential\",\n    \"strong_first\": False,\n    \"melody\": [1, 2, 2, 1],\n    \"bass\": [3, 4, 5, 3],\n    \"figures\": [6, \"6,5\", 5, 6],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.cadenza_semplice","title":"cadenza_semplice  <code>module-attribute</code>","text":"<pre><code>cadenza_semplice = {\n    \"name\": \"Cadenza Semplice\",\n    \"when\": \"Cadence\",\n    \"strong_first\": False,\n    \"melody\": [1, 2, 2, 1],\n    \"bass\": [3, 4, 5, 1],\n    \"figures\": [6, \"6,5\", 5, 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.cadenza_composta","title":"cadenza_composta  <code>module-attribute</code>","text":"<pre><code>cadenza_composta = {\n    \"name\": \"Cadenza Composta\",\n    \"when\": \"Cadence\",\n    \"strong_first\": True,\n    \"melody\": [1, 2, 3, 2, 1],\n    \"bass\": [3, 4, 5, 5, 1],\n    \"figures\": [6, \"6,5\", \"6,4\", 7, 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.cadenza_doppia","title":"cadenza_doppia  <code>module-attribute</code>","text":"<pre><code>cadenza_doppia = {\n    \"name\": \"Cadenza Doppia\",\n    \"when\": \"Cadence\",\n    \"strong_first\": True,\n    \"melody\": [4, 3, 2, 2, 1],\n    \"bass\": [5, 5, 5, 5, 1],\n    \"figures\": [5, \"6,4\", 4, 3, 5],\n    \"relatedTo\": [\"Comma\", \"Complete\"],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.complete","title":"complete  <code>module-attribute</code>","text":"<pre><code>complete = {\n    \"name\": \"Complete Cadence\",\n    \"when\": \"Cadence\",\n    \"strong_first\": False,\n    \"melody\": [3, 2, 2, 1],\n    \"bass\": [1, 4, 5, 1],\n    \"figures\": [5, \"6,5\", 5, 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.comma","title":"comma  <code>module-attribute</code>","text":"<pre><code>comma = {\n    \"name\": \"Comma\",\n    \"when\": \"Cadence\",\n    \"strong_first\": False,\n    \"melody\": [4, 3],\n    \"bass\": [7, 1],\n    \"figures\": [\"6,5\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.converging","title":"converging  <code>module-attribute</code>","text":"<pre><code>converging = {\n    \"name\": \"Converging Cadence\",\n    \"when\": \"Cadence\",\n    \"strong_first\": False,\n    \"melody\": [3, 2, 1, 7],\n    \"bass\": [\"3\", \"4\", \"#4\", \"5\"],\n    \"figures\": [6, \"6,5\", \"6,5\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.quiescenza","title":"quiescenza  <code>module-attribute</code>","text":"<pre><code>quiescenza = {\n    \"name\": \"Quiescenza\",\n    \"when\": \"Post-Cadential\",\n    \"strong_first\": False,\n    \"melody\": [\"b7\", \"6\", \"7\", \"1\"],\n    \"bass\": [1, 1, 1, 1],\n    \"figures\": [\"b7\", \"6,4\", \"7,4,2\", 5],\n}\n</code></pre>"},{"location":"reference/schema/#amads.schema.partimenti.all","title":"all  <code>module-attribute</code>","text":"<pre><code>all = [\n    aprile,\n    cadenza_doppia,\n    cadenza_semplice,\n    comma,\n    converging,\n    deceptive,\n    do_re_mi,\n    evaded,\n    fonte,\n    fenaroli,\n    indugio,\n    jupiter,\n    meyer,\n    modulating_prinner,\n    monte,\n    passo_indietro,\n    pastorella,\n    ponte,\n    prinner,\n    quiescenza,\n    romanesca,\n    sol_fa_mi,\n]\n</code></pre>"},{"location":"reference/utils/","title":"Utility Functions","text":"<pre><code>from amads.core.utils import *\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.dir_to_collection","title":"dir_to_collection","text":"<pre><code>dir_to_collection(filenames: list[str])\n</code></pre> <p>Converts a list of music filenames to a dictionary where keys are filenames and values are corresponding Score objects.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary mapping filenames to Score objects.</p> </li> </ul> Source code in <code>amads/core/utils.py</code> <pre><code>def dir_to_collection(filenames: list[str]):\n    \"\"\"\n    Converts a list of music filenames to a dictionary where keys\n    are filenames and values are corresponding Score objects.\n\n    Parameters\n    ----------\n    filenames : list(str)\n        List of filenames to process.\n\n    Returns\n    -------\n    dict\n        A dictionary mapping filenames to Score objects.\n    \"\"\"\n    scores = {}\n\n    for file in filenames:\n        if any(file.endswith(ext) for ext in valid_score_extensions):\n            try:\n                score = read_score(file)\n                scores[file] = score\n            except Exception as e:\n                print(f\"Error processing file {file}: {e}\")\n        else:\n            print(f\"Unsupported file format: {file}\")\n\n    return scores\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.dir_to_collection(filenames)","title":"<code>filenames</code>","text":"(<code>list(str)</code>)           \u2013            <p>List of filenames to process.</p>"},{"location":"reference/utils/#amads.core.utils.hz_to_key_num","title":"hz_to_key_num","text":"<pre><code>hz_to_key_num(\n    hertz: float | list[float], do_round: bool = True\n) -&gt; float | list[float]\n</code></pre> <p>Converts a frequency in Hertz to the corresponding MIDI key number.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union(float, list(float))</code>           \u2013            <p>The corresponding MIDI key number(s).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hz_to_key_num(440.0)\n69\n&gt;&gt;&gt; hz_to_key_num(260.0, False)\n59.89209719404554\n&gt;&gt;&gt; hz_to_key_num([440, 260], True)\n[69, 60]\n</code></pre> Source code in <code>amads/core/utils.py</code> <pre><code>def hz_to_key_num(\n    hertz: Union[float, list[float]], do_round: bool = True\n) -&gt; Union[float, list[float]]:\n    \"\"\"\n    Converts a frequency in Hertz to the corresponding MIDI key number.\n\n    Parameters\n    ----------\n    hertz : Union(float, list(float))\n        The frequency or list of frequencies in Hertz.\n\n    do_round : bool\n        Perform rounding to the nearest integer key_num.\n\n    Returns\n    -------\n    Union(float, list(float))\n        The corresponding MIDI key number(s).\n\n    Examples\n    --------\n    &gt;&gt;&gt; hz_to_key_num(440.0)\n    69\n    &gt;&gt;&gt; hz_to_key_num(260.0, False)\n    59.89209719404554\n    &gt;&gt;&gt; hz_to_key_num([440, 260], True)\n    [69, 60]\n    \"\"\"\n\n    if isinstance(hertz, list):\n        return [_hz_to_key_num_single(hz, do_round) for hz in hertz]\n    else:\n        return _hz_to_key_num_single(hertz, do_round)\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.hz_to_key_num(hertz)","title":"<code>hertz</code>","text":"(<code>Union(float, list(float))</code>)           \u2013            <p>The frequency or list of frequencies in Hertz.</p>"},{"location":"reference/utils/#amads.core.utils.hz_to_key_num(do_round)","title":"<code>do_round</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Perform rounding to the nearest integer key_num.</p>"},{"location":"reference/utils/#amads.core.utils.key_num_to_hz","title":"key_num_to_hz","text":"<pre><code>key_num_to_hz(\n    key_num: float | Pitch | list[float | Pitch],\n) -&gt; float | list[float]\n</code></pre> <p>Converts a Pitch object or MIDI key number to the corresponding frequency in Hertz.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union(float, list(float))</code>           \u2013            <p>The corresponding frequency in Hertz.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; key_num_to_hz(69)\n440.0\n&gt;&gt;&gt; key_num_to_hz([Pitch(\"A5\"), 60])\n[880.0, 261.6255653005986]\n</code></pre> Source code in <code>amads/core/utils.py</code> <pre><code>def key_num_to_hz(\n    key_num: Union[float, Pitch, list[Union[float, Pitch]]]\n) -&gt; Union[float, list[float]]:\n    \"\"\"\n    Converts a Pitch object or MIDI key number to the corresponding\n    frequency in Hertz.\n\n    Parameters\n    ----------\n    key_num : Union(Pitch, float, list(Union(Pitch, float)))\n        The Pitch object(s) or MIDI key number(s).\n\n    Returns\n    -------\n    Union(float, list(float))\n        The corresponding frequency in Hertz.\n\n    Examples\n    --------\n    &gt;&gt;&gt; key_num_to_hz(69)\n    440.0\n    &gt;&gt;&gt; key_num_to_hz([Pitch(\"A5\"), 60])\n    [880.0, 261.6255653005986]\n    \"\"\"\n\n    def key_num_to_hz_single(k):\n        if isinstance(k, Pitch):\n            key_num = k.key_num\n        else:\n            key_num = k\n        return 440.0 * 2 ** ((key_num - 69) / 12)\n\n    if isinstance(key_num, list):\n        return [key_num_to_hz_single(k) for k in key_num]\n    else:\n        return key_num_to_hz_single(key_num)\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.key_num_to_hz(key_num)","title":"<code>key_num</code>","text":"(<code>Union(Pitch, float, list(Union(Pitch, float)))</code>)           \u2013            <p>The Pitch object(s) or MIDI key number(s).</p>"},{"location":"reference/utils/#amads.core.utils.key_num_to_name","title":"key_num_to_name","text":"<pre><code>key_num_to_name(n, detail='nameoctave')\n</code></pre> <p>Converts key numbers to key names (text).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union(str, list(str))</code>           \u2013            <p>The corresponding key names.</p> </li> </ul> Source code in <code>amads/core/utils.py</code> <pre><code>def key_num_to_name(n, detail=\"nameoctave\"):\n    \"\"\"\n    Converts key numbers to key names (text).\n\n    Parameters\n    ----------\n    n : Union(int, list(int))\n        The key numbers.\n    detail : Optional(str)\n        `'nameonly'` for just the note name (e.g., `'C#'`),\n        `'nameoctave'` for note name with octave (e.g., `'C#4'`) (default).\n\n    Returns\n    -------\n    Union(str, list(str))\n        The corresponding key names.\n    \"\"\"\n\n    def key_num_to_name_single(k):\n        pitch = Pitch(k)\n        if detail == \"nameonly\":\n            # Handles sharps, flats, and naturals correctly\n            return pitch.name\n        elif detail == \"nameoctave\":\n            return pitch.name_with_octave  # Includes note name and octave\n        else:\n            raise ValueError(\n                \"Invalid detail option. Use 'nameonly' or \" \"'nameoctave'.\"\n            )\n\n    if isinstance(n, list):\n        return [key_num_to_name_single(k) for k in n]\n    else:\n        return key_num_to_name_single(n)\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.key_num_to_name(n)","title":"<code>n</code>","text":"(<code>Union(int, list(int))</code>)           \u2013            <p>The key numbers.</p>"},{"location":"reference/utils/#amads.core.utils.key_num_to_name(detail)","title":"<code>detail</code>","text":"(<code>Optional(str)</code>, default:                   <code>'nameoctave'</code> )           \u2013            <p><code>'nameonly'</code> for just the note name (e.g., <code>'C#'</code>), <code>'nameoctave'</code> for note name with octave (e.g., <code>'C#4'</code>) (default).</p>"},{"location":"reference/utils/#amads.core.utils.sign","title":"sign","text":"<pre><code>sign(x: float) -&gt; int\n</code></pre> <p>Get the sign of a numeric value as -1, 0, or +1.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>-1 if <code>x</code> &lt; 0, 0 if <code>x</code> == 0, 1 if <code>x</code> &gt; 0</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sign(-15)\n-1\n</code></pre> <pre><code>&gt;&gt;&gt; sign(-1)\n-1\n</code></pre> <pre><code>&gt;&gt;&gt; sign(-0.5)\n-1\n</code></pre> <pre><code>&gt;&gt;&gt; sign(-0)\n0\n</code></pre> <pre><code>&gt;&gt;&gt; sign(+0)\n0\n</code></pre> <pre><code>&gt;&gt;&gt; sign(+0.5)\n1\n</code></pre> <pre><code>&gt;&gt;&gt; sign(15.2)\n1\n</code></pre> <pre><code>&gt;&gt;&gt; sign(None) is None\nTrue\n</code></pre> Source code in <code>amads/core/utils.py</code> <pre><code>def sign(x: float) -&gt; int:\n    \"\"\"\n    Get the sign of a numeric value as -1, 0, or +1.\n\n    Returns\n    ----------\n    int\n        -1 if `x` &lt; 0, 0 if `x` == 0, 1 if `x` &gt; 0\n\n    Examples\n    --------\n    &gt;&gt;&gt; sign(-15)\n    -1\n\n    &gt;&gt;&gt; sign(-1)\n    -1\n\n    &gt;&gt;&gt; sign(-0.5)\n    -1\n\n    &gt;&gt;&gt; sign(-0)\n    0\n\n    &gt;&gt;&gt; sign(+0)\n    0\n\n    &gt;&gt;&gt; sign(+0.5)\n    1\n\n    &gt;&gt;&gt; sign(15.2)\n    1\n\n    &gt;&gt;&gt; sign(None) is None\n    True\n    \"\"\"\n    if x is None:\n        return None  # type: ignore\n    else:\n        return bool(x &gt; 0) - bool(x &lt; 0)\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.float_range","title":"float_range","text":"<pre><code>float_range(\n    start: float, end: float | None, step: float\n) -&gt; Iterator[float]\n</code></pre> <p>Generate a range of floats.</p> <p>Similar to Python's built-in range() function but supports floating point numbers. If end is None, generates an infinite sequence.</p> <p>Parameters:</p> <p>Yields:</p> <ul> <li> <code>float</code>           \u2013            <p>The next value in the sequence</p> </li> </ul> Source code in <code>amads/core/utils.py</code> <pre><code>def float_range(\n    start: float, end: Optional[float], step: float\n) -&gt; Iterator[float]:\n    \"\"\"Generate a range of floats.\n\n    Similar to Python's built-in range() function but supports floating\n    point numbers. If end is None, generates an infinite sequence.\n\n    Parameters\n    ----------\n    start : float\n        The starting value of the range\n    end : float or None\n        The end value of the range (exclusive). If None, generates an\n        infinite sequence\n    step : float\n        The increment between values\n\n    Yields\n    ------\n    float\n        The next value in the sequence\n    \"\"\"\n    curr = start\n    while end is None or curr &lt; end:\n        yield curr\n        curr += step\n</code></pre>"},{"location":"reference/utils/#amads.core.utils.float_range(start)","title":"<code>start</code>","text":"(<code>float</code>)           \u2013            <p>The starting value of the range</p>"},{"location":"reference/utils/#amads.core.utils.float_range(end)","title":"<code>end</code>","text":"(<code>float or None</code>)           \u2013            <p>The end value of the range (exclusive). If None, generates an infinite sequence</p>"},{"location":"reference/utils/#amads.core.utils.float_range(step)","title":"<code>step</code>","text":"(<code>float</code>)           \u2013            <p>The increment between values</p>"},{"location":"reference/vector/","title":"Vector Functions","text":"<pre><code>from amads.core.vector_transforms_checks import *\nfrom amads.core.vectors_sets import *\n</code></pre> <p>Author: Mark Gotham</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.rotate","title":"rotate","text":"<pre><code>rotate(\n    vector: tuple[int, ...] | list[int], steps: int | None = None\n) -&gt; tuple[int, ...] | list[int]\n</code></pre> <p>this serves equivalently for \"phase shifting\" of rhythm and \"transposition\" of pitch.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...] | list[int]</code>           \u2013            <p>The input (tuple or list), rotated. Same length.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = (0, 1, 2, 3)\n&gt;&gt;&gt; rotate(start, 1)\n(1, 2, 3, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; rotate(start, -1)\n(3, 0, 1, 2)\n</code></pre> <pre><code>&gt;&gt;&gt; rotate(start) # note no steps specified\n(2, 3, 0, 1)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def rotate(\n    vector: Union[tuple[int, ...], list[int]], steps: Union[int, None] = None\n) -&gt; Union[tuple[int, ...], list[int]]:\n    \"\"\"\n    this serves equivalently for\n    \"phase shifting\" of rhythm and\n    \"transposition\" of pitch.\n\n    Parameters\n    ----------\n    vector : Union[tuple[int, ...], list[int]]\n        Any tuple or list of any elements.\n        We expect to work with a list of integers representing a vector.\n    steps: Optional[int]\n        How many steps to rotate.\n        Or, equivalently, the nth index of the input list becomes the 0th index of the new.\n        If unspecified, use the half cycle: int(cycle_length / 2).\n\n    Returns\n    -------\n    Union[tuple[int, ...], list[int]]\n        The input (tuple or list), rotated. Same length.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; start = (0, 1, 2, 3)\n    &gt;&gt;&gt; rotate(start, 1)\n    (1, 2, 3, 0)\n\n    &gt;&gt;&gt; rotate(start, -1)\n    (3, 0, 1, 2)\n\n    &gt;&gt;&gt; rotate(start) # note no steps specified\n    (2, 3, 0, 1)\n\n    \"\"\"\n    if not steps:\n        steps = int(len(vector) / 2)\n\n    return vector[steps:] + vector[:steps]\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.rotate(vector)","title":"<code>vector</code>","text":"(<code>tuple[int, ...] | list[int]</code>)           \u2013            <p>Any tuple or list of any elements. We expect to work with a list of integers representing a vector.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.rotate(steps)","title":"<code>steps</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>How many steps to rotate. Or, equivalently, the nth index of the input list becomes the 0th index of the new. If unspecified, use the half cycle: int(cycle_length / 2).</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.mirror","title":"mirror","text":"<pre><code>mirror(\n    vector: list | tuple, index_of_symmetry: int | None = None\n) -&gt; list | tuple\n</code></pre> <p>Reverse a vector (or any ordered iterable).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list | tuple</code>           \u2013            <p>The input (list or tuple), mirrored. Same length.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_case = (0, 1, 2, 3, 4, 5)\n&gt;&gt;&gt; mirror(test_case)\n(5, 4, 3, 2, 1, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; mirror(test_case, index_of_symmetry=0)\n(0, 5, 4, 3, 2, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; mirror(test_case, index_of_symmetry=1)\n(1, 0, 5, 4, 3, 2)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def mirror(\n    vector: Union[list, tuple], index_of_symmetry: Union[int, None] = None\n) -&gt; Union[list, tuple]:\n    \"\"\"\n    Reverse a vector (or any ordered iterable).\n\n    Parameters\n    ----------\n    vector: tuple\n        The tuple accepts any ordered succession of any elements.\n        We expect integers representing a vector, but do not enforce it.\n    index_of_symmetry: Union[int, None]\n        Defaults to None, in which case, standard reflection of the\n        form `[::-1]`. Alternatively, specify an index to rotate about,\n        e.g., for the reverse function in convolution use 0. This is\n        equivalent to mirror and rotation. See notes at [`rotate`]\n        [amads.core.vector_transforms_checks.rotate].\n\n    Returns\n    -------\n    Union[list, tuple]\n        The input (list or tuple), mirrored. Same length.\n\n    Examples\n    --------\n    &gt;&gt;&gt; test_case = (0, 1, 2, 3, 4, 5)\n    &gt;&gt;&gt; mirror(test_case)\n    (5, 4, 3, 2, 1, 0)\n\n    &gt;&gt;&gt; mirror(test_case, index_of_symmetry=0)\n    (0, 5, 4, 3, 2, 1)\n\n    &gt;&gt;&gt; mirror(test_case, index_of_symmetry=1)\n    (1, 0, 5, 4, 3, 2)\n\n    \"\"\"\n    if index_of_symmetry is not None:\n        rotated = (\n            vector[index_of_symmetry::-1] + vector[-1:index_of_symmetry:-1]\n        )\n    else:\n        rotated = vector[::-1]\n    return tuple(rotated)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.mirror(vector)","title":"<code>vector</code>","text":"(<code>list | tuple</code>)           \u2013            <p>The tuple accepts any ordered succession of any elements. We expect integers representing a vector, but do not enforce it.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.mirror(index_of_symmetry)","title":"<code>index_of_symmetry</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Defaults to None, in which case, standard reflection of the form <code>[::-1]</code>. Alternatively, specify an index to rotate about, e.g., for the reverse function in convolution use 0. This is equivalent to mirror and rotation. See notes at <code>rotate</code>.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.complement","title":"complement","text":"<pre><code>complement(indicator_vector: tuple[int, ...]) -&gt; tuple[int, ...]\n</code></pre> <p>Provide the complement of an indicator vector.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; complement((1, 0, 1, 0))\n(0, 1, 0, 1)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def complement(indicator_vector: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Provide the complement of an indicator vector.\n\n    Examples\n    --------\n    &gt;&gt;&gt; complement((1, 0, 1, 0))\n    (0, 1, 0, 1)\n    \"\"\"\n    if not is_indicator_vector(indicator_vector):\n        raise ValueError(\n            \"This is to be called only on binary tuples representing indicator vectors.\"\n        )\n    return tuple(1 - x for x in indicator_vector)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.change_cycle_length","title":"change_cycle_length","text":"<pre><code>change_cycle_length(\n    start_vector: tuple,\n    destination_length: int,\n    return_indices_not_indicator: bool = True,\n) -&gt; tuple\n</code></pre> <p>Change the cycle length of a vector by mapping each point to the nearest equivalent in the new length.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tresillo = (1, 0, 0, 1, 0, 0, 1, 0)\n&gt;&gt;&gt; change_cycle_length(tresillo, 9)\n(0, 3, 7)\n</code></pre> <pre><code>&gt;&gt;&gt; change_cycle_length(tresillo, 12)\n(0, 4, 9)\n</code></pre> <pre><code>&gt;&gt;&gt; change_cycle_length(start_vector=tresillo, destination_length=9,\n...                     return_indices_not_indicator=False)\n(1, 0, 0, 1, 0, 0, 0, 1, 0)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def change_cycle_length(\n    start_vector: tuple,\n    destination_length: int,\n    return_indices_not_indicator: bool = True,\n) -&gt; tuple:\n    \"\"\"\n    Change the cycle length of a vector by mapping each point to the nearest equivalent in the new length.\n\n    Examples\n    --------\n    &gt;&gt;&gt; tresillo = (1, 0, 0, 1, 0, 0, 1, 0)\n    &gt;&gt;&gt; change_cycle_length(tresillo, 9)\n    (0, 3, 7)\n\n    &gt;&gt;&gt; change_cycle_length(tresillo, 12)\n    (0, 4, 9)\n\n    &gt;&gt;&gt; change_cycle_length(start_vector=tresillo, destination_length=9,\n    ...                     return_indices_not_indicator=False)\n    (1, 0, 0, 1, 0, 0, 0, 1, 0)\n\n    \"\"\"\n    start_indices = indicator_to_indices(start_vector)\n    start_len = len(start_vector)\n    new_indices = [\n        round(destination_length * i / start_len) for i in start_indices\n    ]\n    if return_indices_not_indicator:\n        return tuple(new_indices)\n    else:\n        return indices_to_indicator(\n            new_indices, indicator_length=destination_length\n        )\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.is_rotation_equivalent","title":"is_rotation_equivalent","text":"<pre><code>is_rotation_equivalent(vector_a: tuple, vector_b: tuple) -&gt; bool\n</code></pre> <p>Given two vectors, test for rotation equivalence. This is applicable to indicator vectors, interval sequences, and more as long as the user compares like with like.</p> <p>Examples:</p> <p>Indicator:</p> <pre><code>&gt;&gt;&gt; is_rotation_equivalent((1, 0, 0), (0, 1, 0))\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; is_rotation_equivalent((1, 0, 0), (1, 1, 0))\nFalse\n</code></pre> <p>Intervals:</p> <pre><code>&gt;&gt;&gt; is_rotation_equivalent((3, 3, 2), (3, 2, 3))\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; is_rotation_equivalent((3, 3, 2), (2, 3, 2))\nFalse\n</code></pre> <p>Trivial case:</p> <pre><code>&gt;&gt;&gt; is_rotation_equivalent((1, 0, 0), (1, 0, 0))\nTrue\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def is_rotation_equivalent(vector_a: tuple, vector_b: tuple) -&gt; bool:\n    \"\"\"\n    Given two vectors, test for rotation equivalence.\n    This is applicable to indicator vectors, interval sequences, and more\n    as long as the user compares like with like.\n\n    Examples\n    --------\n\n    Indicator:\n\n    &gt;&gt;&gt; is_rotation_equivalent((1, 0, 0), (0, 1, 0))\n    True\n\n    &gt;&gt;&gt; is_rotation_equivalent((1, 0, 0), (1, 1, 0))\n    False\n\n    Intervals:\n\n    &gt;&gt;&gt; is_rotation_equivalent((3, 3, 2), (3, 2, 3))\n    True\n\n    &gt;&gt;&gt; is_rotation_equivalent((3, 3, 2), (2, 3, 2))\n    False\n\n    Trivial case:\n    &gt;&gt;&gt; is_rotation_equivalent((1, 0, 0), (1, 0, 0))\n    True\n\n    \"\"\"\n    if vector_a == vector_b:\n        return True\n\n    vector_length = len(vector_a)\n    if len(vector_b) != vector_length:\n        raise ValueError(\n            f\"The vectors must be of the same length (currently {vector_length} and {len(vector_b)}.\"\n        )\n\n    for steps in range(1, vector_length):\n        if vector_a == rotate(vector_b, steps):\n            return True\n\n    return False\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.is_maximally_even","title":"is_maximally_even","text":"<pre><code>is_maximally_even(indicator_vector: tuple) -&gt; bool\n</code></pre> <p>Checks if an indicator vector (tuple of 0s and 1s) is maximally even, meaning the 1s and 0s are as evenly distributed as possible.</p> <p>Specifically, this works simply by converting to intervals and running the following basic checks: First, there must be no more than 2 interval types. If there is only 1 type, True (perfectly even). If there are 2 types, then those two must differ in value by 1.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the pattern is maximally even, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_maximally_even((1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0))\nTrue\n&gt;&gt;&gt; is_maximally_even((1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0))\nFalse\n&gt;&gt;&gt; is_maximally_even((0, 0, 1, 0, 0, 1, 0, 0, 1))\nTrue\n&gt;&gt;&gt; is_maximally_even((1, 1, 0, 0, 1))\nFalse\n&gt;&gt;&gt; is_maximally_even((0, 1, 0, 1, 0, 1))\nTrue\n</code></pre> <p>This works with the <code>indicator_to_interval</code> function. Let's look at those representations for the bemb\u00e9 cycle and a comparison case.</p> <pre><code>&gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n&gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=True)\n(2, 2, 1, 2, 2, 2, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=True, sequence_not_vector=False)\n(2, 5, 0, 0, 0, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=False)\n(2, 5, 4, 3, 6, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; is_maximally_even(bemb\u00e9)\nTrue\n</code></pre> <p>For our comparison case, we create another cycle that also has: a) 7 elements in a 12-unit cycle,</p> <pre><code>&gt;&gt;&gt; not_bemb\u00e9 =  (1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1)\n&gt;&gt;&gt; not_bemb\u00e9.count(1)\n7\n</code></pre> <pre><code>&gt;&gt;&gt; len(not_bemb\u00e9)\n12\n</code></pre> <p>b) the same first-order interval set of 5 x 2s and 2 x 1s,</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(not_bemb\u00e9, adjacent_not_all=True, sequence_not_vector=False)\n(2, 5, 0, 0, 0, 0)\n</code></pre> <p>... but for which the those 2 x 1s are together</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(not_bemb\u00e9, adjacent_not_all=True)\n(2, 2, 2, 2, 2, 1, 1)\n</code></pre> <p>... making it not maximally even.</p> <pre><code>&gt;&gt;&gt; is_maximally_even(not_bemb\u00e9)\nFalse\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def is_maximally_even(indicator_vector: tuple) -&gt; bool:\n    \"\"\"\n    Checks if an indicator vector (tuple of 0s and 1s) is maximally even,\n    meaning the 1s and 0s are as evenly distributed as possible.\n\n    Specifically, this works simply by converting to intervals and running the following basic checks:\n    First, there must be no more than 2 interval types.\n    If there is only 1 type, True (perfectly even).\n    If there are 2 types, then those two must differ in value by 1.\n\n    Parameters\n    ----------\n    indicator_vector: tuple[int, ...]\n        An indicator_vector (only 0s and/or 1s).\n\n    Returns\n    -------\n    bool\n        True if the pattern is maximally even, False otherwise.\n\n    Examples\n    --------\n    &gt;&gt;&gt; is_maximally_even((1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0))\n    True\n    &gt;&gt;&gt; is_maximally_even((1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0))\n    False\n    &gt;&gt;&gt; is_maximally_even((0, 0, 1, 0, 0, 1, 0, 0, 1))\n    True\n    &gt;&gt;&gt; is_maximally_even((1, 1, 0, 0, 1))\n    False\n    &gt;&gt;&gt; is_maximally_even((0, 1, 0, 1, 0, 1))\n    True\n\n    This works with the `indicator_to_interval` function.\n    Let's look at those representations for the bemb\u00e9 cycle and a comparison case.\n\n    &gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=True)\n    (2, 2, 1, 2, 2, 2, 1)\n\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=True, sequence_not_vector=False)\n    (2, 5, 0, 0, 0, 0)\n\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=False)\n    (2, 5, 4, 3, 6, 1)\n\n    &gt;&gt;&gt; is_maximally_even(bemb\u00e9)\n    True\n\n    For our comparison case, we create another cycle that also has:\n    a) 7 elements in a 12-unit cycle,\n\n    &gt;&gt;&gt; not_bemb\u00e9 =  (1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1)\n    &gt;&gt;&gt; not_bemb\u00e9.count(1)\n    7\n\n    &gt;&gt;&gt; len(not_bemb\u00e9)\n    12\n\n    b) the same first-order interval set of 5 x 2s and 2 x 1s,\n\n    &gt;&gt;&gt; indicator_to_interval(not_bemb\u00e9, adjacent_not_all=True, sequence_not_vector=False)\n    (2, 5, 0, 0, 0, 0)\n\n    ... but for which the those 2 x 1s are together\n\n    &gt;&gt;&gt; indicator_to_interval(not_bemb\u00e9, adjacent_not_all=True)\n    (2, 2, 2, 2, 2, 1, 1)\n\n    ... making it not maximally even.\n\n    &gt;&gt;&gt; is_maximally_even(not_bemb\u00e9)\n    False\n\n    \"\"\"\n    if not is_indicator_vector(indicator_vector):\n        raise ValueError(\n            f\"The `indicator_vector` argument (set as {indicator_vector}) should be an indicator vector.\"\n        )\n\n    k = indicator_vector.count(1)\n    n = len(indicator_vector)\n\n    prototype_k_in_n = indices_to_indicator(tuple(max_even_k_in_n(k, n)), n)\n\n    return is_rotation_equivalent(prototype_k_in_n, indicator_vector)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.is_maximally_even(indicator_vector)","title":"<code>indicator_vector</code>","text":"(<code>tuple</code>)           \u2013            <p>An indicator_vector (only 0s and/or 1s).</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.max_even_k_in_n","title":"max_even_k_in_n","text":"<pre><code>max_even_k_in_n(k: int, n: int) -&gt; set[int]\n</code></pre> <p>Make a maximally even pattern of k elements in an n-length cycle. Normally, we would expect k to be less than n, but this is not strictly required. Larger values of k simply produce duplicate entries in n that are ignored in the returned set.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; max_even_k_in_n(3, 8)\n{0, 3, 5}\n</code></pre> <pre><code>&gt;&gt;&gt; max_even_k_in_n(7, 12)\n{0, 2, 3, 5, 7, 9, 10}\n</code></pre> <pre><code>&gt;&gt;&gt; max_even_k_in_n(5, 16)\n{0, 3, 6, 10, 13}\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def max_even_k_in_n(k: int, n: int) -&gt; set[int]:\n    \"\"\"\n    Make a maximally even pattern of k elements in an n-length cycle.\n    Normally, we would expect k to be less than n, but this is not strictly required.\n    Larger values of k simply produce duplicate entries in n that are ignored in the\n    returned set.\n\n    Examples\n    --------\n    &gt;&gt;&gt; max_even_k_in_n(3, 8)\n    {0, 3, 5}\n\n    &gt;&gt;&gt; max_even_k_in_n(7, 12)\n    {0, 2, 3, 5, 7, 9, 10}\n\n    &gt;&gt;&gt; max_even_k_in_n(5, 16)\n    {0, 3, 6, 10, 13}\n\n    \"\"\"\n    return set([round(n * i / k) for i in range(k)])\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.rotation_distinct_patterns","title":"rotation_distinct_patterns","text":"<pre><code>rotation_distinct_patterns(\n    vector_patterns: tuple[tuple, ...],\n) -&gt; tuple[tuple, ...]\n</code></pre> <p>Given two or more vectors of the same length, test rotation equivalence among them. Return the list of rotation distinct pattens: the returned patterns are not rotation equivalent to each other, but all tested rhythms (in the argument) are rotation equivalent to one of those returned patterns.</p> <p>Examples:</p> <p>Here are ten canonical 12-unit bell pattern rhythms:</p> <pre><code>&gt;&gt;&gt; Soli = (2, 2, 2, 2, 1, 2, 1)\n&gt;&gt;&gt; Tamb\u00fa = (2, 2, 2, 1, 2, 2, 1)\n&gt;&gt;&gt; Bemb\u00e9 = (2, 2, 1, 2, 2, 2, 1)\n&gt;&gt;&gt; Bemb\u00e9_2 = (1, 2, 2, 1, 2, 2, 2)\n&gt;&gt;&gt; Yoruba = (2, 2, 1, 2, 2, 1, 2)\n&gt;&gt;&gt; Tonada = (2, 1, 2, 1, 2, 2, 2)\n&gt;&gt;&gt; Asaadua = (2, 2, 2, 1, 2, 1, 2)\n&gt;&gt;&gt; Sorsonet = (1, 1, 2, 2, 2, 2, 2)\n&gt;&gt;&gt; Bemba = (2, 1, 2, 2, 2, 1, 2)\n&gt;&gt;&gt; Ashanti = (2, 1, 2, 2, 1, 2, 2)\n&gt;&gt;&gt; ten_tuples = (Asaadua, Ashanti, Bemba, Bemb\u00e9, Bemb\u00e9_2, Soli, Sorsonet, Tamb\u00fa, Tonada, Yoruba)\n</code></pre> <p>Collectively, they have 3 distinct patterns.</p> <pre><code>&gt;&gt;&gt; len(rotation_distinct_patterns(ten_tuples))\n3\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def rotation_distinct_patterns(\n    vector_patterns: tuple[tuple, ...]\n) -&gt; tuple[tuple, ...]:\n    \"\"\"\n    Given two or more vectors of the same length,\n    test rotation equivalence among them.\n    Return the list of rotation distinct pattens:\n    the returned patterns are not rotation equivalent to each other,\n    but all tested rhythms (in the argument) are rotation equivalent\n    to one of those returned patterns.\n\n    Examples\n    --------\n    Here are ten canonical 12-unit bell pattern rhythms:\n\n    &gt;&gt;&gt; Soli = (2, 2, 2, 2, 1, 2, 1)\n    &gt;&gt;&gt; Tamb\u00fa = (2, 2, 2, 1, 2, 2, 1)\n    &gt;&gt;&gt; Bemb\u00e9 = (2, 2, 1, 2, 2, 2, 1)\n    &gt;&gt;&gt; Bemb\u00e9_2 = (1, 2, 2, 1, 2, 2, 2)\n    &gt;&gt;&gt; Yoruba = (2, 2, 1, 2, 2, 1, 2)\n    &gt;&gt;&gt; Tonada = (2, 1, 2, 1, 2, 2, 2)\n    &gt;&gt;&gt; Asaadua = (2, 2, 2, 1, 2, 1, 2)\n    &gt;&gt;&gt; Sorsonet = (1, 1, 2, 2, 2, 2, 2)\n    &gt;&gt;&gt; Bemba = (2, 1, 2, 2, 2, 1, 2)\n    &gt;&gt;&gt; Ashanti = (2, 1, 2, 2, 1, 2, 2)\n    &gt;&gt;&gt; ten_tuples = (Asaadua, Ashanti, Bemba, Bemb\u00e9, Bemb\u00e9_2, Soli, Sorsonet, Tamb\u00fa, Tonada, Yoruba)\n\n    Collectively, they have 3 distinct patterns.\n\n    &gt;&gt;&gt; len(rotation_distinct_patterns(ten_tuples))\n    3\n\n    \"\"\"\n    return_values = [vector_patterns[0]]  # At least one\n    for index in range(1, len(vector_patterns)):\n        for prototype in return_values:\n            if is_rotation_equivalent(prototype, vector_patterns[index]):\n                return_values.append(vector_patterns[index])\n                break\n\n    return tuple(return_values)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_indices","title":"indicator_to_indices","text":"<pre><code>indicator_to_indices(\n    vector: list[int] | tuple[int, ...], wrap: bool = False\n) -&gt; tuple\n</code></pre> <p>Simple mapping from an indicator vector for where events fall, to a tuple of the corresponding indices.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>a tuple containing the indices for which <code>vector</code> is non-zero.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1) # adjacent only\n&gt;&gt;&gt; indicator_to_indices(bemb\u00e9)\n(0, 2, 4, 5, 7, 9, 11)\n</code></pre> <pre><code>&gt;&gt;&gt; indicator_to_indices(bemb\u00e9, wrap=True)\n(0, 2, 4, 5, 7, 9, 11, 12)\n</code></pre> <pre><code>&gt;&gt;&gt; shiko = (1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0) # adjacent only\n&gt;&gt;&gt; indicator_to_indices(shiko)\n(0, 4, 6, 10, 12)\n</code></pre> <pre><code>&gt;&gt;&gt; indicator_to_indices(shiko, wrap=True)\n(0, 4, 6, 10, 12, 16)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def indicator_to_indices(\n    vector: Union[list[int], tuple[int, ...]], wrap: bool = False\n) -&gt; tuple:\n    \"\"\"\n    Simple mapping from an indicator vector for where events fall,\n    to a tuple of the corresponding indices.\n\n    Parameters\n    ----------\n    vector: Union[list[int], tuple[int, ...]]\n        an indicator vector\n\n    wrap: bool\n        if true, the first element of `vector` is appended to `vector`\n        before computing indices, so if the element is non-zero, the\n        length of `vector` will be appear in the result.\n\n    Returns\n    -------\n    tuple[int, ...]\n        a tuple containing the indices for which `vector` is non-zero.\n\n    Examples\n    --------\n    &gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1) # adjacent only\n    &gt;&gt;&gt; indicator_to_indices(bemb\u00e9)\n    (0, 2, 4, 5, 7, 9, 11)\n\n    &gt;&gt;&gt; indicator_to_indices(bemb\u00e9, wrap=True)\n    (0, 2, 4, 5, 7, 9, 11, 12)\n\n    &gt;&gt;&gt; shiko = (1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0) # adjacent only\n    &gt;&gt;&gt; indicator_to_indices(shiko)\n    (0, 4, 6, 10, 12)\n\n    &gt;&gt;&gt; indicator_to_indices(shiko, wrap=True)\n    (0, 4, 6, 10, 12, 16)\n\n    \"\"\"\n    if wrap:\n        vector += (vector[0],)\n\n    set_as_list = list(vector_to_set(vector))\n    set_as_list.sort()\n    return tuple(set_as_list)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_indices(vector)","title":"<code>vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>an indicator vector</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_indices(wrap)","title":"<code>wrap</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>if true, the first element of <code>vector</code> is appended to <code>vector</code> before computing indices, so if the element is non-zero, the length of <code>vector</code> will be appear in the result.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indices_to_indicator","title":"indices_to_indicator","text":"<pre><code>indices_to_indicator(\n    indices_vector: list[int] | tuple[int, ...],\n    indicator_length: int | None = None,\n) -&gt; tuple\n</code></pre> <p>Simple mapping from indices to indicator vector.</p> <p>Parameters:</p> <p>Examples:</p> <p>Round trip</p> <pre><code>&gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n&gt;&gt;&gt; indices = indicator_to_indices(bemb\u00e9)\n&gt;&gt;&gt; indices\n(0, 2, 4, 5, 7, 9, 11)\n</code></pre> <p>No <code>indicator_length</code> is needed for default</p> <pre><code>&gt;&gt;&gt; round_trip = indices_to_indicator(indices)\n&gt;&gt;&gt; round_trip\n(1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; round_trip == bemb\u00e9\nTrue\n</code></pre> <p>The <code>indicator_length</code> can, however, be specified:</p> <pre><code>&gt;&gt;&gt; indices_to_indicator(indices, indicator_length=12)\n(1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n</code></pre> <p>And the <code>indicator_length</code> can extend the indicator as needed:</p> <pre><code>&gt;&gt;&gt; indices_to_indicator(indices, indicator_length=14)\n(1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def indices_to_indicator(\n    indices_vector: Union[list[int], tuple[int, ...]],\n    indicator_length: Optional[int] = None,\n) -&gt; tuple:\n    \"\"\"\n    Simple mapping from indices to indicator vector.\n\n    Parameters\n    ----------\n    indices_vector: Union[list[int], tuple[int, ...]]\n        A vector of indices (0, 2, 4, 5, 7, 9, 11).\n        Monotonic increase is expected but not required.\n    indicator_length: Optional[int]\n        optionally specify the length of the output indicator vector.\n        If not specified, we use the highest index in the indices vector.\n\n    Examples\n    --------\n    Round trip\n    &gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n    &gt;&gt;&gt; indices = indicator_to_indices(bemb\u00e9)\n    &gt;&gt;&gt; indices\n    (0, 2, 4, 5, 7, 9, 11)\n\n    No `indicator_length` is needed for default\n\n    &gt;&gt;&gt; round_trip = indices_to_indicator(indices)\n    &gt;&gt;&gt; round_trip\n    (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n\n    &gt;&gt;&gt; round_trip == bemb\u00e9\n    True\n\n    The `indicator_length` can, however, be specified:\n    &gt;&gt;&gt; indices_to_indicator(indices, indicator_length=12)\n    (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n\n    And the `indicator_length` can extend the indicator as needed:\n    &gt;&gt;&gt; indices_to_indicator(indices, indicator_length=14)\n    (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0)\n\n    \"\"\"\n    out = []\n    if indicator_length is None:\n        indicator_length = max(indices_vector) + 1\n    for i in range(indicator_length):\n        if i in indices_vector:\n            out.append(1)\n        else:\n            out.append(0)\n\n    return tuple(out)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indices_to_indicator(indices_vector)","title":"<code>indices_vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>A vector of indices (0, 2, 4, 5, 7, 9, 11). Monotonic increase is expected but not required.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indices_to_indicator(indicator_length)","title":"<code>indicator_length</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>optionally specify the length of the output indicator vector. If not specified, we use the highest index in the indices vector.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_interval","title":"indicator_to_interval","text":"<pre><code>indicator_to_interval(\n    vector: list[int] | tuple[int, ...],\n    wrap: bool = True,\n    adjacent_not_all: bool = True,\n    sequence_not_vector: bool = True,\n) -&gt; tuple\n</code></pre> <p>Given a vector (assumed to be indicator) convert from 1/0 at each index to the intervals between the 1s.</p> <p>Parameters:</p> <p>Examples:</p> <p>Example 1:</p> <pre><code>&gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n</code></pre> <p>Adjacent intervals expressed as a sequence:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(bemb\u00e9)\n(2, 2, 1, 2, 2, 2, 1)\n</code></pre> <p>Wrap is optional:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(bemb\u00e9, wrap=False)\n(2, 2, 1, 2, 2, 2)\n</code></pre> <p>Adjacent intervals expressed as an interval vector:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(bemb\u00e9, sequence_not_vector=False)\n(2, 5, 0, 0, 0, 0)\n</code></pre> <p>All distances (not just the adjacent pairs), which is necessarily expressed as an interval vector:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=False)\n(2, 5, 4, 3, 6, 1)\n</code></pre> <p>Example 2:</p> <pre><code>&gt;&gt;&gt; shiko = (1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n</code></pre> <p>Adjacent intervals expressed as a sequence:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(shiko)\n(4, 2, 4, 2, 4)\n</code></pre> <p>Adjacent intervals expressed as an interval vector:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(shiko, sequence_not_vector=False)\n(0, 2, 0, 3, 0, 0, 0, 0)\n</code></pre> <p>All distances (not just the adjacent pairs), which is necessarily expressed as an interval vector:</p> <pre><code>&gt;&gt;&gt; indicator_to_interval(shiko, adjacent_not_all=False)\n(0, 2, 0, 3, 0, 4, 0, 1)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def indicator_to_interval(\n    vector: Union[list[int], tuple[int, ...]],\n    wrap: bool = True,\n    adjacent_not_all: bool = True,\n    sequence_not_vector: bool = True,\n) -&gt; tuple:\n    \"\"\"\n    Given a vector (assumed to be indicator)\n    convert from 1/0 at each index to the intervals between the 1s.\n\n    Parameters\n    ----------\n    vector: Union[list[int], tuple[int, ...]]\n        an indicator vector representing positions.\n    wrap: bool\n        wrap the cycle, duplicating the first element at the end to include\n        that (possible) interval.\n    adjacent_not_all: bool\n        If True, form the set of intervals between pairs of adjacent positions.\n        If False, form the set of intervals between all pairs.\n    sequence_not_vector: bool\n        In the case of adjacent intervals, True means express the result as an\n        interval sequence, and False means compute an interval vector containing\n        the counts of intervals of size 1, 2, 3, etc. If `adjacent_not_all` is\n        False (meaning all pairs), the result is always an interval vector.\n\n    Examples\n    --------\n    Example 1:\n    &gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n\n    Adjacent intervals expressed as a sequence:\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9)\n    (2, 2, 1, 2, 2, 2, 1)\n\n    Wrap is optional:\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9, wrap=False)\n    (2, 2, 1, 2, 2, 2)\n\n    Adjacent intervals expressed as an interval vector:\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9, sequence_not_vector=False)\n    (2, 5, 0, 0, 0, 0)\n\n    All distances (not just the adjacent pairs), which is necessarily\n    expressed as an interval vector:\n    &gt;&gt;&gt; indicator_to_interval(bemb\u00e9, adjacent_not_all=False)\n    (2, 5, 4, 3, 6, 1)\n\n    Example 2:\n    &gt;&gt;&gt; shiko = (1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n\n    Adjacent intervals expressed as a sequence:\n    &gt;&gt;&gt; indicator_to_interval(shiko)\n    (4, 2, 4, 2, 4)\n\n    Adjacent intervals expressed as an interval vector:\n    &gt;&gt;&gt; indicator_to_interval(shiko, sequence_not_vector=False)\n    (0, 2, 0, 3, 0, 0, 0, 0)\n\n    All distances (not just the adjacent pairs), which is necessarily\n    expressed as an interval vector:\n    &gt;&gt;&gt; indicator_to_interval(shiko, adjacent_not_all=False)\n    (0, 2, 0, 3, 0, 4, 0, 1)\n\n    \"\"\"\n    if adjacent_not_all and wrap:\n        vector += (vector[0],)  # TODO DRY\n\n    indices = indicator_to_indices(vector)\n\n    if adjacent_not_all:\n        sequence = tuple(\n            [indices[i + 1] - indices[i] for i in range(len(indices) - 1)]\n        )\n        if sequence_not_vector:\n            return sequence\n        else:\n            ics = sequence\n    else:  # all\n        ics = [p[1] - p[0] for p in combinations(indices, 2)]\n\n    vector_length = len(vector)\n    half_vector_length = int(vector_length / 2)\n    interval_vector = [0] * half_vector_length\n\n    for ic in ics:\n        if ic &lt; 0:\n            ic *= -1\n        if ic &gt; half_vector_length:\n            ic = vector_length - ic\n        interval_vector[ic - 1] += 1\n    return tuple(interval_vector)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_interval(vector)","title":"<code>vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>an indicator vector representing positions.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_interval(wrap)","title":"<code>wrap</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>wrap the cycle, duplicating the first element at the end to include that (possible) interval.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_interval(adjacent_not_all)","title":"<code>adjacent_not_all</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, form the set of intervals between pairs of adjacent positions. If False, form the set of intervals between all pairs.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.indicator_to_interval(sequence_not_vector)","title":"<code>sequence_not_vector</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>In the case of adjacent intervals, True means express the result as an interval sequence, and False means compute an interval vector containing the counts of intervals of size 1, 2, 3, etc. If <code>adjacent_not_all</code> is False (meaning all pairs), the result is always an interval vector.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.interval_sequence_to_indices","title":"interval_sequence_to_indices","text":"<pre><code>interval_sequence_to_indices(\n    interval_sequence_vector: list[int] | tuple[int, ...],\n    wrap: bool = False,\n) -&gt; tuple[int, ...]\n</code></pre> <p>Given an interval sequence vector, convert to indices.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>A vector containing the positions (indices) that are used.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; interval_sequence_to_indices((3, 3, 2), wrap=False)  # Default\n(0, 3, 6)\n</code></pre> <pre><code>&gt;&gt;&gt; interval_sequence_to_indices((3, 3, 2), wrap=True)\n(0, 3, 6, 8)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def interval_sequence_to_indices(\n    interval_sequence_vector: Union[list[int], tuple[int, ...]],\n    wrap: bool = False,\n) -&gt; tuple[int, ...]:\n    \"\"\"\n    Given an interval sequence vector, convert to indices.\n\n    Parameters\n    ----------\n    interval_sequence_vector: Union[list[int], tuple[int, ...]]\n        a vector of distances (intervals) between adjacent positions\n        that are used.\n    wrap: bool\n        If True, include the index after the end of the sequence\n\n    Returns\n    -------\n    tuple[int, ...]\n        A vector containing the positions (indices) that are used.\n\n    Examples\n    --------\n    &gt;&gt;&gt; interval_sequence_to_indices((3, 3, 2), wrap=False)  # Default\n    (0, 3, 6)\n\n    &gt;&gt;&gt; interval_sequence_to_indices((3, 3, 2), wrap=True)\n    (0, 3, 6, 8)\n\n    \"\"\"\n    indices = [0]\n    count = 0\n    if not wrap:\n        interval_sequence_vector = interval_sequence_vector[:-1]\n    for i in interval_sequence_vector:\n        count += i\n        indices.append(count)\n    return tuple(indices)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.interval_sequence_to_indices(interval_sequence_vector)","title":"<code>interval_sequence_vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>a vector of distances (intervals) between adjacent positions that are used.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.interval_sequence_to_indices(wrap)","title":"<code>wrap</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, include the index after the end of the sequence</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.interval_sequence_to_indicator","title":"interval_sequence_to_indicator","text":"<pre><code>interval_sequence_to_indicator(\n    interval_sequence_vector: list[int] | tuple[int, ...],\n) -&gt; tuple[int, ...]\n</code></pre> <p>Given an interval sequence vector, convert to indicator.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>An indicator vector representing all positions, where used positions contain the value 1.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; interval_sequence_to_indicator((3, 3, 2))\n(1, 0, 0, 1, 0, 0, 1, 0)\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def interval_sequence_to_indicator(\n    interval_sequence_vector: Union[list[int], tuple[int, ...]]\n) -&gt; tuple[int, ...]:\n    \"\"\"\n    Given an interval sequence vector, convert to indicator.\n\n    Parameters\n    ----------\n    interval_sequence_vector: Union[list[int], tuple[int, ...]]\n        the sequence of distances (intervals) between adjacent positions\n        that are used.\n\n    Returns\n    -------\n    tuple[int, ...]\n        An indicator vector representing all positions, where used\n        positions contain the value 1.\n\n    Examples\n    --------\n    &gt;&gt;&gt; interval_sequence_to_indicator((3, 3, 2))\n    (1, 0, 0, 1, 0, 0, 1, 0)\n\n    \"\"\"\n    indices = interval_sequence_to_indices(interval_sequence_vector, wrap=False)\n    indicator = indices_to_indicator(\n        indices, indicator_length=sum(interval_sequence_vector)\n    )\n    return tuple(indicator)\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.interval_sequence_to_indicator(interval_sequence_vector)","title":"<code>interval_sequence_vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>the sequence of distances (intervals) between adjacent positions that are used.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.saturated_subsequence_repetition","title":"saturated_subsequence_repetition","text":"<pre><code>saturated_subsequence_repetition(\n    sequence: list[int] | tuple[int, ...],\n    all_rotations: bool = True,\n    subsequence_period: int | None = None,\n) -&gt; list[list[int]]\n</code></pre> <p>Check if a sequence contains a repeated subsequence such that the subsequence saturates the whole (no sequence items \"left over\"). This is broadly equivalent to a \"periodic sequence\", with the additional constraint of saturatation.</p> <p>This function is a wrapper for an abstraction provided at saturated_subsequence_repetition.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list[int]] | None</code>           \u2013            <p>A list of all subsequences that, if repeated, can form the input <code>sequence</code>. If <code>all_rotations</code>, then also include subsequences that can repeat to form any rotations of <code>sequence</code>. If <code>sequence</code> is not periodic, return None.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_sequence = [1, 2, 1, 2, 1, 2, 1, 2]\n</code></pre> <p>All rotations, all subsequence lengths:</p> <pre><code>&gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, all_rotations=True)\n[[1, 2], [2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]\n</code></pre> <p>No rotations, all subsequence lengths:</p> <pre><code>&gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, all_rotations=False)\n[[1, 2], [1, 2, 1, 2]]\n</code></pre> <p>All rotations, subsequence length fixed at 2:</p> <pre><code>&gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=2, all_rotations=True)\n[[1, 2], [2, 1]]\n</code></pre> <p>All rotations, subsequence length fixed at 4:</p> <pre><code>&gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=4, all_rotations=True)\n[[1, 2, 1, 2], [2, 1, 2, 1]]\n</code></pre> <p>No rotations, subsequence length fixed at 2:</p> <pre><code>&gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=2, all_rotations=False)\n[[1, 2]]\n</code></pre> <p>No rotations, subsequence length fixed at 4:</p> <pre><code>&gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=4, all_rotations=False)\n[[1, 2, 1, 2]]\n</code></pre> Source code in <code>amads/core/vector_transforms_checks.py</code> <pre><code>def saturated_subsequence_repetition(\n    sequence: Union[List[int], tuple[int, ...]],\n    all_rotations: bool = True,\n    subsequence_period: Optional[int] = None,\n) -&gt; List[List[int]]:\n    \"\"\"\n    Check if a sequence contains a repeated subsequence such that\n    the subsequence saturates the whole (no sequence items \"left over\").\n    This is broadly equivalent to a \"periodic sequence\", with the additional\n    constraint of saturatation.\n\n    This function is a wrapper for an abstraction provided at\n    [saturated_subsequence_repetition]\n    [amads.core.vector_transforms_checks.saturated_subsequence_repetition].\n\n    Parameters\n    ----------\n    sequence: Union[list[int], tuple[int, ...]]\n        A vector for event positions in the cycle time span.\n    all_rotations: bool\n        If True, check all rotations of the sequence.\n    subsequence_period: Optional[int]\n        If specified, check only that period length; otherwise,\n        check all factors of n.\n\n    Returns\n    -------\n    Union[List[List[int]], None]\n        A list of all subsequences that, if repeated, can form the input\n        `sequence`. If `all_rotations`, then also include subsequences\n        that can repeat to form any rotations of `sequence`. If\n        `sequence` is not periodic, return None.\n\n    Examples\n    --------\n    &gt;&gt;&gt; test_sequence = [1, 2, 1, 2, 1, 2, 1, 2]\n\n    All rotations, all subsequence lengths:\n\n    &gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, all_rotations=True)\n    [[1, 2], [2, 1], [1, 2, 1, 2], [2, 1, 2, 1]]\n\n    No rotations, all subsequence lengths:\n\n    &gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, all_rotations=False)\n    [[1, 2], [1, 2, 1, 2]]\n\n    All rotations, subsequence length fixed at 2:\n\n    &gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=2, all_rotations=True)\n    [[1, 2], [2, 1]]\n\n    All rotations, subsequence length fixed at 4:\n\n    &gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=4, all_rotations=True)\n    [[1, 2, 1, 2], [2, 1, 2, 1]]\n\n    No rotations, subsequence length fixed at 2:\n    &gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=2, all_rotations=False)\n    [[1, 2]]\n\n    No rotations, subsequence length fixed at 4:\n    &gt;&gt;&gt; saturated_subsequence_repetition(test_sequence, subsequence_period=4, all_rotations=False)\n    [[1, 2, 1, 2]]\n\n    \"\"\"\n    subsequence_periods = []\n    subsequences = []\n\n    if subsequence_period is None:\n        for length in range(1, len(sequence) // 2 + 1):\n            if len(sequence) % length == 0:  # Valid divisor\n                subsequence_periods.append(length)\n    else:\n        subsequence_periods = [subsequence_period]\n\n    for period in subsequence_periods:\n        subsequence = sequence[:period]\n        if subsequence not in subsequences:\n            if all(\n                sequence[i : i + period] == subsequence\n                for i in range(0, len(sequence), period)\n            ):\n                subsequences.append(subsequence)\n\n        if all_rotations:\n            for i in range(\n                1, period\n            ):  # sic, from 1 (0 is done) and only up to the length of the subsequence\n                this_sequence = rotate(sequence, i)\n                subsequence = this_sequence[:period]\n                if subsequence not in subsequences:\n                    if all(\n                        this_sequence[i : i + period] == subsequence\n                        for i in range(0, len(this_sequence), period)\n                    ):\n                        subsequences.append(subsequence)\n\n    return subsequences\n</code></pre>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.saturated_subsequence_repetition(sequence)","title":"<code>sequence</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>A vector for event positions in the cycle time span.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.saturated_subsequence_repetition(all_rotations)","title":"<code>all_rotations</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, check all rotations of the sequence.</p>"},{"location":"reference/vector/#amads.core.vector_transforms_checks.saturated_subsequence_repetition(subsequence_period)","title":"<code>subsequence_period</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>If specified, check only that period length; otherwise, check all factors of n.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.multiset_to_vector","title":"multiset_to_vector","text":"<pre><code>multiset_to_vector(\n    multiset: Iterable, max_index: int | None = None\n) -&gt; tuple[int, ...]\n</code></pre> <p>Converts any \"set\" or \"multiset\" (any iterable object containing only integers) into a \"vector\" (count of those integers organized by index). This is similar to the collections.Counter function, simply returning an ordered tuple instead of a dict.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>The corresponding vector of counts for elements 0, 1, 2, etc.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_multiset = (1, 1, 1, 2, 2, 3)\n&gt;&gt;&gt; vector = multiset_to_vector(test_multiset)\n&gt;&gt;&gt; vector\n(0, 3, 2, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; vector_with_padding = multiset_to_vector(test_multiset, max_index=6)\n&gt;&gt;&gt; vector_with_padding\n(0, 3, 2, 1, 0, 0, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; roundtrip = vector_to_multiset(vector)\n&gt;&gt;&gt; roundtrip\n(1, 1, 1, 2, 2, 3)\n</code></pre> <pre><code>&gt;&gt;&gt; roundtrip == test_multiset\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; test_set = (1, 2, 3)\n&gt;&gt;&gt; vector_2 = multiset_to_vector(test_set)\n&gt;&gt;&gt; vector_2\n(0, 1, 1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; set_roundtrip = vector_to_multiset(vector_2)\n&gt;&gt;&gt; set_roundtrip\n(1, 2, 3)\n</code></pre> <pre><code>&gt;&gt;&gt; set_roundtrip == test_set\nTrue\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def multiset_to_vector(\n    multiset: Iterable,\n    max_index: Union[int, None] = None,\n) -&gt; tuple[int, ...]:\n    \"\"\"\n    Converts any \"set\" or \"multiset\" (any iterable object containing only integers)\n    into a \"vector\" (count of those integers organized by index).\n    This is similar to the collections.Counter function, simply returning\n    an ordered tuple instead of a dict.\n\n    Parameters\n    ----------\n    multiset : Iterable\n        The input integers as an iterable object (list, tuple, set).\n        Multisets are accepted but not required (i.e., sets as trivial cases of multisets).\n    max_index: Union[int, None]\n        Sets the maximum index of the output vector.\n        If None, use the maximum value of the input set.\n\n    Returns\n    -------\n    tuple[int, ...]\n        The corresponding vector of counts for elements 0, 1, 2, etc.\n\n    Examples\n    --------\n    &gt;&gt;&gt; test_multiset = (1, 1, 1, 2, 2, 3)\n    &gt;&gt;&gt; vector = multiset_to_vector(test_multiset)\n    &gt;&gt;&gt; vector\n    (0, 3, 2, 1)\n\n    &gt;&gt;&gt; vector_with_padding = multiset_to_vector(test_multiset, max_index=6)\n    &gt;&gt;&gt; vector_with_padding\n    (0, 3, 2, 1, 0, 0, 0)\n\n    &gt;&gt;&gt; roundtrip = vector_to_multiset(vector)\n    &gt;&gt;&gt; roundtrip\n    (1, 1, 1, 2, 2, 3)\n\n    &gt;&gt;&gt; roundtrip == test_multiset\n    True\n\n    &gt;&gt;&gt; test_set = (1, 2, 3)\n    &gt;&gt;&gt; vector_2 = multiset_to_vector(test_set)\n    &gt;&gt;&gt; vector_2\n    (0, 1, 1, 1)\n\n    &gt;&gt;&gt; set_roundtrip = vector_to_multiset(vector_2)\n    &gt;&gt;&gt; set_roundtrip\n    (1, 2, 3)\n\n    &gt;&gt;&gt; set_roundtrip == test_set\n    True\n\n    \"\"\"\n    if max_index is None:\n        max_index = max(multiset)\n    counts = [0] * (max_index + 1)\n    for item in multiset:\n        counts[item] += 1\n\n    return tuple(counts)\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.multiset_to_vector(multiset)","title":"<code>multiset</code>","text":"(<code>Iterable</code>)           \u2013            <p>The input integers as an iterable object (list, tuple, set). Multisets are accepted but not required (i.e., sets as trivial cases of multisets).</p>"},{"location":"reference/vector/#amads.core.vectors_sets.multiset_to_vector(max_index)","title":"<code>max_index</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>Sets the maximum index of the output vector. If None, use the maximum value of the input set.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.vector_to_multiset","title":"vector_to_multiset","text":"<pre><code>vector_to_multiset(vector: tuple[int, ...]) -&gt; tuple[int, ...]\n</code></pre> <p>Converts any \"vector\" (count of integers organised by index) to a corresponding \"multiset\" (unordered integers).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>The corresponding set as a tuple (because it will often be a multiset).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_vector = (0, 3, 2, 1, 0, 0, 0)\n&gt;&gt;&gt; resulting_set = vector_to_multiset(test_vector)\n&gt;&gt;&gt; resulting_set\n(1, 1, 1, 2, 2, 3)\n</code></pre> <pre><code>&gt;&gt;&gt; roundtrip = multiset_to_vector(resulting_set, max_index=6)\n&gt;&gt;&gt; roundtrip\n(0, 3, 2, 1, 0, 0, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; roundtrip == test_vector\nTrue\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def vector_to_multiset(vector: tuple[int, ...]) -&gt; tuple[int, ...]:\n    \"\"\"\n    Converts any \"vector\" (count of integers organised by index)\n    to a corresponding \"multiset\" (unordered integers).\n\n    Parameters\n    ----------\n    vector:  tuple[int, ...]\n        The input vector where each index i contains the number\n        of occurrences of i.\n\n    Returns\n    -------\n    tuple[int, ...]\n        The corresponding set as a tuple (because it will often be a multiset).\n\n    Examples\n    --------\n    &gt;&gt;&gt; test_vector = (0, 3, 2, 1, 0, 0, 0)\n    &gt;&gt;&gt; resulting_set = vector_to_multiset(test_vector)\n    &gt;&gt;&gt; resulting_set\n    (1, 1, 1, 2, 2, 3)\n\n    &gt;&gt;&gt; roundtrip = multiset_to_vector(resulting_set, max_index=6)\n    &gt;&gt;&gt; roundtrip\n    (0, 3, 2, 1, 0, 0, 0)\n\n    &gt;&gt;&gt; roundtrip == test_vector\n    True\n\n    \"\"\"\n    return tuple(i for i, count in enumerate(vector) for _ in range(count))\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.vector_to_multiset(vector)","title":"<code>vector</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The input vector where each index i contains the number of occurrences of i.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.vector_to_set","title":"vector_to_set","text":"<pre><code>vector_to_set(vector: tuple[int, ...]) -&gt; set\n</code></pre> <p>Converts any \"vector\" of counts to a corresponding \"set\" of the distinct non-0 indices. cf <code>vector_to_multiset</code></p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>set</code>           \u2013            <p>The corresponding set of integers (equivalently, the indices at which the input <code>vector</code> is non-zero.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_vector = (0, 3, 2, 1, 0, 0, 0)\n&gt;&gt;&gt; resulting_set = vector_to_set(test_vector)\n&gt;&gt;&gt; resulting_set\n{1, 2, 3}\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def vector_to_set(vector: tuple[int, ...]) -&gt; set:\n    \"\"\"\n    Converts any \"vector\" of counts to a corresponding \"set\" of the distinct non-0 indices.\n    cf `vector_to_multiset`\n\n    Parameters\n    ----------\n    vector: tuple[int, ...]\n        The input vector. Each index i contains the count of elements\n        equal to i. The vector can therefore be an indicator vector\n        with 0's and 1's.\n\n    Returns\n    -------\n    set\n        The corresponding set of integers (equivalently, the indices\n        at which the input `vector` is non-zero.\n\n    Examples\n    --------\n    &gt;&gt;&gt; test_vector = (0, 3, 2, 1, 0, 0, 0)\n    &gt;&gt;&gt; resulting_set = vector_to_set(test_vector)\n    &gt;&gt;&gt; resulting_set\n    {1, 2, 3}\n    \"\"\"\n    return set(vector_to_multiset(vector))\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.vector_to_set(vector)","title":"<code>vector</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>The input vector. Each index i contains the count of elements equal to i. The vector can therefore be an indicator vector with 0's and 1's.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.weighted_to_indicator","title":"weighted_to_indicator","text":"<pre><code>weighted_to_indicator(\n    weighted_vector: tuple[float, ...], threshold: float = 0.0\n) -&gt; tuple[int, ...]\n</code></pre> <p>Converts a weighted vector to an indicator vector.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>Representing the indicator vector (0s and 1s).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; weighted_vector1 = (0.0, 0.0, 2.0, 0.0)\n&gt;&gt;&gt; weighted_to_indicator(weighted_vector1)\n(0, 0, 1, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; weighted_vector2 = (0.2, 0.0, 1.5, 0.0, 0.01)\n&gt;&gt;&gt; weighted_to_indicator(weighted_vector2)\n(1, 0, 1, 0, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; weighted_to_indicator(weighted_vector2, threshold=0.1)\n(1, 0, 1, 0, 0)\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def weighted_to_indicator(\n    weighted_vector: tuple[float, ...], threshold: float = 0.0\n) -&gt; tuple[int, ...]:\n    \"\"\"\n    Converts a weighted vector to an indicator vector.\n\n    Parameters\n    ----------\n    weighted_vector: tuple[float, ...]\n        Represents the weighted vector.\n    threshold: float\n        Values below this threshold will be set to 0.\n        This handles cases where weights might be very small but not exactly zero.\n\n    Returns\n    -------\n    tuple[int, ...]\n        Representing the indicator vector (0s and 1s).\n\n    Examples\n    --------\n    &gt;&gt;&gt; weighted_vector1 = (0.0, 0.0, 2.0, 0.0)\n    &gt;&gt;&gt; weighted_to_indicator(weighted_vector1)\n    (0, 0, 1, 0)\n\n    &gt;&gt;&gt; weighted_vector2 = (0.2, 0.0, 1.5, 0.0, 0.01)\n    &gt;&gt;&gt; weighted_to_indicator(weighted_vector2)\n    (1, 0, 1, 0, 1)\n\n    &gt;&gt;&gt; weighted_to_indicator(weighted_vector2, threshold=0.1)\n    (1, 0, 1, 0, 0)\n    \"\"\"\n    # The simpler/faster version commented below works but returns a\n    # tuple of np.int which in Python 3.10 prints as \"np.int(1)\"\n    # rather than \"1\" (but in Python 3.12, it prints \"1\" either way).\n\n    # return tuple(np.where(np.array(weighted_vector) &gt; threshold, 1, 0))\n\n    return tuple(\n        x.item() for x in np.where(np.array(weighted_vector) &gt; threshold, 1, 0)\n    )\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.weighted_to_indicator(weighted_vector)","title":"<code>weighted_vector</code>","text":"(<code>tuple[float, ...]</code>)           \u2013            <p>Represents the weighted vector.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.weighted_to_indicator(threshold)","title":"<code>threshold</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Values below this threshold will be set to 0. This handles cases where weights might be very small but not exactly zero.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.apply_constant","title":"apply_constant","text":"<pre><code>apply_constant(\n    set_or_vector: Iterable, constant: float, modulo: int | None = None\n) -&gt; tuple | list | set\n</code></pre> <p>Apply a constant value to a set or vector.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple, list, or set:</code>           \u2013            <p>The set or vector with the constant applied. This return type matches the input type.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; start = (0, 1, 2, 3, 11)\n&gt;&gt;&gt; more = apply_constant(start, 1)\n&gt;&gt;&gt; more\n(1, 2, 3, 4, 12)\n</code></pre> <pre><code>&gt;&gt;&gt; less = apply_constant(more, -1)\n&gt;&gt;&gt; less\n(0, 1, 2, 3, 11)\n</code></pre> <pre><code>&gt;&gt;&gt; start == less\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; more = apply_constant(start, 1, modulo=12)\n&gt;&gt;&gt; more\n(1, 2, 3, 4, 0)\n</code></pre> <pre><code>&gt;&gt;&gt; as_list = [0, 1, 2, 3, 11]\n&gt;&gt;&gt; more_list = apply_constant(as_list, 1)\n&gt;&gt;&gt; more_list\n[1, 2, 3, 4, 12]\n</code></pre> <pre><code>&gt;&gt;&gt; as_set = {0, 1, 2, 3, 11}\n&gt;&gt;&gt; more_set = apply_constant(as_set, 1)\n&gt;&gt;&gt; more_set\n{1, 2, 3, 4, 12}\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def apply_constant(\n    set_or_vector: Iterable,\n    constant: float,\n    modulo: Union[int, None] = None,\n) -&gt; Union[tuple, list, set]:\n    \"\"\"\n    Apply a constant value to a set or vector.\n\n    Parameters\n    ----------\n    set_or_vector:\n        An iterable representing a set or vector.\n    constant:\n        The constant may be an int or a float and positive or negative.\n    modulo:\n        An optional integer.\n        If provided, the result will be taken modulo this value.\n\n    Returns\n    -------\n    tuple, list, or set:\n        The set or vector with the constant applied.\n        This return type matches the input type.\n\n    Examples\n    --------\n    &gt;&gt;&gt; start = (0, 1, 2, 3, 11)\n    &gt;&gt;&gt; more = apply_constant(start, 1)\n    &gt;&gt;&gt; more\n    (1, 2, 3, 4, 12)\n\n    &gt;&gt;&gt; less = apply_constant(more, -1)\n    &gt;&gt;&gt; less\n    (0, 1, 2, 3, 11)\n\n    &gt;&gt;&gt; start == less\n    True\n\n    &gt;&gt;&gt; more = apply_constant(start, 1, modulo=12)\n    &gt;&gt;&gt; more\n    (1, 2, 3, 4, 0)\n\n    &gt;&gt;&gt; as_list = [0, 1, 2, 3, 11]\n    &gt;&gt;&gt; more_list = apply_constant(as_list, 1)\n    &gt;&gt;&gt; more_list\n    [1, 2, 3, 4, 12]\n\n    &gt;&gt;&gt; as_set = {0, 1, 2, 3, 11}\n    &gt;&gt;&gt; more_set = apply_constant(as_set, 1)\n    &gt;&gt;&gt; more_set\n    {1, 2, 3, 4, 12}\n    \"\"\"\n    result = [x + constant for x in set_or_vector]\n    if modulo is not None:\n        result = [x % modulo for x in result]\n\n    if isinstance(set_or_vector, tuple):\n        return tuple(result)\n    elif isinstance(set_or_vector, list):\n        return result\n    elif isinstance(set_or_vector, set):\n        return set(result)\n    else:\n        return result\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.apply_constant(set_or_vector)","title":"<code>set_or_vector</code>","text":"(<code>Iterable</code>)           \u2013            <p>An iterable representing a set or vector.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.apply_constant(constant)","title":"<code>constant</code>","text":"(<code>float</code>)           \u2013            <p>The constant may be an int or a float and positive or negative.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.apply_constant(modulo)","title":"<code>modulo</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>An optional integer. If provided, the result will be taken modulo this value.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.scalar_multiply","title":"scalar_multiply","text":"<pre><code>scalar_multiply(input: tuple, scale_factor: int = 2) -&gt; tuple\n</code></pre> <p>Multiply all values of a tuple.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; scalar_multiply((0, 1, 2))\n(0, 2, 4)\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def scalar_multiply(input: tuple, scale_factor: int = 2) -&gt; tuple:\n    \"\"\"\n    Multiply all values of a tuple.\n\n    Parameters\n    ----------\n    input: tuple\n        a vector\n\n    scale_factor: int\n        The scale factor aka \"multiplicative operand\".\n        Multiply all elements of `input` by this amount.\n        Defaults to 2.\n\n    Examples\n    --------\n    &gt;&gt;&gt; scalar_multiply((0, 1, 2))\n    (0, 2, 4)\n\n    \"\"\"\n    # The simpler/faster version commented below works but returns a\n    # tuple of np.int which in Python 3.10 prints as \"np.int(1)\"\n    # rather than \"1\" (but in Python 3.12, it prints \"1\" either way).\n\n    # return tuple(np.array(input) * scale_factor)\n\n    return tuple(x.item() for x in np.array(input) * scale_factor)\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.scalar_multiply(input)","title":"<code>input</code>","text":"(<code>tuple</code>)           \u2013            <p>a vector</p>"},{"location":"reference/vector/#amads.core.vectors_sets.scalar_multiply(scale_factor)","title":"<code>scale_factor</code>","text":"(<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The scale factor aka \"multiplicative operand\". Multiply all elements of <code>input</code> by this amount. Defaults to 2.</p>"},{"location":"reference/vector/#amads.core.vectors_sets.is_set","title":"is_set","text":"<pre><code>is_set(input: Iterable) -&gt; bool\n</code></pre> <p>Check whether an iterable object is a set (specified in the type) or a de facto set (not in type, but with no repeated elements).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; clear_set = {1, 2, 3}\n&gt;&gt;&gt; is_set(clear_set)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; de_facto_set = (1, 2, 3)\n&gt;&gt;&gt; is_set(de_facto_set)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; de_facto_multiset = (1, 1, 2, 3)\n&gt;&gt;&gt; is_set(de_facto_multiset)\nFalse\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def is_set(input: Iterable) -&gt; bool:\n    \"\"\"\n    Check whether an iterable object is\n    a set (specified in the type) or\n    a de facto set (not in type, but with no repeated elements).\n\n    Examples\n    --------\n    &gt;&gt;&gt; clear_set = {1, 2, 3}\n    &gt;&gt;&gt; is_set(clear_set)\n    True\n\n    &gt;&gt;&gt; de_facto_set = (1, 2, 3)\n    &gt;&gt;&gt; is_set(de_facto_set)\n    True\n\n    &gt;&gt;&gt; de_facto_multiset = (1, 1, 2, 3)\n    &gt;&gt;&gt; is_set(de_facto_multiset)\n    False\n    \"\"\"\n    if isinstance(input, set):\n        return True\n    elif len(set(input)) == len(input):\n        return True\n    return False\n</code></pre>"},{"location":"reference/vector/#amads.core.vectors_sets.is_indicator_vector","title":"is_indicator_vector","text":"<pre><code>is_indicator_vector(vector: tuple) -&gt; bool\n</code></pre> <p>Check whether an input vector (tuple) is an indicator vector, containing only 0s and 1s.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_indicator_vector((0, 1))\nTrue\n</code></pre> <p>Can be all 0s</p> <pre><code>&gt;&gt;&gt; is_indicator_vector((0, 0))\nTrue\n</code></pre> <p>Can be all 1s</p> <pre><code>&gt;&gt;&gt; is_indicator_vector((1, 1))\nTrue\n</code></pre> <p>Cannot have any non-0 or 1 entry</p> <pre><code>&gt;&gt;&gt; is_indicator_vector((1, 2))\nFalse\n</code></pre> <p>Note: cannot be empty</p> <pre><code>&gt;&gt;&gt; is_indicator_vector(())\nFalse\n</code></pre> Source code in <code>amads/core/vectors_sets.py</code> <pre><code>def is_indicator_vector(vector: tuple) -&gt; bool:\n    \"\"\"\n    Check whether an input vector (tuple) is an indicator vector,\n    containing only 0s and 1s.\n\n    Examples\n    --------\n    &gt;&gt;&gt; is_indicator_vector((0, 1))\n    True\n\n    Can be all 0s\n    &gt;&gt;&gt; is_indicator_vector((0, 0))\n    True\n\n    Can be all 1s\n    &gt;&gt;&gt; is_indicator_vector((1, 1))\n    True\n\n    Cannot have any non-0 or 1 entry\n    &gt;&gt;&gt; is_indicator_vector((1, 2))\n    False\n\n    Note: cannot be empty\n    &gt;&gt;&gt; is_indicator_vector(())\n    False\n    \"\"\"\n    if len(vector) == 0:\n        return False\n    if all(x in (0, 1) for x in vector):\n        return True\n    return False\n</code></pre>"},{"location":"reference/algorithms/complexity/","title":"Complexity","text":""},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity","title":"complexity","text":"<p>This module provides functionality for measuring the complexity of discrete sequences using the LZ77 compression algorithm.</p> <p>Author: Huw Cheston (2025)</p> References <ul> <li> <p>Ziv, J., &amp; Lempel, A. (1977). A universal algorithm for sequential data compression.     IEEE Transactions on Information Theory, 23(3), 337\u2013343.     https://doi.org/10.1109/TIT.1977.1055714</p> </li> <li> <p>Cheston, H., Schlichting, J. L., Cross, I., &amp; Harrison, P. M. C. (2024).     Rhythmic qualities of jazz improvisation predict performer identity and style     in source-separated audio recordings. Royal Society Open Science, 11(11).     https://doi.org/10.1098/rsos.240920</p> </li> </ul>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_encode","title":"lz77_encode","text":"<pre><code>lz77_encode(input_list: list[Hashable]) -&gt; list\n</code></pre> <p>Runs the LZ77 compression algorithm over the input <code>data</code>, generating tuples of (distance, length, symbol)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of tuples of (distance, length, symbol) representing the LZ77 encoded data.</p> </li> </ul> Source code in <code>amads/algorithms/complexity.py</code> <pre><code>def lz77_encode(input_list: list[Hashable]) -&gt; list:\n    \"\"\"Runs the LZ77 compression algorithm over the input `data`,\n    generating tuples of (distance, length, symbol)\n\n    Parameters\n    ----------\n    input_list : list[Hashable]\n        The input sequence to be compressed.\n\n    Returns\n    -------\n    list\n        A list of tuples of (distance, length, symbol)\n        representing the LZ77 encoded data.\n    \"\"\"\n\n    # Catch sequences that have a length of zero\n    if len(input_list) == 0:\n        raise ValueError(\"Cannot encode an empty sequence!\")\n    encoded = []\n    i = 0\n    while i &lt; len(input_list):\n        best_length = 0\n        best_distance = 0\n        # Search the entire processed portion (positions 0 to i-1)\n        for j in range(0, i):\n            length = 0\n            # Allow overlapping matches: compare while within input bounds.\n            while (\n                (i + length &lt; len(input_list))\n                and (j + length &lt; len(input_list))\n                and (input_list[j + length] == input_list[i + length])\n            ):\n                length += 1\n            if length &gt; best_length:\n                best_length = length\n                best_distance = i - j\n        # If a match was found, output a match token.\n        if best_length &gt; 0:\n            encoded.append((best_distance, best_length, input_list[i]))\n            i += best_length\n        else:\n            # No match: output a literal token with length 1.\n            encoded.append((0, 1, input_list[i]))\n            i += 1\n    return encoded\n</code></pre>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_encode(input_list)","title":"<code>input_list</code>","text":"(<code>list[Hashable]</code>)           \u2013            <p>The input sequence to be compressed.</p>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_decode","title":"lz77_decode","text":"<pre><code>lz77_decode(encoded: list[tuple[int, int, Hashable]]) -&gt; list[Hashable]\n</code></pre> <p>Decode a list of LZ77 tokens, each of which are 3-tuples with form (distance, length, symbol)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Hashable]</code>           \u2013            <p>The decoded sequence.</p> </li> </ul> Source code in <code>amads/algorithms/complexity.py</code> <pre><code>def lz77_decode(encoded: list[tuple[int, int, Hashable]]) -&gt; list[Hashable]:\n    \"\"\"Decode a list of LZ77 tokens, each of which are 3-tuples with form (distance, length, symbol)\n\n    Parameters\n    ----------\n    encoded : list[tuple[int, int, Hashable]]\n        A list of LZ77 encoded tokens.\n\n    Returns\n    -------\n    list[Hashable]\n        The decoded sequence.\n    \"\"\"\n\n    # Catch sequences that have a length of zero\n    if len(encoded) == 0:\n        raise ValueError(\"Cannot decode an empty sequence!\")\n    decoded = []\n    for token in encoded:\n        distance, length, symbol = token\n        # Literal token: simply append the symbol.\n        if distance == 0:\n            decoded.append(symbol)\n        # Match token: copy 'length' characters from the already decoded list,\n        # starting at position len(decoded) - distance.\n        else:\n            start = len(decoded) - distance\n            for i in range(length):\n                decoded.append(decoded[start + i])\n    return decoded\n</code></pre>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_decode(encoded)","title":"<code>encoded</code>","text":"(<code>list[tuple[int, int, Hashable]]</code>)           \u2013            <p>A list of LZ77 encoded tokens.</p>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_complexity","title":"lz77_complexity","text":"<pre><code>lz77_complexity(\n    sequence: Iterable[Hashable], normalized: bool = False\n) -&gt; int | float\n</code></pre> <p>Compresses a discrete sequence using the LZ77 algorithm and returns the length of the compressed output.</p> <p>This function applies LZ77 compression to a sequence of hashable elements (e.g., strings, floats, integers). Higher compression lengths indicate greater complexity in the sequence.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int | float:</code>           \u2013            <p>The length of the compressed sequence, either as a raw integer or a normalized float.</p> </li> </ul> Source code in <code>amads/algorithms/complexity.py</code> <pre><code>def lz77_complexity(\n    sequence: Iterable[Hashable], normalized: bool = False\n) -&gt; Union[int, float]:\n    \"\"\"\n    Compresses a discrete sequence using the LZ77 algorithm and returns the length of the compressed output.\n\n    This function applies LZ77 compression to a sequence of hashable elements (e.g., strings, floats, integers).\n    Higher compression lengths indicate greater complexity in the sequence.\n\n    Parameters\n    ----------\n    sequence : Iterable[Hashable]\n        A discrete sequence, such as pitch classes or inter-onset intervals.\n\n    normalized : Optional(bool)\n        If True, the result is expressed relative to the input size, where 1.0 indicates\n        maximum complexity (i.e., no compression is possible). Defaults to False.\n\n    Returns\n    -------\n    int | float:\n        The length of the compressed sequence, either as a raw integer or a normalized float.\n    \"\"\"\n\n    # Compress the sequence\n    sequence = list(sequence)\n    compressed = lz77_encode(sequence)\n    # Express with relation to length of input string if required: returns a float\n    if normalized:\n        return len(compressed) / len(sequence)\n    # Otherwise, take the length of the compressed string as the complexity of the input: returns an int\n    else:\n        return len(compressed)\n</code></pre>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_complexity(sequence)","title":"<code>sequence</code>","text":"(<code>Iterable[Hashable]</code>)           \u2013            <p>A discrete sequence, such as pitch classes or inter-onset intervals.</p>"},{"location":"reference/algorithms/complexity/#amads.algorithms.complexity.lz77_complexity(normalized)","title":"<code>normalized</code>","text":"(<code>Optional(bool)</code>, default:                   <code>False</code> )           \u2013            <p>If True, the result is expressed relative to the input size, where 1.0 indicates maximum complexity (i.e., no compression is possible). Defaults to False.</p>"},{"location":"reference/algorithms/entropy/","title":"Entropy","text":""},{"location":"reference/algorithms/entropy/#amads.algorithms.entropy.entropy","title":"entropy","text":"<pre><code>entropy(\n    d: list[float], in_bits=False, miditoolbox_compatible: bool = False\n) -&gt; float\n</code></pre> <p>Calculate the relative entropy of a distribution.</p> <p>This function computes the relative entropy (also known as normalized entropy) of a given distribution <code>d</code>. The result is a value between 0 and 1, where 0 indicates no uncertainty (all probability mass is concentrated in one outcome) and 1 indicates maximum uncertainty (uniform distribution).</p> <p>If <code>in_bits</code> is set to True, the result will be in bits (base 2 logarithm) instead of relative entropy. The <code>in_bits</code> result gives the expected number of bits needed to encode an outcome drawn from the distribution.</p> <p>The distribution <code>d</code> will be normalized if it does not already sum to 1. If <code>d</code> is all zeros, the function will return 1.0 to avoid division by zero. If <code>miditoolbox_compatible</code> is set to True, division by zero is avoided by adding a small constant to the distribution, which will slightly alter the result. (This is to maintain compatibility with the original MIDI Toolbox implementation.)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The relative entropy (0 &lt;= H &lt;= 1) unless <code>in_bits</code> is True, in which case the unnormalized entropy in bits is returned.</p> </li> </ul> Notes <p>Implementation based on the original MATLAB code from: https://github.com/miditoolbox/1.1/blob/master/miditoolbox/entropy.m</p> <p>Examples:</p> <p>Entropy is maximized when all outcomes are equally likely:</p> <pre><code>&gt;&gt;&gt; entropy([0.5, 0.5])\n1.0\n</code></pre> <p>Entropy is minimized when one outcome is certain:</p> <pre><code>&gt;&gt;&gt; entropy([0.0, 1.0])\n0.0\n</code></pre> Source code in <code>amads/algorithms/entropy.py</code> <pre><code>def entropy(\n    d: List[float], in_bits=False, miditoolbox_compatible: bool = False\n) -&gt; float:\n    \"\"\"\n    Calculate the relative entropy of a distribution.\n\n    This function computes the relative entropy (also known as normalized\n    entropy) of a given distribution `d`. The result is a value between 0\n    and 1, where 0 indicates no uncertainty (all probability mass is\n    concentrated in one outcome) and 1 indicates maximum uncertainty\n    (uniform distribution).\n\n    If `in_bits` is set to True, the result will be in bits\n    (base 2 logarithm) instead of relative entropy. The `in_bits`\n    result gives the expected number of bits needed to encode an outcome\n    drawn from the distribution.\n\n    The distribution `d` will be normalized if it does not already sum\n    to 1. If `d` is all zeros, the function will return 1.0 to avoid\n    division by zero. If `miditoolbox_compatible` is set to True, division\n    by zero is avoided by adding a small constant to the distribution,\n    which will slightly alter the result. (This is to maintain compatibility\n    with the original MIDI Toolbox implementation.)\n\n    Parameters\n    ----------\n    d : List[float]\n        The input distribution.\n\n    in_bits : bool, optional\n        If True, returns unnormalized entropy in bits (base 2 logarithm).\n        Default is False: returns relative entropy (0 &lt;= H &lt;= 1).\n\n    miditoolbox_compatible : bool, optional\n        If True, uses the original MIDI Toolbox method of calculation.\n        Default is False.\n\n    Returns\n    -------\n    float\n        The relative entropy (0 &lt;= H &lt;= 1) unless `in_bits` is True,\n        in which case the unnormalized entropy in bits is returned.\n\n    Notes\n    -----\n    Implementation based on the original MATLAB code from:\n    https://github.com/miditoolbox/1.1/blob/master/miditoolbox/entropy.m\n\n    Examples\n    --------\n    Entropy is maximized when all outcomes are equally likely:\n    &gt;&gt;&gt; entropy([0.5, 0.5])\n    1.0\n\n    Entropy is minimized when one outcome is certain:\n    &gt;&gt;&gt; entropy([0.0, 1.0])\n    0.0\n    \"\"\"\n    darray = np.asarray(d).flatten()  # Convert to a 1D numpy array\n    sum = np.sum(darray)\n    if miditoolbox_compatible:\n        sum += 1e-12  # Avoid division by zero\n    elif sum == 0:\n        return 1.0  # Avoid division by zero; return maximum entropy\n    darray = darray / sum  # Normalize\n    if miditoolbox_compatible:\n        logd = np.log(darray + 1e-12)  # Avoid log(0)\n    else:\n        logd = np.where(\n            darray &gt; 0, np.log(darray), 0\n        )  # Compute log(d), treating log(0) as 0\n    h = -np.sum(darray * logd)\n    if in_bits:\n        h = h / np.log(2)  # Unnormalized entropy in bits\n    else:\n        h = h / np.log(len(darray))  # Normalize to relative entropy\n    return float(h)\n</code></pre>"},{"location":"reference/algorithms/entropy/#amads.algorithms.entropy.entropy(d)","title":"<code>d</code>","text":"(<code>list[float]</code>)           \u2013            <p>The input distribution.</p>"},{"location":"reference/algorithms/entropy/#amads.algorithms.entropy.entropy(in_bits)","title":"<code>in_bits</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, returns unnormalized entropy in bits (base 2 logarithm). Default is False: returns relative entropy (0 &lt;= H &lt;= 1).</p>"},{"location":"reference/algorithms/entropy/#amads.algorithms.entropy.entropy(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, uses the original MIDI Toolbox method of calculation. Default is False.</p>"},{"location":"reference/algorithms/gcd/","title":"GCD - Greatest Common Divisor","text":"<p>Author: Mark Gotham </p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.integer_gcd_pair","title":"integer_gcd_pair","text":"<pre><code>integer_gcd_pair(a: int, b: int) -&gt; int\n</code></pre> <p>Calculates the greatest common divisor (GCD) of two integers using the Euclidean algorithm.</p> <p>integer_gcd_pair(0, 2) 2</p> <p>integer_gcd_pair(15, 16) 1</p> <p>integer_gcd_pair(8, 16) 8</p> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def integer_gcd_pair(a: int, b: int) -&gt; int:\n    \"\"\"\n    Calculates the greatest common divisor (GCD) of two integers using the\n    Euclidean algorithm.\n\n    &gt;&gt;&gt; integer_gcd_pair(0, 2)\n    2\n\n    &gt;&gt;&gt; integer_gcd_pair(15, 16)\n    1\n\n    &gt;&gt;&gt; integer_gcd_pair(8, 16)\n    8\n\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return a\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd_pair","title":"float_gcd_pair","text":"<pre><code>float_gcd_pair(\n    a: float, b: float = 1.0, rtol=1e-05, atol=1e-08\n) -&gt; float\n</code></pre> <p>Calculate approximate greatest common divisor (GCD) for values a and b given the specified relative and absolute tolerance (<code>rtol</code> and <code>atol</code>). With thanks to Euclid, <code>fractions.gcd</code>, and <code>stackexchange &lt;https://stackoverflow.com/questions/45323619/&gt;</code>_.</p> <p>Tolerance values should be set in relation to the granularity (e.g., pre-rounding) of the input data.</p> Warning <pre><code>Float GCD calcualtion is inherently approximate.\nMixing floats with other types in\n`calculate_gcd` will reduce reliability.\nPrefer `Fraction` where possible.\nFor solutions specific to music, see other modeules in this repo,\nnotably `grid`.\n</code></pre> <p>Parameters:</p> <p>Examples:</p> <p>At risk of failure in both directions. Default tolerance values fail simple cases (2 / 3 to 4d.p.):</p> <pre><code>&gt;&gt;&gt; round(float_gcd_pair(0.6667), 3) # failure\n0.0\n</code></pre> <p>Leaving the value the same, but changing the tolerance to accommodate:</p> <pre><code>&gt;&gt;&gt; round(float_gcd_pair(0.6667, atol=0.001, rtol=0.001), 3) # success\n0.333\n</code></pre> <p>But this same kind of tolerance adjustment can make errors for other, common musical values. 15/16 is a common musical value for which the finer tolerance is effective:</p> <pre><code>&gt;&gt;&gt; fifteen_sixteenths = 15/16\n&gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths)) # success\n16\n</code></pre> <pre><code>&gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths, atol=0.001, rtol=0.001)) # success\n16\n</code></pre> <pre><code>&gt;&gt;&gt; fifteen_sixteenths_3dp = round(fifteen_sixteenths, 3)\n&gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths_3dp)) # failure\n500\n</code></pre> <pre><code>&gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths_3dp, atol=0.001, rtol=0.001)) # failure\n500\n</code></pre> <p>Note that both-zero inputs return zero:</p> <pre><code>&gt;&gt;&gt; float_gcd_pair(0.0, 0.0)\n0.0\n</code></pre> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def float_gcd_pair(a: float, b: float = 1.0, rtol=1e-05, atol=1e-08) -&gt; float:\n    \"\"\"\n    Calculate approximate greatest common divisor (GCD) for values a and b given the specified\n    relative and absolute tolerance (`rtol` and `atol`).\n    With thanks to Euclid,\n    `fractions.gcd`, and\n    `stackexchange &lt;https://stackoverflow.com/questions/45323619/&gt;`_.\n\n    Tolerance values should be set in relation to the granularity\n    (e.g., pre-rounding) of the input data.\n\n    Warning\n    -------\n        Float GCD calcualtion is inherently approximate.\n        Mixing floats with other types in\n        `calculate_gcd` will reduce reliability.\n        Prefer `Fraction` where possible.\n        For solutions specific to music, see other modeules in this repo,\n        notably `grid`.\n\n    Parameters\n    ----------\n    a: float\n        Any float value.\n    b: float\n        Any float value, though typically 1.0 (default) for our use case\n        of measure-relative positioning.\n    rtol\n        the relative tolerance\n    atol\n        the absolute tolerance\n\n    Examples\n    --------\n    At risk of failure in both directions.\n    Default tolerance values fail simple cases (2 / 3 to 4d.p.):\n    &gt;&gt;&gt; round(float_gcd_pair(0.6667), 3) # failure\n    0.0\n\n    Leaving the value the same, but changing the tolerance to accommodate:\n    &gt;&gt;&gt; round(float_gcd_pair(0.6667, atol=0.001, rtol=0.001), 3) # success\n    0.333\n\n    But this same kind of tolerance adjustment can make errors for other,\n    common musical values.\n    15/16 is a common musical value for which the finer tolerance is effective:\n\n    &gt;&gt;&gt; fifteen_sixteenths = 15/16\n    &gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths)) # success\n    16\n\n    &gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths, atol=0.001, rtol=0.001)) # success\n    16\n\n    &gt;&gt;&gt; fifteen_sixteenths_3dp = round(fifteen_sixteenths, 3)\n    &gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths_3dp)) # failure\n    500\n\n    &gt;&gt;&gt; round(1 / float_gcd_pair(fifteen_sixteenths_3dp, atol=0.001, rtol=0.001)) # failure\n    500\n\n    Note that both-zero inputs return zero:\n    &gt;&gt;&gt; float_gcd_pair(0.0, 0.0)\n    0.0\n\n    \"\"\"\n    if a == 0.0 and b == 0.0:\n        return 0.0\n    t = min(abs(a), abs(b))\n    while abs(b) &gt; rtol * t + atol:\n        a, b = b, a % b\n    return a\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd_pair(a)","title":"<code>a</code>","text":"(<code>float</code>)           \u2013            <p>Any float value.</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd_pair(b)","title":"<code>b</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Any float value, though typically 1.0 (default) for our use case of measure-relative positioning.</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd_pair(rtol)","title":"<code>rtol</code>","text":"\u2013            <p>the relative tolerance</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd_pair(atol)","title":"<code>atol</code>","text":"\u2013            <p>the absolute tolerance</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.fraction_gcd_pair","title":"fraction_gcd_pair","text":"<pre><code>fraction_gcd_pair(x: Fraction, y: Fraction) -&gt; Fraction\n</code></pre> <p>Compute the GCD of two fractions using the equivalence between gcd(a/b, c/d) and gcd(a, c)/lcm(b, d)</p> <p>This function compares exactly two fractions (x and y). For a longer list, use <code>fraction_gcd</code>.</p> <p>Returns:</p> <ul> <li> <code>Fraction</code>           \u2013            <p>The GCD of <code>x</code> and <code>y</code>, which is always simplified.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fraction_gcd_pair(Fraction(1, 2), Fraction(2, 3))\nFraction(1, 6)\n</code></pre> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def fraction_gcd_pair(x: Fraction, y: Fraction) -&gt; Fraction:\n    \"\"\"\n    Compute the GCD of two fractions using the\n    equivalence between gcd(a/b, c/d) and gcd(a, c)/lcm(b, d)\n\n    This function compares exactly two fractions (x and y).\n    For a longer list, use `fraction_gcd`.\n\n    Returns\n    -------\n    Fraction\n        The GCD of `x` and `y`, which is always simplified.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fraction_gcd_pair(Fraction(1, 2), Fraction(2, 3))\n    Fraction(1, 6)\n\n    \"\"\"\n    return Fraction(\n        integer_gcd_pair(x.numerator, y.numerator),\n        lcm_pair(x.denominator, y.denominator),\n    )\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.lcm_pair","title":"lcm_pair","text":"<pre><code>lcm_pair(a: int, b: int) -&gt; int\n</code></pre> <p>Compute the Lowest Common Multiple (LCM) of two integers.</p> <p>lcm_pair(8, 16) 16</p> <p>lcm_pair(2, 3) 6</p> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def lcm_pair(a: int, b: int) -&gt; int:\n    \"\"\"\n    Compute the Lowest Common Multiple (LCM) of two integers.\n\n    &gt;&gt;&gt; lcm_pair(8, 16)\n    16\n\n    &gt;&gt;&gt; lcm_pair(2, 3)\n    6\n\n    \"\"\"\n    return a * b // integer_gcd_pair(a, b)\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.fraction_gcd","title":"fraction_gcd","text":"<pre><code>fraction_gcd(fractions: list[Fraction]) -&gt; Fraction\n</code></pre> <p>Compute GCD where all elements are known/asserted to be Fractions. See <code>fraction_gcd_pair</code>.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>fractions</code> is empty.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Fraction</code>           \u2013            <p>The GCD of all Fractions in <code>fractions</code>.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; fraction_gcd([Fraction(1, 2), Fraction(2, 3), Fraction(5, 12)])\nFraction(1, 12)\n</code></pre> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def fraction_gcd(fractions: list[Fraction]) -&gt; Fraction:\n    \"\"\"\n    Compute GCD where all elements are known/asserted to be Fractions.\n    See `fraction_gcd_pair`.\n\n    Raises\n    ------\n    ValueError\n        If `fractions` is empty.\n\n    Returns\n    -------\n    Fraction\n        The GCD of all Fractions in `fractions`.\n\n    Examples\n    --------\n    &gt;&gt;&gt; fraction_gcd([Fraction(1, 2), Fraction(2, 3), Fraction(5, 12)])\n    Fraction(1, 12)\n\n    \"\"\"\n    if not fractions:\n        raise ValueError(\"fractions must not be empty\")\n    gcd = fractions[0]\n    for i in range(1, len(fractions)):\n        gcd = fraction_gcd_pair(gcd, fractions[i])\n    return gcd\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd","title":"float_gcd","text":"<pre><code>float_gcd(floats: list[float], rtol=1e-05, atol=1e-08) -&gt; float\n</code></pre> <p>Calculate GCD for a list of floats given the specified relative and absolute tolerance (<code>rtol</code> and <code>atol</code>).</p> <p>If the values are known to be integers use <code>integer_gcd</code>, known to be Fractions use <code>fraction_gcd</code>, and if the type is not known use <code>calculate_gcd</code>.</p> Warning <pre><code>Float GCD is inherently approximate.\nSee `float_gcd_pair` for details.\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>floats</code> is empty.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def float_gcd(floats: list[float], rtol=1e-05, atol=1e-08) -&gt; float:\n    \"\"\"\n    Calculate GCD for a list of floats given the specified\n    relative and absolute tolerance (`rtol` and `atol`).\n\n    If the values are known to be integers use `integer_gcd`, known to be\n    Fractions use `fraction_gcd`, and if the type is not known use\n    `calculate_gcd`.\n\n    Warning\n    -------\n        Float GCD is inherently approximate.\n        See `float_gcd_pair` for details.\n\n    Raises\n    ------\n    ValueError\n        If `floats` is empty.\n\n    Parameters\n    ----------\n    floats: list[float]\n        Any float values.\n    rtol\n        the relative tolerance\n    atol\n        the absolute tolerance\n\n    \"\"\"\n    if not floats:\n        raise ValueError(\"floats must not be empty\")\n    gcd = floats[0]\n    for i in range(1, len(floats)):\n        gcd = float_gcd_pair(gcd, floats[i], rtol=rtol, atol=atol)\n    return gcd\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd(floats)","title":"<code>floats</code>","text":"(<code>list[float]</code>)           \u2013            <p>Any float values.</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd(rtol)","title":"<code>rtol</code>","text":"\u2013            <p>the relative tolerance</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.float_gcd(atol)","title":"<code>atol</code>","text":"\u2013            <p>the absolute tolerance</p>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.integer_gcd","title":"integer_gcd","text":"<pre><code>integer_gcd(integers: list[int]) -&gt; int\n</code></pre> <p>Compute GCD where the elements are known/asserted to be integers. See <code>integer_gcd_pair</code>.</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>integers</code> is empty.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The GCD of all elements in the list.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; integer_gcd([0, 2, 4])\n2\n</code></pre> <pre><code>&gt;&gt;&gt; integer_gcd([0, 15, 16])\n1\n</code></pre> <pre><code>&gt;&gt;&gt; integer_gcd([0, 8, 16])\n8\n</code></pre> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def integer_gcd(integers: list[int]) -&gt; int:\n    \"\"\"\n    Compute GCD where the elements are known/asserted to be integers.\n    See `integer_gcd_pair`.\n\n    Raises\n    ------\n    ValueError\n        If `integers` is empty.\n\n    Returns\n    -------\n    int\n        The GCD of all elements in the list.\n\n    Examples\n    --------\n    &gt;&gt;&gt; integer_gcd([0, 2, 4])\n    2\n\n    &gt;&gt;&gt; integer_gcd([0, 15, 16])\n    1\n\n    &gt;&gt;&gt; integer_gcd([0, 8, 16])\n    8\n\n    \"\"\"\n    if not integers:\n        raise ValueError(\"integers must not be empty\")\n    gcd = integers[0]\n    for i in range(1, len(integers)):\n        gcd = integer_gcd_pair(gcd, integers[i])\n    return gcd\n</code></pre>"},{"location":"reference/algorithms/gcd/#amads.algorithms.gcd.calculate_gcd","title":"calculate_gcd","text":"<pre><code>calculate_gcd(numbers: list)\n</code></pre> <p>Compute GCD. Wrapper function when you don't know the type of the numeric data. If the value type is known (integer, fractions, float), use the more specific <code>{type}_gcd</code> function.</p> <p>Integers and fractions are lossless and processed first, before any floats.</p> Warning <pre><code>Mixing floats with other numeric types reduces reliability.\nPrefer `Fraction` where possible.\n</code></pre> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>numbers</code> is empty.</p> </li> <li> <code>&gt;&gt;&gt; calculate_gcd([1, 2])</code>             \u2013            </li> <li> <code>Fraction(1, 1)</code>             \u2013            </li> <li> <code>&gt;&gt;&gt; calculate_gcd([1, Fraction(1, 2), 2])</code>             \u2013            </li> <li> <code>Fraction(1, 2)</code>             \u2013            </li> <li> <code>&gt;&gt;&gt; calculate_gcd([0, 1/2])</code>             \u2013            </li> <li> <code>0.5</code>             \u2013            </li> <li> <code>&gt;&gt;&gt; calculate_gcd([0, Fraction(1, 2), 1/2])</code>             \u2013            </li> <li> <code>Fraction(1, 2)</code>             \u2013            </li> <li> <code>&gt;&gt;&gt; gcd = calculate_gcd([0, Fraction(1, 2), 4/12])</code>             \u2013            </li> <li> <code>&gt;&gt;&gt; round(gcd, 3)</code>             \u2013            </li> <li> <code>0.167</code>             \u2013            </li> <li> <code>All-float input is supported:</code>             \u2013            </li> <li> <code>&gt;&gt;&gt; calculate_gcd([0.5, 0.25])</code>             \u2013            </li> <li> <code>0.25</code>             \u2013            </li> </ul> Source code in <code>amads/algorithms/gcd.py</code> <pre><code>def calculate_gcd(numbers: list):\n    \"\"\"\n    Compute GCD.\n    Wrapper function when you don't know the type of the numeric data.\n    If the value type is known (integer, fractions, float),\n    use the more specific ``{type}_gcd`` function.\n\n    Integers and fractions are lossless and processed first, before any floats.\n\n    Warning\n    -------\n        Mixing floats with other numeric types reduces reliability.\n        Prefer `Fraction` where possible.\n\n    Raises\n    ------\n    ValueError\n        If `numbers` is empty.\n\n    &gt;&gt;&gt; calculate_gcd([1, 2])\n    Fraction(1, 1)\n\n    &gt;&gt;&gt; calculate_gcd([1, Fraction(1, 2), 2])\n    Fraction(1, 2)\n\n    &gt;&gt;&gt; calculate_gcd([0, 1/2])\n    0.5\n\n    &gt;&gt;&gt; calculate_gcd([0, Fraction(1, 2), 1/2])\n    Fraction(1, 2)\n\n    &gt;&gt;&gt; gcd = calculate_gcd([0, Fraction(1, 2), 4/12])\n    &gt;&gt;&gt; round(gcd, 3)\n    0.167\n\n    All-float input is supported:\n    &gt;&gt;&gt; calculate_gcd([0.5, 0.25])\n    0.25\n\n    \"\"\"\n    if not numbers:\n        raise ValueError(\"numbers must not be empty\")\n\n    floats = [num for num in numbers if isinstance(num, float)]\n    ints_fractions = [num for num in numbers if not isinstance(num, float)]\n\n    if ints_fractions:\n        gcd = Fraction(ints_fractions[0])\n        for num in ints_fractions[1:]:\n            gcd = fraction_gcd_pair(Fraction(num), gcd)\n        for f in floats:\n            gcd = float_gcd_pair(f, gcd)\n    else:\n        # All floats\n        gcd = floats[0]\n        for f in floats[1:]:\n            gcd = float_gcd_pair(f, gcd)\n\n    return gcd\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/","title":"Mtype tokenizer","text":""},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MelodyTokenizer","title":"MelodyTokenizer","text":"<pre><code>MelodyTokenizer()\n</code></pre> <p>Abstract base class for tokenizing melodies into n-grams.</p> <p>Methods:</p> <ul> <li> <code>tokenize</code>             \u2013              <p>Tokenize a melody into phrases. (Unimplemented abstract method.)</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize the tokenizer.\"\"\"\n    self.ioi_data = {}  # Dictionary to store IOI information for notes\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MelodyTokenizer-functions","title":"Functions","text":""},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MelodyTokenizer.tokenize","title":"tokenize","text":"<pre><code>tokenize(score: Score) -&gt; list[list]\n</code></pre> <p>Tokenize a melody into phrases. (Unimplemented abstract method.)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[list]</code>           \u2013            <p>List of tokenized phrases</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>NotImplementedError</code>             \u2013            <p>if this method of MelodyTokenizer is called</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def tokenize(self, score: Score) -&gt; List[List]:\n    \"\"\"Tokenize a melody into phrases. (Unimplemented abstract method.)\n\n    Parameters\n    ----------\n    score : Score\n        A Score object containing a melody\n\n    Returns\n    -------\n    list[list]\n        List of tokenized phrases\n\n    Raises\n    ------\n    NotImplementedError\n        if this method of MelodyTokenizer is called\n    \"\"\"\n    raise NotImplementedError\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MelodyTokenizer.tokenize(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>A Score object containing a melody</p>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer","title":"FantasticTokenizer","text":"<pre><code>FantasticTokenizer()\n</code></pre> <p>               Bases: <code>MelodyTokenizer</code></p> <p>This tokenizer produces the M-Types as defined in the FANTASTIC toolbox [1].</p> <p>An M-Type is a sequence of musical symbols (pitch intervals and duration ratios) that represents a melodic fragment, similar to how an n-gram represents a sequence of n consecutive items from a text. The length of an M-Type can vary, just like n-grams can be of different lengths (bigrams, trigrams, etc.)</p> <p>The tokenizer takes a score as the input, and returns a dictionary of unique M-Type (n-gram) counts.</p> <p>Attributes:</p> <ul> <li> <code>phrase_gap</code>               (<code>float</code>)           \u2013            <p>Time gap in seconds that defines phrase boundaries</p> </li> <li> <code>tokens</code>               (<code>list</code>)           \u2013            <p>List of tokens after tokenization</p> </li> </ul> References <p>[1] M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology Accessing     STatistics (In a Corpus): Technical Report v1.5</p> <p>Methods:</p> <ul> <li> <code>tokenize</code>             \u2013              <p>Tokenize a melody into M-Types.</p> </li> <li> <code>classify_pitch_interval</code>             \u2013              <p>Classify pitch interval according to Fantastic's interval class scheme.</p> </li> <li> <code>classify_ioi_ratio</code>             \u2013              <p>Classify an IOI ratio into relative rhythm classes.</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def __init__(self):\n    super().__init__()\n    self.tokens = []\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer-functions","title":"Functions","text":""},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer.tokenize","title":"tokenize","text":"<pre><code>tokenize(score: Score) -&gt; list\n</code></pre> <p>Tokenize a melody into M-Types.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if score has more than one part, if the part has concurrent notes (IOI == 0) or if a Note in the part has a tie.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>List of M-Type tokens</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def tokenize(self, score: Score) -&gt; List:\n    \"\"\"Tokenize a melody into M-Types.\n\n    Parameters\n    ----------\n    score : Score\n        Score object containing melody to tokenize\n\n    Raises\n    ------\n    ValueError\n        if score has more than one part, if the part has concurrent\n        notes (IOI == 0) or if a Note in the part has a tie.\n\n    Returns\n    -------\n    list\n        List of M-Type tokens\n    \"\"\"\n    # Extract notes and calculate IOIs using get_notes\n    notes = score.calc_differences([\"ioi-ratio\", \"interval\"])\n    if len(notes) != 1:\n        raise ValueError(\"score has more than one Part\")\n    notes = notes[0]\n    tokens = []\n\n    # Skip if phrase is too short\n    if len(notes) &lt; 2:\n        return tokens\n\n    for note in notes[1:]:\n        pitch_interval = note.get(\"interval\")\n        pitch_interval_class: Optional[str] = self.classify_pitch_interval(\n            pitch_interval\n        )\n        ioi_ratio_class = self.classify_ioi_ratio(note.get(\"ioi_ratio\"))\n        token = MType(pitch_interval_class, ioi_ratio_class)\n        tokens.append(token)\n    return tokens\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer.tokenize(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>Score object containing melody to tokenize</p>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer.classify_pitch_interval","title":"classify_pitch_interval","text":"<pre><code>classify_pitch_interval(pitch_interval: int | None) -&gt; str | None\n</code></pre> <p>Classify pitch interval according to Fantastic's interval class scheme.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str | None</code>           \u2013            <p>Interval class label (e.g. 'd8', 'd7', 'u2', etc.) 'd' = downward interval, 'u' = upward interval, 's' = same pitch, and 't' = tritone. Returns None if input is None</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def classify_pitch_interval(\n    self, pitch_interval: Optional[int]\n) -&gt; Optional[str]:\n    \"\"\"Classify pitch interval according to Fantastic's interval class scheme.\n\n    Parameters\n    ----------\n    pitch_interval : int or None\n        Interval in semitones between consecutive notes\n\n    Returns\n    -------\n    Optional[str]\n        Interval class label (e.g. 'd8', 'd7', 'u2', etc.)\n        'd' = downward interval,\n        'u' = upward interval,\n        's' = same pitch, and\n        't' = tritone.\n        Returns None if input is None\n    \"\"\"\n    # Clamp interval to [-12, 12] semitone range\n    if pitch_interval is None:\n        return None\n\n    if pitch_interval &lt; -12:\n        pitch_interval = -12\n    elif pitch_interval &gt; 12:\n        pitch_interval = 12\n\n    # Map intervals to class labels based on Fantastic's scheme\n    return self.interval_map[pitch_interval]\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer.classify_pitch_interval(pitch_interval)","title":"<code>pitch_interval</code>","text":"(<code>int or None</code>)           \u2013            <p>Interval in semitones between consecutive notes</p>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer.classify_ioi_ratio","title":"classify_ioi_ratio","text":"<pre><code>classify_ioi_ratio(ioi_ratio: float | None) -&gt; str | None\n</code></pre> <p>Classify an IOI ratio into relative rhythm classes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str or None</code>           \u2013            <p>'q' for quicker (&lt;0.8119), 'e' for equal (0.8119-1.4946), and 'l' for longer (&gt;1.4946). Returns None if input is None.</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def classify_ioi_ratio(self, ioi_ratio: Optional[float]) -&gt; Optional[str]:\n    \"\"\"Classify an IOI ratio into relative rhythm classes.\n\n    Parameters\n    ----------\n    ioi_ratio : float or None\n        Inter-onset interval ratio between consecutive notes\n\n    Returns\n    -------\n    str or None\n        'q' for quicker (&lt;0.8119),\n        'e' for equal (0.8119-1.4946), and\n        'l' for longer (&gt;1.4946).\n        Returns None if input is None.\n    \"\"\"\n    if ioi_ratio is None:\n        return None\n    elif ioi_ratio &lt; 0.8118987:\n        return \"q\"\n    elif ioi_ratio &lt; 1.4945858:\n        return \"e\"\n    else:\n        return \"l\"\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.FantasticTokenizer.classify_ioi_ratio(ioi_ratio)","title":"<code>ioi_ratio</code>","text":"(<code>float or None</code>)           \u2013            <p>Inter-onset interval ratio between consecutive notes</p>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MType","title":"MType","text":"<pre><code>MType(pitch_interval_class: str | None, ioi_ratio_class: str | None)\n</code></pre> <p>A class for representing M-Types.</p> <p>Methods:</p> <ul> <li> <code>__hash__</code>             \u2013              <p>Return the hash based on the integer attribute.</p> </li> <li> <code>__eq__</code>             \u2013              <p>Check equality based on the integer attribute.</p> </li> <li> <code>__repr__</code>             \u2013              <p>Return a string representation of the MType.</p> </li> </ul> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def __init__(\n    self,\n    pitch_interval_class: Optional[str],\n    ioi_ratio_class: Optional[str],\n):\n    self.pitch_interval_class = pitch_interval_class\n    self.ioi_ratio_class = ioi_ratio_class\n    self.integer = self.encode()\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MType-functions","title":"Functions","text":""},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MType.__hash__","title":"__hash__","text":"<pre><code>__hash__()\n</code></pre> <p>Return the hash based on the integer attribute.</p> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def __hash__(self):\n    \"\"\"Return the hash based on the integer attribute.\"\"\"\n    return hash(self.integer)\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MType.__eq__","title":"__eq__","text":"<pre><code>__eq__(other)\n</code></pre> <p>Check equality based on the integer attribute.</p> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"Check equality based on the integer attribute.\"\"\"\n    if isinstance(other, MType):\n        return self.integer == other.integer\n    return False\n</code></pre>"},{"location":"reference/algorithms/mtype_tokenizer/#amads.algorithms.mtype_tokenizer.MType.__repr__","title":"__repr__","text":"<pre><code>__repr__()\n</code></pre> <p>Return a string representation of the MType.</p> Source code in <code>amads/algorithms/mtype_tokenizer.py</code> <pre><code>def __repr__(self):\n    \"\"\"Return a string representation of the MType.\"\"\"\n    return f\"MType {self.integer}\"\n</code></pre>"},{"location":"reference/algorithms/ngrams/","title":"Ngrams","text":""},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter","title":"NGramCounter","text":"<pre><code>NGramCounter()\n</code></pre> <p>A stateful n-gram counter that accumulates counts across multiple sequences.</p> <p>Methods:</p> <ul> <li> <code>count_ngrams</code>             \u2013              <p>Update n-gram counts from a sequence of tokens.</p> </li> <li> <code>reset</code>             \u2013              <p>Reset the n-gram counter to empty.</p> </li> <li> <code>get_counts</code>             \u2013              <p>Get the current n-gram counts.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>yules_k</code>               (<code>float</code>)           \u2013            <p>Calculate Yule's K statistic [1] for the n-gram counts.</p> </li> <li> <code>simpsons_d</code>               (<code>float</code>)           \u2013            <p>Compute mean Simpson's D [1] diversity index over n-grams.</p> </li> <li> <code>sichels_s</code>               (<code>float</code>)           \u2013            <p>Compute Sichel's S statistic over n-grams.</p> </li> <li> <code>honores_h</code>               (<code>float</code>)           \u2013            <p>Compute Honore's H statistic over n-grams.</p> </li> <li> <code>mean_entropy</code>               (<code>float</code>)           \u2013            <p>Compute entropy of n-gram distribution.</p> </li> <li> <code>mean_productivity</code>               (<code>float</code>)           \u2013            <p>Compute mean productivity of n-gram distribution.</p> </li> </ul> Source code in <code>amads/algorithms/ngrams.py</code> <pre><code>def __init__(self):\n    \"\"\"Initialize an empty n-gram counter.\"\"\"\n    self.ngram_counts = (\n        {}\n    )  # Initialize with empty dictionary instead of None\n</code></pre>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter-attributes","title":"Attributes","text":""},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.yules_k","title":"yules_k  <code>property</code>","text":"<pre><code>yules_k: float\n</code></pre> <p>Calculate Yule's K statistic [1] for the n-gram counts.</p> <p>Yule's K is a measure of the rate at which tokens are repeated in a sequence. It is calculated according to the formula: $$ K = 1 / |n| * 1000 * (sum(V(m,N) * m^2) - N) / (N * N) $$ where:</p> <ul> <li>$|n|$ is the number of different n-gram lengths</li> <li>$V(m,N)$ is the number of types with frequency $m$ with $N$ tokens</li> <li>$N$ is the total number of tokens in the sequence</li> <li>$m$ is the index for the frequency class in the frequency distribution</li> </ul> <p>Interpretation:</p> <ul> <li>Higher K values indicate more repetitive sequences</li> <li>Lower K values indicate more diverse sequences with less repetition</li> <li>K is scaled by 1000 to make values more readable</li> </ul> <p>[1] Yule, G. U. 1944. The Statistical Study of Literary Vocabulary. Cambridge University Press.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean Yule's K statistic across all n-gram lengths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>for empty input.</p> </li> </ul>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.simpsons_d","title":"simpsons_d  <code>property</code>","text":"<pre><code>simpsons_d: float\n</code></pre> <p>Compute mean Simpson's D [1] diversity index over n-grams.</p> <p>This is closely mathematically related to the definition of Yule's K. Simpson's D is a measure of diversity in a sequence: $$ D = 1 - sum(n_i * (n_i - 1)) / (N * (N - 1)) $$ where:</p> <ul> <li>$n_i$ is the frequency of the i-th type,</li> <li>$N$ is the total number of tokens in the sequence, and</li> <li>$D$ is the Simpson's D diversity index.</li> </ul> <p>Interpretation:</p> <ul> <li>Higher D values indicate more repetitive sequences where      tokens are often repeated</li> <li>Lower D values indicate more diverse sequences with many      different tokens</li> </ul> <p>[1] Simpson, E. H. 1949. Measurement of diversity. Nature, 163:688</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean Simpson's D value across n-gram lengths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>for empty input.</p> </li> </ul>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.sichels_s","title":"sichels_s  <code>property</code>","text":"<pre><code>sichels_s: float\n</code></pre> <p>Compute Sichel's S statistic over n-grams.</p> <p>Sichel's S is a measure of the proportion of token types that occur exactly twice in a sequence. It is defined as: $$ S = V(2,N)/(|n| * V(N)) $$ where:</p> <ul> <li>$V(2,N)$ is the number of types that occur exactly twice in the sequence</li> <li>$V(N)$ is the total number of types in the sequence</li> <li>$|n|$ is the number of n-gram lengths considered</li> </ul> <p>Interpretation:</p> <ul> <li>Higher S values indicate more types occurring exactly twice</li> <li>Lower S values indicate fewer types occurring exactly twice</li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean Sichel's S value across n-gram lengths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>for empty input.</p> </li> </ul>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.honores_h","title":"honores_h  <code>property</code>","text":"<pre><code>honores_h: float\n</code></pre> <p>Compute Honore's H statistic over n-grams.</p> <p>Honore's H is based on the assumption that the proportion of tokens occurring exactly once is logarithmically related to the total number of tokens in the sequence. It is defined as: $$ H = 100 * (log(N) / (1.01 - (V1/V(N)))) $$ where:</p> <ul> <li>$N$ is the total number of tokens in the sequence</li> <li>$V1$ is the number of types that occur exactly once</li> <li>$V(N)$ : The number of different types in a sequence with N tokens.     This can be interpreted as the size of the token vocabulary of     the sequence.</li> </ul> <p>Interpretation:</p> <ul> <li>Higher H values indicate more lexically rich sequences with      many unique tokens</li> <li>Lower H values indicate more repetitive sequences with fewer      unique tokens</li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean Honore's H value across n-gram lengths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>for empty input.</p> </li> </ul>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.mean_entropy","title":"mean_entropy  <code>property</code>","text":"<pre><code>mean_entropy: float\n</code></pre> <p>Compute entropy of n-gram distribution.</p> <p>For each ngram length n, calculates the Shannon entropy of the ngram distribution and divides by the maximum entropy for that length (log2 N). The mean is then taken over these relative entropy values across all lengths.</p> <p>This is defined as: $$ H = -sum_{i=1}^{N}(p(x_i) * log2(p(x_i))) $$ where:</p> <ul> <li>$H$ is the Shannon entropy</li> <li>$N$ is the total number of tokens in the sequence</li> <li>$p(x_i)$ is the probability of the i-th type</li> </ul> <p>Interpretation:</p> <ul> <li>Higher entropy indicates more random/unpredictable sequences</li> <li>Lower entropy indicates more predictable/structured sequences</li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean Shannon entropy value across n-gram lengths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>for empty input.</p> </li> </ul>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.mean_productivity","title":"mean_productivity  <code>property</code>","text":"<pre><code>mean_productivity: float\n</code></pre> <p>Compute mean productivity of n-gram distribution.</p> <p>Mean productivity is defined as the mean of the number of types occurring only once divided by the total number of tokens. The types occurring only once in a sequence are known as hapax legomena. $$ meanproductivity = sum(V1(N)/|n|) $$ where</p> <ul> <li>$V1(N)$ is the number of types occurring once</li> <li>$|n|$ is the number of n-gram lengths</li> </ul> <p>Interpretation:</p> <ul> <li>Higher productivity indicates more diverse/generative sequences      with many unique tokens</li> <li>Lower productivity indicates more repetitive sequences with fewer      unique tokens</li> </ul> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean productivity value across n-gram lengths.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>for empty input.</p> </li> </ul>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter-functions","title":"Functions","text":""},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.count_ngrams","title":"count_ngrams","text":"<pre><code>count_ngrams(tokens: list, n: int | list | None = None) -&gt; None\n</code></pre> <p>Update n-gram counts from a sequence of tokens.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; tresillo = [3, 3, 2]\n&gt;&gt;&gt; ten_tresillo = tresillo * 10\n&gt;&gt;&gt; ngc = NGramCounter()\n&gt;&gt;&gt; ngc.count_ngrams(tokens=ten_tresillo, n=3)\n&gt;&gt;&gt; ngc.ngram_counts\n{('3', '3', '2'): 10, ('3', '2', '3'): 9, ('2', '3', '3'): 9}\n</code></pre> Source code in <code>amads/algorithms/ngrams.py</code> <pre><code>def count_ngrams(\n    self, tokens: list, n: Union[int, list, None] = None\n) -&gt; None:\n    \"\"\"Update n-gram counts from a sequence of tokens.\n\n    Parameters\n    ----------\n    tokens : list\n        List of tokens to process\n    n : int | list | None\n        If int, count n-grams of that specific length.\n        If list, count n-grams of the specified lengths.\n        If None, count n-grams of all possible lengths.\n\n    Examples\n    --------\n    &gt;&gt;&gt; tresillo = [3, 3, 2]\n    &gt;&gt;&gt; ten_tresillo = tresillo * 10\n    &gt;&gt;&gt; ngc = NGramCounter()\n    &gt;&gt;&gt; ngc.count_ngrams(tokens=ten_tresillo, n=3)\n    &gt;&gt;&gt; ngc.ngram_counts\n    {('3', '3', '2'): 10, ('3', '2', '3'): 9, ('2', '3', '3'): 9}\n\n    \"\"\"\n    # Determine n-gram lengths to count\n    if n is None:\n        n_values = range(1, len(tokens) + 1)\n    elif isinstance(n, int):\n        if n &lt; 1:\n            raise ValueError(f\"n-gram length {n} is less than 1\")\n        if n &gt; len(tokens):\n            raise ValueError(\n                f\"n-gram length {n} is larger than token sequence \"\n                f\"length {len(tokens)}\"\n            )\n        n_values = [n]\n    else:\n        # n is a list\n        for val in n:\n            if not isinstance(val, int):\n                raise TypeError(\n                    f\"n-gram lengths must be integers, got {type(val)}\"\n                )\n            if val &lt; 1:\n                raise ValueError(f\"n-gram length {val} is less than 1\")\n            if val &gt; len(tokens):\n                raise ValueError(\n                    f\"n-gram length {val} is larger than token sequence \"\n                    f\"length {len(tokens)}\"\n                )\n        n_values = n\n\n    # Count n-grams and update the counter\n    for n in n_values:\n        for i in range(len(tokens) - n + 1):\n            # Create hashable n-gram\n            ngram = tuple(str(token) for token in tokens[i : i + n])\n            # Update count in the dictionary\n            self.ngram_counts[ngram] = self.ngram_counts.get(ngram, 0) + 1\n</code></pre>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.count_ngrams(tokens)","title":"<code>tokens</code>","text":"(<code>list</code>)           \u2013            <p>List of tokens to process</p>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.count_ngrams(n)","title":"<code>n</code>","text":"(<code>int | list | None</code>, default:                   <code>None</code> )           \u2013            <p>If int, count n-grams of that specific length. If list, count n-grams of the specified lengths. If None, count n-grams of all possible lengths.</p>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.reset","title":"reset","text":"<pre><code>reset() -&gt; None\n</code></pre> <p>Reset the n-gram counter to empty.</p> Source code in <code>amads/algorithms/ngrams.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"Reset the n-gram counter to empty.\"\"\"\n    self.ngram_counts = {}\n</code></pre>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.get_counts","title":"get_counts","text":"<pre><code>get_counts(n: int | None = None) -&gt; dict\n</code></pre> <p>Get the current n-gram counts.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Dictionary mapping each n-gram to its count</p> </li> </ul> Source code in <code>amads/algorithms/ngrams.py</code> <pre><code>def get_counts(self, n: Optional[int] = None) -&gt; Dict:\n    \"\"\"Get the current n-gram counts.\n\n    Parameters\n    ----------\n    n : int, optional\n        If provided, only return counts for n-grams of this length.\n        If None, return counts for all n-gram lengths.\n\n    Returns\n    -------\n    dict\n        Dictionary mapping each n-gram to its count\n    \"\"\"\n    if n is None:\n        return self.ngram_counts.copy()\n    return {k: v for k, v in self.ngram_counts.items() if len(k) == n}\n</code></pre>"},{"location":"reference/algorithms/ngrams/#amads.algorithms.ngrams.NGramCounter.get_counts(n)","title":"<code>n</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>If provided, only return counts for n-grams of this length. If None, return counts for all n-gram lengths.</p>"},{"location":"reference/algorithms/nnotes/","title":"Nnotes","text":""},{"location":"reference/algorithms/nnotes/#amads.algorithms.nnotes.nnotes","title":"nnotes","text":"<pre><code>nnotes(score: Score, merge_ties: bool = False) -&gt; int\n</code></pre> <p>Returns the number of notes in a musical score.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The number of notes in the score</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from amads.music import example\n&gt;&gt;&gt; from amads.io.readscore import read_score\n&gt;&gt;&gt; import contextlib\n&gt;&gt;&gt; # Load example score while suppressing output:\n&gt;&gt;&gt; with contextlib.redirect_stdout(None):\n...     score = read_score(example.fullpath(\"musicxml/ex3.xml\"))\n&gt;&gt;&gt; nnotes(score)\n2\n&gt;&gt;&gt; nnotes(score, merge_ties=True)\n1\n</code></pre> Source code in <code>amads/algorithms/nnotes.py</code> <pre><code>def nnotes(score: Score, merge_ties: bool = False) -&gt; int:\n    \"\"\"\n    Returns the number of notes in a musical score.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze\n\n    merge_ties : bool\n        Count tied sequences of notes as a single note.\n\n\n    Returns\n    -------\n    int\n        The number of notes in the score\n\n    Examples\n    --------\n    &gt;&gt;&gt; from amads.music import example\n    &gt;&gt;&gt; from amads.io.readscore import read_score\n    &gt;&gt;&gt; import contextlib\n    &gt;&gt;&gt; # Load example score while suppressing output:\n    &gt;&gt;&gt; with contextlib.redirect_stdout(None):\n    ...     score = read_score(example.fullpath(\"musicxml/ex3.xml\"))\n    &gt;&gt;&gt; nnotes(score)\n    2\n    &gt;&gt;&gt; nnotes(score, merge_ties=True)\n    1\n    \"\"\"\n\n    if merge_ties:\n        score = score.merge_tied_notes()  # type: ignore\n    total = 0\n    for _ in score.find_all(Note):\n        total += 1\n    return total\n</code></pre>"},{"location":"reference/algorithms/nnotes/#amads.algorithms.nnotes.nnotes(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze</p>"},{"location":"reference/algorithms/nnotes/#amads.algorithms.nnotes.nnotes(merge_ties)","title":"<code>merge_ties</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Count tied sequences of notes as a single note.</p>"},{"location":"reference/algorithms/norm/","title":"Norm","text":"<p>Author: Mark Gotham </p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm","title":"norm","text":"<p>Local implementation of standard normalization routines centrally for use in various functions.  The local implementation serves to obviate the need for external libraries (e.g., scipy) in basic cases.</p> <p>Comparisons on this module support any pair of profiles.  Example use cases include pitch class profile matching for 'best key' measurement, and the metrical equivalent.</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.euclidean_distance","title":"euclidean_distance","text":"<pre><code>euclidean_distance(\n    profile_1: Iterable, profile_2: Iterable, norm_: bool = False\n) -&gt; float\n</code></pre> <p>The Euclidean distance between two points is the length of the line segment connecting them in N dimensional space and is given by the Pythagorean formula. List length checks are included. Normalization is optional (defaults to False).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; profile_1 = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; profile_2 = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; euclidean_distance(profile_1, profile_2)\n2.23606797749979\n</code></pre> <pre><code>&gt;&gt;&gt; euclidean_distance(profile_1, profile_2, norm_=True)\n0.17474594224380802\n</code></pre> Source code in <code>amads/algorithms/norm.py</code> <pre><code>def euclidean_distance(\n    profile_1: Iterable, profile_2: Iterable, norm_: bool = False\n) -&gt; float:\n    \"\"\"\n    The Euclidean distance between two points\n    is the length of the line segment connecting them in N dimensional space and\n    is given by the Pythagorean formula.\n    List length checks are included.\n    Normalization is optional (defaults to False).\n\n    Examples\n    --------\n    &gt;&gt;&gt; profile_1 = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; profile_2 = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; euclidean_distance(profile_1, profile_2)\n    2.23606797749979\n\n    &gt;&gt;&gt; euclidean_distance(profile_1, profile_2, norm_=True)\n    0.17474594224380802\n\n    \"\"\"\n    shared_length(profile_1, profile_2)\n\n    if norm_:\n        profile_1 = normalize(profile_1, \"l2\")\n        profile_2 = normalize(profile_2, \"l2\")\n    return pnorm_distance(profile_1, profile_2, p=2)\n</code></pre>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.manhattan_distance","title":"manhattan_distance","text":"<pre><code>manhattan_distance(\n    profile_1: Iterable, profile_2: Iterable, norm_: bool = False\n) -&gt; float\n</code></pre> <p>The 'L1' aka 'Manhattan' distance between two points in N dimensional space. The distance is the sum of the absoluted differences along each axis. List length checks are included. Normalization is optional (defaults to False).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; profile_1 = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; profile_2 = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; manhattan_distance(profile_1, profile_2)\n5.0\n</code></pre> <pre><code>&gt;&gt;&gt; manhattan_distance(profile_1, profile_2, norm_=True)\n0.2\n</code></pre> Source code in <code>amads/algorithms/norm.py</code> <pre><code>def manhattan_distance(\n    profile_1: Iterable, profile_2: Iterable, norm_: bool = False\n) -&gt; float:\n    \"\"\"\n    The 'L1' aka 'Manhattan' distance between two points in N dimensional space.\n    The distance is the sum of the absoluted differences along each axis.\n    List length checks are included.\n    Normalization is optional (defaults to False).\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; profile_1 = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; profile_2 = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; manhattan_distance(profile_1, profile_2)\n    5.0\n\n    &gt;&gt;&gt; manhattan_distance(profile_1, profile_2, norm_=True)\n    0.2\n\n    \"\"\"\n    shared_length(profile_1, profile_2)\n    if norm_:\n        profile_1 = normalize(profile_1, \"l1\")\n        profile_2 = normalize(profile_2, \"l1\")\n    return pnorm_distance(profile_1, profile_2, p=1)\n</code></pre>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.normalize","title":"normalize","text":"<pre><code>normalize(\n    profile: Iterable,\n    method: str = \"Euclidean\",\n    round_output: bool = False,\n    round_places: int = 3,\n) -&gt; array\n</code></pre> <p>Normalize usage profiles in standard ways.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>array</code>           \u2013            <p>The normalized vector</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; toy_example = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; normalize(toy_example, method=\"l1\")\narray([0. , 0.1, 0.2, 0.3, 0.4])\n</code></pre> <pre><code>&gt;&gt;&gt; normalize(toy_example, method=\"l2\")\narray([0.        , 0.18257419, 0.36514837, 0.54772256, 0.73029674])\n</code></pre> <pre><code>&gt;&gt;&gt; normalize(toy_example, method=\"l2\", round_output=True, round_places=3)\narray([0.   , 0.183, 0.365, 0.548, 0.73 ])\n</code></pre> <pre><code>&gt;&gt;&gt; normalize(toy_example, method=\"max\")\narray([0.  , 0.25, 0.5 , 0.75, 1.  ])\n</code></pre> Source code in <code>amads/algorithms/norm.py</code> <pre><code>def normalize(\n    profile: Iterable,\n    method: str = \"Euclidean\",\n    round_output: bool = False,\n    round_places: int = 3,\n) -&gt; np.array:\n    \"\"\"\n    Normalize usage profiles in standard ways.\n\n    Parameters\n    ----------\n    profile : list\n        Any 1-D list of numeric data.\n\n    method : str\n        The desired normalization routine. Chose from any of\n\n         - `'Euclidean'` or `'l2'` (scale so that the vector length is 1);\n         - `'Sum'`, `'Manhattan'`, or `'l1'` (divide each value by the total\n            across the profile);\n         - `'max'`, `'maximum'`, `'inf'` or `'infinity'` (divide each value\n            by the largest value).\n\n        These strings are not case-sensitive.\n\n    round_output : bool\n        Optionally, round the output values (default False).\n\n    round_places : int\n        If rounding, how many decimal places to use (default=3).\n        Moot if `round_output` if False (default).\n\n    Returns\n    -------\n    np.array\n        The normalized vector\n\n    Examples\n    --------\n    &gt;&gt;&gt; toy_example = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; normalize(toy_example, method=\"l1\")\n    array([0. , 0.1, 0.2, 0.3, 0.4])\n\n    &gt;&gt;&gt; normalize(toy_example, method=\"l2\")\n    array([0.        , 0.18257419, 0.36514837, 0.54772256, 0.73029674])\n\n    &gt;&gt;&gt; normalize(toy_example, method=\"l2\", round_output=True, round_places=3)\n    array([0.   , 0.183, 0.365, 0.548, 0.73 ])\n\n    &gt;&gt;&gt; normalize(toy_example, method=\"max\")\n    array([0.  , 0.25, 0.5 , 0.75, 1.  ])\n\n    \"\"\"\n\n    if not np.array(profile).any():\n        return profile  # All 0s: don't divide by 0 (or indeed do anything!)\n\n    method = method.lower()\n    if method in l1_names:\n        norm_ord = 1\n    elif method in l2_names:\n        norm_ord = 2\n    elif method in max_names:\n        norm_ord = np.inf\n    else:\n        raise ValueError(\n            f\"Invalid method. Must be one of {l1_names + l2_names + max_names}\"\n        )\n    norm_dist = profile / np.linalg.norm(profile, ord=norm_ord)\n\n    if round_output:\n        return np.round(norm_dist, round_places)\n    else:\n        return norm_dist\n</code></pre>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.normalize(profile)","title":"<code>profile</code>","text":"(<code>list</code>)           \u2013            <p>Any 1-D list of numeric data.</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.normalize(method)","title":"<code>method</code>","text":"(<code>str</code>, default:                   <code>'Euclidean'</code> )           \u2013            <p>The desired normalization routine. Chose from any of</p> <ul> <li><code>'Euclidean'</code> or <code>'l2'</code> (scale so that the vector length is 1);</li> <li><code>'Sum'</code>, <code>'Manhattan'</code>, or <code>'l1'</code> (divide each value by the total     across the profile);</li> <li><code>'max'</code>, <code>'maximum'</code>, <code>'inf'</code> or <code>'infinity'</code> (divide each value     by the largest value).</li> </ul> <p>These strings are not case-sensitive.</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.normalize(round_output)","title":"<code>round_output</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Optionally, round the output values (default False).</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.normalize(round_places)","title":"<code>round_places</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>If rounding, how many decimal places to use (default=3). Moot if <code>round_output</code> if False (default).</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.pnorm_distance","title":"pnorm_distance","text":"<pre><code>pnorm_distance(\n    profile_1: array | Iterable,\n    profile_2: array | Iterable,\n    p: int = 2,\n)\n</code></pre> <p>Calculate the p-norm distance between two vectors.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>The p-norm distance.</code> )          \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; profile_1 = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; profile_2 = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; pnorm_distance(profile_1, profile_2)\n2.23606797749979\n</code></pre> <pre><code>&gt;&gt;&gt; pnorm_distance(profile_1, profile_2, p=1)\n5.0\n</code></pre> Source code in <code>amads/algorithms/norm.py</code> <pre><code>def pnorm_distance(\n    profile_1: np.array | Iterable, profile_2: np.array | Iterable, p: int = 2\n):\n    \"\"\"\n    Calculate the p-norm distance between two vectors.\n\n    Parameters\n    ----------\n    profile_1: list\n        A 1-D numpy array of numeric data.\n    profile_2: list\n        Another 1-D numpy array of numeric data.\n    p: int\n        The order of the normalisation.\n        The default is 2 (for Euclidean distance), alternatives include 1\n        for Manhattan.\n\n    Returns\n    -------\n    float: The p-norm distance.\n\n    Examples\n    --------\n    &gt;&gt;&gt; profile_1 = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; profile_2 = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; pnorm_distance(profile_1, profile_2)\n    2.23606797749979\n\n    &gt;&gt;&gt; pnorm_distance(profile_1, profile_2, p=1)\n    5.0\n\n    \"\"\"\n    vector1 = np.array(profile_1)\n    vector2 = np.array(profile_2)\n    diffs = np.abs(vector1 - vector2)\n    return float(np.sum(diffs**p) ** (1 / p))\n</code></pre>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.pnorm_distance(profile_1)","title":"<code>profile_1</code>","text":"(<code>array | Iterable</code>)           \u2013            <p>A 1-D numpy array of numeric data.</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.pnorm_distance(profile_2)","title":"<code>profile_2</code>","text":"(<code>array | Iterable</code>)           \u2013            <p>Another 1-D numpy array of numeric data.</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.pnorm_distance(p)","title":"<code>p</code>","text":"(<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The order of the normalisation. The default is 2 (for Euclidean distance), alternatives include 1 for Manhattan.</p>"},{"location":"reference/algorithms/norm/#amads.algorithms.norm.shared_length","title":"shared_length","text":"<pre><code>shared_length(profile_1: Iterable, profile_2: Iterable) -&gt; int\n</code></pre> <p>Simple checks that two lists are of the same length. If so, returns the length of the list; if not, raises an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shared_length([1, 2], [2, 1])\n2\n</code></pre> Source code in <code>amads/algorithms/norm.py</code> <pre><code>def shared_length(profile_1: Iterable, profile_2: Iterable) -&gt; int:\n    \"\"\"\n    Simple checks that two lists are of the same length.\n    If so, returns the length of the list; if not, raises an error.\n\n    Examples\n    --------\n    &gt;&gt;&gt; shared_length([1, 2], [2, 1])\n    2\n    \"\"\"\n    ln1 = len(profile_1)\n    ln2 = len(profile_2)\n    if ln2 != ln1:\n        raise ValueError(f\"Lengths (currently {ln1} and {ln2}) must match\")\n    else:\n        return ln1\n</code></pre>"},{"location":"reference/algorithms/scale/","title":"Scale","text":""},{"location":"reference/algorithms/scale/#amads.algorithms.scale.scale","title":"scale","text":"<pre><code>scale(\n    score: EventGroup,\n    factor: float = 2.0,\n    dim: str = \"all\",\n    inplace: bool = False,\n)\n</code></pre> <p>Scale event timings in a score by a given factor.</p> <p>Original MIDI Toolbox doc</p> <p>Note that if notes are tied, scaling by only onset time or only duration will result in tied notes where the offset of the first note is not the same as the onset of the second note.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>EventGroup</code>           \u2013            <p>The scaled version of the input score (modified in place)</p> </li> </ul> Source code in <code>amads/algorithms/scale.py</code> <pre><code>def scale(\n    score: EventGroup,\n    factor: float = 2.0,\n    dim: str = \"all\",\n    inplace: bool = False,\n):\n    \"\"\"Scale event timings in a score by a given factor.\n\n    [Original MIDI Toolbox doc](https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=88)\n\n    Note that if notes are tied, scaling by only onset time or only duration\n    will result in tied notes where the offset of the first note is not the\n    same as the onset of the second note.\n\n    Parameters\n    ----------\n    score : EventGroup\n        Score object or other EventGroup object to be modified\n    factor : float\n        Amount to scale by (must be &gt; 0)\n    dim : {\"onset\", \"duration\", \"all\"}\n        Dimension to scale:\n\n         - 'onset': scales the onset times of all events\n         - 'duration': scales the durations of all non-EventGroup events (Note, Rest)\n         - 'all': scales both onset times and durations\n    inplace : bool\n        If True, modify the input score in place. If False, return a new score\n        object with the scaled timings. (Default value = False)\n\n    Returns\n    -------\n    EventGroup\n        The scaled version of the input score (modified in place)\n    \"\"\"\n    # Algorithm: onset times are scaled when all deltas are scaled.\n    # Note that setting onsets directly is not straightforward: if\n    # you scale the parent onset first (changing the delta) that\n    # will change all the children onsets before you get a chance\n    # to scale them. If you scale the children first, then they\n    # will have incorrect values after you scale the parent.\n\n    if not inplace:\n        score = score.copy()\n    assert dim in [\"all\", \"onset\", \"duration\"]\n    if dim == \"all\":  # do both in place\n        scale(score, factor, \"duration\", True)\n        scale(score, factor, \"onset\", True)\n        return score\n    if dim == \"onset\":\n        score.onset *= factor\n    else:  # dim must be duration\n        score.duration *= factor\n    for elem in score.content:\n        if isinstance(elem, EventGroup):\n            # make the changes in place (inplace=True):\n            scale(elem, factor, dim, True)\n        elif dim == \"onset\":\n            elem.onset *= factor\n        else:  # dim == \"duration\"\n            elem.duration *= factor\n    return score\n</code></pre>"},{"location":"reference/algorithms/scale/#amads.algorithms.scale.scale(score)","title":"<code>score</code>","text":"(<code>EventGroup</code>)           \u2013            <p>Score object or other EventGroup object to be modified</p>"},{"location":"reference/algorithms/scale/#amads.algorithms.scale.scale(factor)","title":"<code>factor</code>","text":"(<code>float</code>, default:                   <code>2.0</code> )           \u2013            <p>Amount to scale by (must be &gt; 0)</p>"},{"location":"reference/algorithms/scale/#amads.algorithms.scale.scale(dim)","title":"<code>dim</code>","text":"(<code>(onset, duration, all)</code>, default:                   <code>\"onset\"</code> )           \u2013            <p>Dimension to scale:</p> <ul> <li>'onset': scales the onset times of all events</li> <li>'duration': scales the durations of all non-EventGroup events (Note, Rest)</li> <li>'all': scales both onset times and durations</li> </ul>"},{"location":"reference/algorithms/scale/#amads.algorithms.scale.scale(inplace)","title":"<code>inplace</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, modify the input score in place. If False, return a new score object with the scaled timings. (Default value = False)</p>"},{"location":"reference/algorithms/slice/","title":"Slice","text":"<p>The <code>algorithms/slice</code> directory contains software pertaining to breaking scores into sequences of \u201cvertical slices,\u201d e.g, the portions of all notes within a sequence of time intervals.</p> <p>In the \u201cSalami Slice\u201d algorithm, time intervals are non-overlapping and their boundaries are all note onset and offset times. A list of slices can be created by calling the <code>salami_slice</code> function. The returned slices are instances of the <code>Slice</code> class.</p> <p>A more basic way to slice a score is to construct a <code>Window</code>, which is basically just a <code>Slice</code> with a special constructor that selects and clips notes that fall within a given time interval, resulting in a single slice. You can create a sequence of <code>Window</code>s using any criteria for time intervals, including overlapping windows.</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami","title":"salami","text":"<p>Salami slice algorithm for segmenting musical scores.</p> <p>This module implements the salami slice algorithm, which segments a musical score into vertical slices at each note onset and offset. Each slice contains all notes that are sounding at that point in time.</p> <p>Author: Peter Harrison</p> <p>Note: The algorithm is named after the way a salami sausage is sliced into thin, vertical segments.</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint","title":"Timepoint  <code>dataclass</code>","text":"<pre><code>Timepoint(\n    time: float,\n    note_ons: list[Note] = list(),\n    note_offs: list[Note] = list(),\n    sounding_notes: set[Note] = set(),\n)\n</code></pre> <p>A point in time with associated note events.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>from_notes</code>             \u2013              <p>Create a sequence of timepoints from a list of notes.</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>last_note_end</code>           \u2013            <p>Get the end time of the last note sounding at this timepoint.</p> </li> </ul>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint(time)","title":"<code>time</code>","text":"(<code>float</code>)           \u2013            <p>The time in seconds</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint(note_ons)","title":"<code>note_ons</code>","text":"(<code>list[Note]</code>, default:                   <code>list()</code> )           \u2013            <p>Notes that start at this timepoint</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint(note_offs)","title":"<code>note_offs</code>","text":"(<code>list[Note]</code>, default:                   <code>list()</code> )           \u2013            <p>Notes that end at this timepoint</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint(sounding_notes)","title":"<code>sounding_notes</code>","text":"(<code>set[Note]</code>, default:                   <code>set()</code> )           \u2013            <p>All notes that are sounding at this timepoint</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint-attributes","title":"Attributes","text":""},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint.last_note_end","title":"last_note_end  <code>property</code>","text":"<pre><code>last_note_end\n</code></pre> <p>Get the end time of the last note sounding at this timepoint.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The end time</p> </li> </ul>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint-functions","title":"Functions","text":""},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint.from_notes","title":"from_notes  <code>classmethod</code>","text":"<pre><code>from_notes(\n    notes: list[Note], time_n_digits: int | None = None\n) -&gt; list[Timepoint]\n</code></pre> <p>Create a sequence of timepoints from a list of notes.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Timepoint]</code>           \u2013            <p>Sequence of timepoints with associated note events</p> </li> </ul> Source code in <code>amads/algorithms/slice/salami.py</code> <pre><code>@classmethod\ndef from_notes(\n    cls, notes: List[Note], time_n_digits: Optional[int] = None\n) -&gt; List[\"Timepoint\"]:\n    \"\"\"Create a sequence of timepoints from a list of notes.\n\n    Parameters\n    ----------\n    notes : List[Note]\n        The notes to process\n    time_n_digits : int, optional\n        Number of decimal places to round times to\n\n    Returns\n    -------\n    List[Timepoint]\n        Sequence of timepoints with associated note events\n    \"\"\"\n    note_ons = defaultdict(list)\n    note_offs = defaultdict(list)\n\n    for note in notes:\n        note_on = note.onset\n        note_off = note.offset\n\n        if time_n_digits is not None:\n            note_on = round(note_on, time_n_digits)\n            note_off = round(note_off, time_n_digits)\n\n        note_ons[note_on].append(note)\n        note_offs[note_off].append(note)\n\n    times = sorted(set(note_ons.keys()) | set(note_offs.keys()))\n\n    timepoints = []\n    sounding_notes = set()\n\n    for time in times:\n        for note in note_offs[time]:\n            sounding_notes.discard(note)\n\n        for note in note_ons[time]:\n            sounding_notes.add(note)\n\n        timepoints.append(\n            Timepoint(\n                time=time,\n                note_ons=note_ons[time],\n                note_offs=note_offs[time],\n                sounding_notes=sorted(\n                    list(sounding_notes), key=lambda n: n.key_num\n                ),\n            )\n        )\n\n    return timepoints\n</code></pre>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint.from_notes(notes)","title":"<code>notes</code>","text":"(<code>list[Note]</code>)           \u2013            <p>The notes to process</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.Timepoint.from_notes(time_n_digits)","title":"<code>time_n_digits</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of decimal places to round times to</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.salami_slice","title":"salami_slice","text":"<pre><code>salami_slice(\n    passage: Score | Iterable[Note],\n    remove_duplicated_pitches: bool = True,\n    include_empty_slices: bool = False,\n    include_note_end_slices: bool = True,\n    min_slice_duration: float = 0.01,\n) -&gt; list[Slice]\n</code></pre> <p>Segment a musical passage into vertical slices at note onsets and offsets ('salami slices').</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Slice]</code>           \u2013            <p>The sequence of vertical slices</p> </li> </ul> Source code in <code>amads/algorithms/slice/salami.py</code> <pre><code>def salami_slice(\n    passage: Union[Score, Iterable[Note]],\n    remove_duplicated_pitches: bool = True,\n    include_empty_slices: bool = False,\n    include_note_end_slices: bool = True,\n    min_slice_duration: float = 0.01,\n) -&gt; List[Slice]:\n    \"\"\"Segment a musical passage into vertical slices at note onsets and offsets ('salami slices').\n\n    Parameters\n    ----------\n    passage : Score or Iterable[Note]\n        The musical passage to slice\n    remove_duplicated_pitches : bool, default=True\n        Whether to remove duplicate pitches within each slice\n    include_empty_slices : bool, default=False\n        Whether to include slices with no sounding notes\n    include_note_end_slices : bool, default=True\n        Whether to create slices at note ends\n    min_slice_duration : float, default=0.01\n        Minimum duration for a slice to be included\n\n    Returns\n    -------\n    List[Slice]\n        The sequence of vertical slices\n    \"\"\"\n    if isinstance(passage, Score):\n        notes = passage.get_sorted_notes()\n    else:\n        notes = passage\n\n    timepoints = Timepoint.from_notes(notes)\n    slices = []\n\n    for i, timepoint in enumerate(timepoints):\n        if len(timepoint.note_ons) &gt; 0 or (\n            include_note_end_slices and len(timepoint.note_offs) &gt; 0\n        ):\n            try:\n                next_timepoint = timepoints[i + 1]\n            except IndexError:\n                next_timepoint = None\n\n            is_last_timepoint = next_timepoint is None\n            is_empty_slice = len(timepoint.sounding_notes) == 0\n\n            if is_empty_slice:\n                if not include_empty_slices:\n                    continue\n                if is_last_timepoint:\n                    # Don't include empty slices at the end of the score\n                    continue\n\n            slice_onset = timepoint.time\n\n            if next_timepoint is None:\n                if len(timepoint.sounding_notes) == 0:\n                    continue\n                else:\n                    slice_end = timepoint.last_note_end\n            else:\n                slice_end = next_timepoint.time\n\n            slice_duration = slice_end - slice_onset\n\n            if slice_duration &lt; min_slice_duration:\n                continue\n\n            pitches = [note.pitch for note in timepoint.sounding_notes]\n            if remove_duplicated_pitches:\n                pitches = sorted(set(pitches))\n\n            slice = Slice(\n                timepoint.sounding_notes, slice_onset, slice_end - slice_onset\n            )\n\n            # construct a new Note for each pitch and add it to the slice\n            for pitch in pitches:\n                Note(slice, slice_onset, slice_duration, pitch)\n\n            slices.append(slice)\n\n    return slices\n</code></pre>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.salami_slice(passage)","title":"<code>passage</code>","text":"(<code>Score or Iterable[Note]</code>)           \u2013            <p>The musical passage to slice</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.salami_slice(remove_duplicated_pitches)","title":"<code>remove_duplicated_pitches</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to remove duplicate pitches within each slice</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.salami_slice(include_empty_slices)","title":"<code>include_empty_slices</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to include slices with no sounding notes</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.salami_slice(include_note_end_slices)","title":"<code>include_note_end_slices</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to create slices at note ends</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.salami.salami_slice(min_slice_duration)","title":"<code>min_slice_duration</code>","text":"(<code>float</code>, default:                   <code>0.01</code> )           \u2013            <p>Minimum duration for a slice to be included</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.slice.Slice","title":"Slice","text":"<pre><code>Slice(\n    original_notes: list[Note], onset: float = 0, duration: float = 0\n)\n</code></pre> <p>               Bases: <code>Concurrence</code></p> <p>A slice of a musical score between two timepoints.</p> <p>This is the base class for different slicing algorithms like salami slicing and windowing. A slice contains a list of notes that are sounding between its start and end times, as well as references to the original notes from which these were derived.</p> <p>Author: Peter Harrison</p> <p>Parameters:</p> Source code in <code>amads/algorithms/slice/slice.py</code> <pre><code>def __init__(\n    self,\n    original_notes: List[Note],\n    onset: float = 0,\n    duration: float = 0,\n):\n    super().__init__(\n        parent=None, onset=onset, duration=duration, content=[]\n    )\n    self.original_notes = original_notes\n</code></pre>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.slice.Slice(original_notes)","title":"<code>original_notes</code>","text":"(<code>list[Note]</code>)           \u2013            <p>The original unmodified notes from which the slice notes were derived</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.slice.Slice(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The start time offset of the slice</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.slice.Slice(duration)","title":"<code>duration</code>","text":"(<code>float</code>, default:                   <code>0</code> )           \u2013            <p>The duration of the slice</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.Window","title":"Window","text":"<pre><code>Window(\n    time: float,\n    size: float,\n    align: str,\n    candidate_notes: Iterable[Note],\n    skip: int = 0,\n)\n</code></pre> <p>               Bases: <code>Slice</code></p> <p>A fixed-size window of a musical score. candidate_notes that overlap with this interval are copied and clipped to fit within the window. Notes that overlap less than 1.0e-6 duration units (whether beats or seconds) are mostly excluded from the window to reduce numerical issues. An exception is made for notes that are so short that they do not overlap any window by at least 1.0e-6 duration units. (This seems far-fetched, but zero-length notes representing grace notes are one possibility to consider; there may be others.)</p> <p>Additional details that you may not need: For very short notes, the window is considered closed on the left and open on the right, so that the window is considered to contain the note if it starts at the same time as the window, and a note is not in the window if it starts at the offset time of the window. To guarantee that zero-length notes are included in only one window, the offset of a window should be identical to the onset of the next window. sliding_window() takes care of this by default, but if the Window constructor is used directly where arithmetic with time and size is inexact, this may not be the case.</p> <p>Author: Peter Harrison</p> <p>Parameters:</p> Source code in <code>amads/algorithms/slice/window.py</code> <pre><code>def __init__(\n    self,\n    time: float,\n    size: float,\n    align: str,\n    candidate_notes: Iterable[Note],\n    skip: int = 0,\n):\n    match align:\n        case \"left\":\n            onset = time\n        case \"center\":\n            onset = time - size / 2\n        case \"right\":\n            onset = time - size\n        case _:\n            raise ValueError(f\"Invalid value passed to `align`: {align}\")\n\n    offset = onset + size\n\n    super().__init__(\n        original_notes=[],\n        onset=onset,\n        duration=size,\n    )\n\n    self.time = time\n    self.align = align\n    # skip logic: skip is the lowest index of candidate_notes for which\n    # candidate_notes[skip].offset &gt;= onset. The next window can start\n    # searching from this index.\n\n    candidate_notes = list(candidate_notes)\n    self.skip = len(candidate_notes)\n\n    for i in range(skip, len(candidate_notes)):\n        note = candidate_notes[i]\n\n        if note.offset &lt; onset:\n            # The note finished before the window starts.\n            continue\n        else:  # note overlaps window, start no later than this\n            # when searching for overlaps with the next window\n            self.skip = min(self.skip, i)\n\n        if note.onset &gt;= offset:\n            # The note starts after the window finishes.\n            # All the remaining notes in candidate_notes will have even later onsets,\n            # so we don't need to check them for this window.\n            # They might be caught by future windows though.\n            break\n\n        # note.onset &lt; offset, so it starts in window\n        if note.offset - offset &lt; 1.0e-6:\n            # The note will not overlap with the next window.\n            # Since it starts in this window, include it.\n            pass\n        elif offset - note.onset &lt; 1.0e-6:\n            # after clipping to window boundaries, this note\n            # will be shorter than 1.0e-6, but it extends into\n            # the next window, so ignore the small overlap here\n            continue\n\n        self.original_notes.append(note)\n\n        # We use deepcopy_into instead of creating a new Note because we want to\n        # preserve any other attributes that might be useful in downstream tasks.\n        note = note.insert_copy_into(parent=self)\n        # Clip the note to fit within the window\n        note.onset = max(note.onset, onset)\n        note.offset = min(note.offset, offset)\n</code></pre>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.Window(time)","title":"<code>time</code>","text":"(<code>float</code>)           \u2013            <p>The reference time for this window</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.Window(size)","title":"<code>size</code>","text":"(<code>float</code>)           \u2013            <p>The size of the window in time units</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.Window(align)","title":"<code>align</code>","text":"(<code>str</code>)           \u2013            <p>How to align the window relative to the reference time: \"left\": window starts at reference time, \"center\": reference time is at window center, or \"right\": window ends at reference time.</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.Window(candidate_notes)","title":"<code>candidate_notes</code>","text":"(<code>Iterable[Note]</code>)           \u2013            <p>Notes to consider for inclusion in this window, sorted by onset time and pitch</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.Window(skip)","title":"<code>skip</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>Index to start searching from in candidate_notes. This is used to optimize performance when iterating through multiple windows - each window can tell the next window which notes it can safely skip because they end before the window starts.</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window","title":"sliding_window","text":"<pre><code>sliding_window(\n    passage: Score | Iterable[Note],\n    size: float,\n    step: float = 1.0,\n    align: str = \"right\",\n    onset: float = 0.0,\n    offset: float | None = None,\n    times: Iterable[float] | None = None,\n) -&gt; Iterator[Window]\n</code></pre> <p>Slice a score into (possibly overlapping) windows of a given size.</p> <p>Author: Peter Harrison</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterator[Window]</code>           \u2013            <p>Iterator over the windows</p> </li> </ul> Source code in <code>amads/algorithms/slice/window.py</code> <pre><code>def sliding_window(\n    passage: Union[Score, Iterable[Note]],\n    size: float,\n    step: float = 1.0,\n    align: str = \"right\",\n    onset: float = 0.0,\n    offset: Optional[float] = None,\n    times: Optional[Iterable[float]] = None,\n) -&gt; Iterator[Window]:\n    \"\"\"Slice a score into (possibly overlapping) windows of a given size.\n\n    &lt;small&gt;**Author**: Peter Harrison&lt;/small&gt;\n\n    Parameters\n    ----------\n    passage : Score or Iterable[Note]\n        The musical passage to be windowed\n    size : float\n        The size (duration) of each window (time units)\n    step : float, default=1.0\n        The step size to take between windows (time units).\n        For example, if step is 0.1, then a given slice will start 0.1 time units\n        after the previous slice started. Note that if step is smaller than size,\n        successive windows will overlap\n    align : str, default=\"right\"\n        Each generated window has a `time` property that points to a\n        particular timepoint in the musical passage. The `align` parameter determines\n        how the window is aligned to this timepoint:\n        - \"left\": the window starts at ``window.time``\n        - \"center\": ``window.time`` corresponds to the midpoint of the window\n        - \"right\": the window finishes at ``window.time``\n    onset : float, default=0.0\n        The desired time of the first window\n    offset : float, optional\n        If set, the windowing will stop once the offset time is reached.\n        Following the behaviour of Python's built-in range function,\n        ``offset`` is not treated inclusively, i.e. the last window will\n        not include ``offset``. The returned iterator will stop early\n        the last window is empty (i.e. contains no notes) and there are\n        no more notes to process.\n    times : Iterable[float], optional\n        Optional iterable of times to generate windows for. If provided,\n        `onset` and `offset` are ignored. The returned iterator will\n        stop once all times have been processed or when an empty window\n        is generated and there are no more notes to process.\n\n    Returns\n    -------\n    Iterator[Window]\n        Iterator over the windows\n    \"\"\"\n    if isinstance(passage, Score):\n        if not passage.is_flat_and_collapsed():\n            raise NotImplementedError(\n                \"Currently this function only supports flat scores with a \"\n                \"single Part. You can flatten a score using \"\n                \"`score.flatten(collapse=True)`.\"\n            )\n        notes = passage.find_all(Note)\n    else:\n        notes = passage\n\n    notes = cast(List[Note], list(notes))\n    notes.sort(key=lambda n: (n.onset, n.pitch))\n\n    # We could rely on Window to obey `align`, but here we convert onset and\n    # offset to always use \"left\". By using left, we can guarantee when\n    # step == size that each window time computed by repeated addition of\n    # step will exactly equal each previous window offset, computed as\n    # onset + size in Window. This avoids any floating point rounding error\n    # that could affect the windowing. (This is not a problem in the typical\n    # cases where window size is 1 or a power of 2 that will be computed\n    # exactly due to binary representations of floats.)\n    match align:\n        case \"left\":\n            pass\n        case \"center\":\n            onset -= size / 2\n            if offset is not None:\n                offset -= size / 2\n        case \"right\":\n            onset -= size\n            if offset is not None:\n                offset -= size\n        case _:\n            raise ValueError(f\"Invalid value passed to `align`: {align}\")\n\n    if times is None:\n        window_times = float_range(onset, offset, step)\n    else:\n        for par, default in [(\"onset\", 0.0), (\"offset\", None), (\"step\", 1.0)]:\n            provided = globals()[par]\n            if provided != default:\n                raise ValueError(\n                    f\"`{par}` was set to {provided} but `times` was also provided\"\n                )\n\n        window_times = times\n\n    skip = 0\n\n    for time in window_times:\n        window = Window(time, size, \"left\", notes, skip)\n\n        yield window\n\n        skip = window.skip\n\n        if skip == len(notes):\n            break\n\n    skip = 0\n    if times is not None:\n        for par, default in [(\"onset\", 0.0), (\"offset\", None), (\"step\", 1.0)]:\n            provided = globals()[par]\n            if provided != default:\n                raise ValueError(\n                    f\"`{par}` was set to {provided} but `times` was also provided\"\n                )\n        for time in times:\n            window = Window(time, size, align, notes, skip)\n\n            yield window\n\n            skip = window.skip\n            if skip == len(notes):\n                break\n    else:  # compute windows equally spaced by step\n        match align:\n            case \"left\":\n                time = onset\n            case \"center\":\n                time = onset - size / 2\n            case \"right\":\n                time = onset - size\n            case _:\n                raise ValueError(f\"Invalid value passed to `align`: {align}\")\n        while (offset is None) or (time &lt; offset):\n            window = Window(time, size, \"left\", notes, skip)\n\n            yield window\n\n            # if step == size, windows are back-to-back, so the next onset\n            # is exactly equal to the previous offset. Avoid\n            onset = window.offset if step == size else onset + step\n            time += step\n            skip = window.skip\n            if skip == len(notes):\n                break\n</code></pre>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(passage)","title":"<code>passage</code>","text":"(<code>Score or Iterable[Note]</code>)           \u2013            <p>The musical passage to be windowed</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(size)","title":"<code>size</code>","text":"(<code>float</code>)           \u2013            <p>The size (duration) of each window (time units)</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(step)","title":"<code>step</code>","text":"(<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>The step size to take between windows (time units). For example, if step is 0.1, then a given slice will start 0.1 time units after the previous slice started. Note that if step is smaller than size, successive windows will overlap</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(align)","title":"<code>align</code>","text":"(<code>str</code>, default:                   <code>\"right\"</code> )           \u2013            <p>Each generated window has a <code>time</code> property that points to a particular timepoint in the musical passage. The <code>align</code> parameter determines how the window is aligned to this timepoint: - \"left\": the window starts at <code>window.time</code> - \"center\": <code>window.time</code> corresponds to the midpoint of the window - \"right\": the window finishes at <code>window.time</code></p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(onset)","title":"<code>onset</code>","text":"(<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>The desired time of the first window</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(offset)","title":"<code>offset</code>","text":"(<code>float</code>, default:                   <code>None</code> )           \u2013            <p>If set, the windowing will stop once the offset time is reached. Following the behaviour of Python's built-in range function, <code>offset</code> is not treated inclusively, i.e. the last window will not include <code>offset</code>. The returned iterator will stop early the last window is empty (i.e. contains no notes) and there are no more notes to process.</p>"},{"location":"reference/algorithms/slice/#amads.algorithms.slice.window.sliding_window(times)","title":"<code>times</code>","text":"(<code>Iterable[float]</code>, default:                   <code>None</code> )           \u2013            <p>Optional iterable of times to generate windows for. If provided, <code>onset</code> and <code>offset</code> are ignored. The returned iterator will stop once all times have been processed or when an empty window is generated and there are no more notes to process.</p>"},{"location":"reference/harmony/consonance/","title":"Consonance","text":""},{"location":"reference/harmony/consonance/#amads.harmony.consonance.consonance.approximate_fraction_consonance","title":"approximate_fraction_consonance","text":"<pre><code>approximate_fraction_consonance(x, d: float = 0.001) -&gt; tuple\n</code></pre> <p>Takes a float and approximates the value as a fraction.</p> <p>Based on [1] via an implementation in R by Peter Harrison.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple</code>           \u2013            <p>A tuple (numerator, denominator) representing the fraction.</p> </li> </ul> References <p>[1] Frieder Stolzenburg. 2015. Harmony perception by periodicity detection. DOI: 10.1080/17459737.2015.1033024</p> <p>Examples:</p> <p>Fine for simple cases:</p> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(0.833)\n(5, 6)\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(0.875)\n(7, 8)\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(0.916)\n(11, 12)\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(0.6666)\n(2, 3)\n</code></pre> <p>Liable to fail in both directions.</p> <pre><code>&gt;&gt;&gt; one_third = 1 / 3\n&gt;&gt;&gt; one_third\n0.3333333333333333\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(one_third)\n(1, 3)\n</code></pre> <pre><code>&gt;&gt;&gt; one_third_3dp = round(one_third, 3)\n&gt;&gt;&gt; one_third_3dp\n0.333\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(one_third_3dp) # fail\n(167, 502)\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(one_third_3dp, d = 0.01) # ... fixed by adapting tolerance\n(1, 3)\n</code></pre> <p>But this same tolerance adjustment makes errors for other, common musical values. 15/16 is a common musical value for which the finer tolerance is effective:</p> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(0.938) # effective at default tolerance value\n(15, 16)\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_fraction_consonance(0.938, d = 0.01) # ... made incorrect by the same tolerance adaptation above\n(14, 15)\n</code></pre> Source code in <code>amads/harmony/consonance/consonance.py</code> <pre><code>def approximate_fraction_consonance(x, d: float = 0.001) -&gt; tuple:\n    \"\"\"\n    Takes a float and approximates the value as a fraction.\n\n    Based on [1] via an implementation in R by Peter Harrison.\n\n    Parameters\n    ----------\n    x: float\n        Input float to be approximated as a fraction.\n    d: float\n        Tolerance ratio.\n\n    Returns\n    -------\n    tuple\n        A tuple (numerator, denominator) representing the fraction.\n\n    References\n    ----------\n    [1] Frieder Stolzenburg. 2015. Harmony perception by periodicity detection.\n    DOI: 10.1080/17459737.2015.1033024\n\n    Examples\n    --------\n    Fine for simple cases:\n\n    &gt;&gt;&gt; approximate_fraction_consonance(0.833)\n    (5, 6)\n\n    &gt;&gt;&gt; approximate_fraction_consonance(0.875)\n    (7, 8)\n\n    &gt;&gt;&gt; approximate_fraction_consonance(0.916)\n    (11, 12)\n\n    &gt;&gt;&gt; approximate_fraction_consonance(0.6666)\n    (2, 3)\n\n    Liable to fail in both directions.\n\n    &gt;&gt;&gt; one_third = 1 / 3\n    &gt;&gt;&gt; one_third\n    0.3333333333333333\n\n    &gt;&gt;&gt; approximate_fraction_consonance(one_third)\n    (1, 3)\n\n    &gt;&gt;&gt; one_third_3dp = round(one_third, 3)\n    &gt;&gt;&gt; one_third_3dp\n    0.333\n\n    &gt;&gt;&gt; approximate_fraction_consonance(one_third_3dp) # fail\n    (167, 502)\n\n    &gt;&gt;&gt; approximate_fraction_consonance(one_third_3dp, d = 0.01) # ... fixed by adapting tolerance\n    (1, 3)\n\n    But this same tolerance adjustment makes errors for other, common musical values.\n    15/16 is a common musical value for which the finer tolerance is effective:\n\n    &gt;&gt;&gt; approximate_fraction_consonance(0.938) # effective at default tolerance value\n    (15, 16)\n\n    &gt;&gt;&gt; approximate_fraction_consonance(0.938, d = 0.01) # ... made incorrect by the same tolerance adaptation above\n    (14, 15)\n    \"\"\"\n\n    x_min = (1 - d) * x\n    x_max = (1 + d) * x\n    a_l = floor(x)\n    b_l = 1\n    a_r = floor(x) + 1\n    b_r = 1\n    a = round(x)\n    b = 1\n\n    while a / b &lt; x_min or x_max &lt; a / b:\n        x_0 = 2 * x - a / b\n        if x &lt; a / b:\n            a_r = a\n            b_r = b\n            k = floor((x_0 * b_l - a_l) / (a_r - x_0 * b_r))\n            a_l = a_l + k * a_r\n            b_l = b_l + k * b_r\n        else:\n            a_l = a\n            b_l = b\n            k = floor((a_r - x_0 * b_r) / (x_0 * b_l - a_l))\n            a_r = a_r + k * a_l\n            b_r = b_r + k * b_l\n        a = a_l + a_r\n        b = b_l + b_r\n\n    return a, b\n</code></pre>"},{"location":"reference/harmony/consonance/#amads.harmony.consonance.consonance.approximate_fraction_consonance(x)","title":"<code>x</code>","text":"\u2013            <p>Input float to be approximated as a fraction.</p>"},{"location":"reference/harmony/consonance/#amads.harmony.consonance.consonance.approximate_fraction_consonance(d)","title":"<code>d</code>","text":"(<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>Tolerance ratio.</p>"},{"location":"reference/harmony/root_finding/","title":"Root finding","text":""},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis","title":"ParncuttRootAnalysis","text":"<pre><code>ParncuttRootAnalysis(\n    chord: list[int] | Chord | PitchCollection,\n    root_support_weights: str | dict[int, float] = \"v2\",\n    exponent: float = 0.5,\n)\n</code></pre> <p>Parncutt's (1988) model for finding the root of a chord.</p> <p>Author: Peter Harrison</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>pc_set</code>               (<code>set</code>)           \u2013            <p>The chord's pitch class set.</p> </li> <li> <code>root</code>               (<code>int</code>)           \u2013            <p>The pitch class of the derived chord root.</p> </li> <li> <code>root_ambiguity</code>               (<code>float</code>)           \u2013            <p>A measure of how ambiguous the root is.</p> </li> <li> <code>root_strengths</code>               (<code>list[float]</code>)           \u2013            <p>Root support values for each pitch class.</p> </li> <li> <code>root_support_weights</code>               (<code>str | dict[int, float]</code>)           \u2013            <p>Identifies the root support weights to use. \"v1\" uses the original weights from Parncutt (1988), \"v2\" uses the updated weights from Parncutt (2006), by default \"v2\".</p> </li> <li> <code>exponent</code>               (<code>float</code>)           \u2013            <p>Exponent to be used when computing root ambiguities, by default 0.5.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # Major triad\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis([60, 64, 67])  # C major triad\n&gt;&gt;&gt; analysis.root\n0\n&gt;&gt;&gt; analysis.root_ambiguity\n1.9\n</code></pre> <pre><code>&gt;&gt;&gt; # Minor triad\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis([60, 63, 67])  # C minor triad\n&gt;&gt;&gt; analysis.root\n0\n&gt;&gt;&gt; analysis.root_ambiguity\n2.1\n</code></pre> <pre><code>&gt;&gt;&gt; # Dominant seventh\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis([60, 64, 67, 70])  # C7\n&gt;&gt;&gt; analysis.root\n0\n&gt;&gt;&gt; analysis.root_ambiguity\n2.1\n</code></pre> <pre><code>&gt;&gt;&gt; # Diminished triad (more ambiguous)\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis([60, 63, 66])  # C diminished\n&gt;&gt;&gt; analysis.root\n0\n&gt;&gt;&gt; analysis.root_ambiguity\n2.5\n</code></pre> <pre><code>&gt;&gt;&gt; # Using original Parncutt (1988) weights\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis([60, 64, 67, 70], root_support_weights=\"v1\")\n&gt;&gt;&gt; analysis.root\n0\n&gt;&gt;&gt; analysis.root_ambiguity\n2.1\n</code></pre> <pre><code>&gt;&gt;&gt; # Using a Chord object as the input\n&gt;&gt;&gt; from amads.core.basics import Chord, Note\n&gt;&gt;&gt; chord = Chord(Note(pitch=60),  # C4\n...               Note(pitch=64),  # E4\n...               Note(pitch=67))  # G4\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis(chord)\n&gt;&gt;&gt; analysis.root\n0\n</code></pre> <pre><code>&gt;&gt;&gt; # Using a PitchCollection object as the input\n&gt;&gt;&gt; from amads.core.pitch import Pitch, PitchCollection\n&gt;&gt;&gt; pitch_collection = PitchCollection([Pitch(x) for x in [\"D4\", \"F4\", \"A4\"]])\n&gt;&gt;&gt; analysis = ParncuttRootAnalysis(pitch_collection)\n&gt;&gt;&gt; analysis.root\n2\n</code></pre> <p>See as_distribution() method for plotting root support weights.</p> References <p>[1] Parncutt, R. (1988). Revision of Terhardt's psychoacoustical model of the root(s) of a musical chord. Music Perception, 6(1), 65\u201393. https://doi.org/10.2307/40285416</p> <p>[2] Parncutt, R. (2006). Commentary on Cook &amp; Fujisawa's \"The Psychophysics of Harmony Perception: Harmony is a Three-Tone Phenomenon.\" Empirical Musicology Review, 1(4), 204\u2013209.</p> <p>Methods:</p> <ul> <li> <code>load_chord</code>             \u2013              <p>Normalize the chord argument into pitch and pitch-class sets.</p> </li> <li> <code>load_root_support_weights</code>             \u2013              <p>Resolve the root-support weight table.</p> </li> <li> <code>get_root_strength</code>             \u2013              <p>Compute support for a candidate root pitch class.</p> </li> <li> <code>get_root</code>             \u2013              <p>Return the pitch class with maximal root strength.</p> </li> <li> <code>get_root_ambiguity</code>             \u2013              <p>Measure ambiguity as the normalized sum of root strengths.</p> </li> <li> <code>as_distribution</code>             \u2013              <p>Convert root support weights to a (plot-able) Distribution</p> </li> </ul> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>def __init__(\n    self,\n    chord: Union[List[int], Chord, PitchCollection],\n    root_support_weights: Union[str, Dict[int, float]] = \"v2\",\n    exponent: float = 0.5,\n):\n    self.pitch_set, self.pc_set = self.load_chord(chord)\n    self.root_support_weights = self.load_root_support_weights(\n        root_support_weights\n    )\n    self.exponent = exponent\n    self.root_strengths = [self.get_root_strength(pc) for pc in range(12)]\n    self.root = self.get_root()\n    self.root_ambiguity = self.get_root_ambiguity()\n</code></pre>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis(chord)","title":"<code>chord</code>","text":"(<code>list[int] | Chord | PitchCollection</code>)           \u2013            <p>The chord to analyze. Can be represented as: A list of MIDI pitches representing a chord, A Chord object, or A PitchCollection object.</p>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis(root_support_weights)","title":"<code>root_support_weights</code>","text":"(<code>str | dict[int, float]</code>, default:                   <code>'v2'</code> )           \u2013            <p>Identifies the root support weights to use. \"v1\" uses the original weights from Parncutt (1988), \"v2\" uses the updated weights from Parncutt (2006), by default \"v2\".</p>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis(exponent)","title":"<code>exponent</code>","text":"(<code>float</code>, default:                   <code>0.5</code> )           \u2013            <p>Exponent to be used when computing root ambiguities, by default 0.5.</p>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis-functions","title":"Functions","text":""},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis.load_chord","title":"load_chord  <code>staticmethod</code>","text":"<pre><code>load_chord(\n    chord: list[int] | Chord | PitchCollection,\n) -&gt; tuple[set[int], set[int]]\n</code></pre> <p>Normalize the chord argument into pitch and pitch-class sets.</p> <p>Accepts a list of MIDI numbers, a Chord, or a PitchCollection and returns a set of MIDI pitches along with its pitch-class set. Raises on unknown types, empty chords, or undefined pitches.</p> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>@staticmethod\ndef load_chord(\n    chord: Union[List[int], Chord, PitchCollection]\n) -&gt; tuple[set[int], set[int]]:\n    \"\"\"Normalize the chord argument into pitch and pitch-class sets.\n\n    Accepts a list of MIDI numbers, a Chord, or a PitchCollection and\n    returns a set of MIDI pitches along with its pitch-class set.\n    Raises on unknown types, empty chords, or undefined pitches.\n    \"\"\"\n    if isinstance(chord, list):\n        pitch_set = set(chord)\n    elif isinstance(chord, Chord):\n        pitch_set = set(note.key_num for note in chord.find_all(Note))  # type: ignore\n    elif isinstance(chord, PitchCollection):\n        pitch_set = set(chord.pitch_num_multiset)\n    else:\n        raise TypeError(\n            \"Chord must be a list of MIDI pitches, a Chord object, or a PitchCollection object\"\n        )\n\n    if len(pitch_set) == 0:\n        raise ValueError(\"Chord must contain at least one pitch\")\n    if None in pitch_set:\n        raise ValueError(\"Some Note in Chord has undefined pitch\")\n\n    pc_set = set(pitch % 12 for pitch in pitch_set)  # type: ignore\n    return pitch_set, pc_set  # type: ignore\n</code></pre>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis.load_root_support_weights","title":"load_root_support_weights","text":"<pre><code>load_root_support_weights(\n    root_support_weights: str | dict[int, float],\n) -&gt; dict[int, float]\n</code></pre> <p>Resolve the root-support weight table.</p> <p>Accepts a version key (\"v1\" or \"v2\") or a custom mapping of interval-&gt;weight values. Raises ValueError for unknown versions.</p> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>def load_root_support_weights(\n    self, root_support_weights: Union[str, Dict[int, float]]\n) -&gt; Dict[int, float]:\n    \"\"\"Resolve the root-support weight table.\n\n    Accepts a version key (\"v1\" or \"v2\") or a custom mapping of\n    interval-&gt;weight values. Raises ValueError for unknown versions.\n    \"\"\"\n    if isinstance(root_support_weights, str):\n        if root_support_weights not in self.available_root_support_weights:\n            raise ValueError(\n                f\"Unknown root support weights version: {root_support_weights}\"\n            )\n        return self.available_root_support_weights[root_support_weights]\n    else:\n        # If it's a dictionary, return it directly\n        return root_support_weights\n</code></pre>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis.get_root_strength","title":"get_root_strength","text":"<pre><code>get_root_strength(pc: int) -&gt; float\n</code></pre> <p>Compute support for a candidate root pitch class.</p> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>def get_root_strength(self, pc: int) -&gt; float:\n    \"\"\"Compute support for a candidate root pitch class.\"\"\"\n    return sum(\n        support_weight\n        for interval, support_weight in self.root_support_weights.items()\n        if (pc + interval) % 12 in self.pc_set\n    )\n</code></pre>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis.get_root","title":"get_root","text":"<pre><code>get_root() -&gt; int\n</code></pre> <p>Return the pitch class with maximal root strength.</p> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>def get_root(self) -&gt; int:\n    \"\"\"Return the pitch class with maximal root strength.\"\"\"\n    return self.root_strengths.index(max(self.root_strengths))\n</code></pre>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis.get_root_ambiguity","title":"get_root_ambiguity","text":"<pre><code>get_root_ambiguity() -&gt; float\n</code></pre> <p>Measure ambiguity as the normalized sum of root strengths.</p> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>def get_root_ambiguity(self) -&gt; float:\n    \"\"\"Measure ambiguity as the normalized sum of root strengths.\"\"\"\n    max_weight = max(self.root_strengths)\n    if max_weight == 0:\n        return 0.0\n    return sum(w / max_weight for w in self.root_strengths) ** self.exponent\n</code></pre>"},{"location":"reference/harmony/root_finding/#amads.harmony.root_finding.parncutt.ParncuttRootAnalysis.as_distribution","title":"as_distribution","text":"<pre><code>as_distribution() -&gt; Distribution\n</code></pre> <p>Convert root support weights to a (plot-able) Distribution</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>containing (12) root support weights</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; analysis = ParncuttRootAnalysis([0, 4, 7])\n&gt;&gt;&gt; import matplotlib.pyplot as plt\n&gt;&gt;&gt; fig = analysis.as_distribution().plot(show=False)\n&gt;&gt;&gt; # plt.show() # in an interactive session, this will display the plot\n&gt;&gt;&gt; plt.close(fig) # in a non-interactive session, this is needed to close the plot\n</code></pre> Source code in <code>amads/harmony/root_finding/parncutt.py</code> <pre><code>def as_distribution(self) -&gt; Distribution:\n    \"\"\"\n    Convert root support weights to a (plot-able) Distribution\n\n    Returns\n    -------\n    Distribution\n        containing (12) root support weights\n\n    Examples\n    --------\n    &gt;&gt;&gt; analysis = ParncuttRootAnalysis([0, 4, 7])\n    &gt;&gt;&gt; import matplotlib.pyplot as plt\n    &gt;&gt;&gt; fig = analysis.as_distribution().plot(show=False)\n    &gt;&gt;&gt; # plt.show() # in an interactive session, this will display the plot\n    &gt;&gt;&gt; plt.close(fig) # in a non-interactive session, this is needed to close the plot\n    \"\"\"\n    return Distribution(\n        \"Root Support Weights\",\n        self.root_strengths,\n        \"root_support_weights\",\n        [12],\n        CHROMATIC_NAMES,  # type: ignore\n        \"Pitch class\",  # type: ignore\n        None,\n        \"Root strength\",\n    )\n</code></pre>"},{"location":"reference/melody/boundary/","title":"Boundary","text":""},{"location":"reference/melody/boundary/#amads.melody.boundary.boundary","title":"boundary","text":"<pre><code>boundary(score: Score) -&gt; Score\n</code></pre> <p>Compute the local boundary strength with LBDM (Cambouropoulos, 1997).</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the score is not monophonic</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>where the notes have the \"boundary_strength\" property set to a value from 0 to 1.</p> </li> </ul> Source code in <code>amads/melody/boundary.py</code> <pre><code>def boundary(score: Score) -&gt; Score:\n    \"\"\"\n    Compute the local boundary strength with LBDM (Cambouropoulos, 1997).\n\n    Raises\n    ------\n    ValueError\n        if the score is not monophonic\n\n    Returns\n    -------\n    Score\n        where the notes have the \"boundary_strength\" property set to a\n        value from 0 to 1.\n    \"\"\"\n    if not score.ismonophonic():\n        raise ValueError(\"Score must be monophonic\")\n\n    notes = score.get_sorted_notes()\n\n    # profiles\n    pp = [\n        abs(pair[1].key_num - pair[0].key_num) for pair in zip(notes, notes[1:])\n    ]\n    po = [pair[1].onset - pair[0].onset for pair in zip(notes, notes[1:])]\n    pr = [\n        max(0, pair[1].onset - pair[0].offset) for pair in zip(notes, notes[1:])\n    ]\n\n    def list_degrees(profile):\n        ret_list = [\n            abs(pair[1] - pair[0]) / (1e-6 + pair[1] + pair[0])\n            for pair in zip(profile, profile[1:])\n        ]\n        ret_list.append(0)\n        return ret_list\n\n    # degrees of change\n    rp = list_degrees(pp)\n    ro = list_degrees(po)\n    rr = list_degrees(pr)\n\n    def list_strengths(profile, degrees):\n        degrees_sum = [0]\n        for degree_pair in zip(degrees, degrees[1:]):\n            degrees_sum.append(degree_pair[0] + degree_pair[1])\n        strengths = [pair[0] * pair[1] for pair in zip(profile, degrees_sum)]\n        max_strength = max(strengths)\n        if max_strength &gt; 0.1:\n            strengths = [x / max_strength for x in strengths]\n        return strengths\n\n    sp = list_strengths(pp, rp)\n    so = list_strengths(po, ro)\n    sr = list_strengths(pr, rr)\n\n    if len(notes) &gt; 0:\n        notes[0].set(\"boundary_strength\", 1)\n    for sp_elem, so_elem, sr_elem, note in zip(sp, so, sr, notes[1:]):\n        note.set(\n            \"boundary_strength\", 0.25 * sp_elem + 0.5 * so_elem + 0.25 * sr_elem\n        )\n\n        # b = [1]\n        # for sp_elem, so_elem, sr_elem in zip(sp, so, sr):\n        #    b.append(0.25 * sp_elem + 0.5 * so_elem + 0.25 * sr_elem)\n    # assert len(b) == len(notes)\n\n    return score\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.segment","title":"segment","text":"<p>Functions:</p> <ul> <li> <code>fantastic_segmenter</code>             \u2013              <p>Segment melody into phrases based on IOI gaps.</p> </li> </ul>"},{"location":"reference/melody/boundary/#amads.melody.segment-functions","title":"Functions","text":""},{"location":"reference/melody/boundary/#amads.melody.segment.fantastic_segmenter","title":"fantastic_segmenter","text":"<pre><code>fantastic_segmenter(\n    score: Score, phrase_gap: float, units: str\n) -&gt; list[Score]\n</code></pre> <p>Segment melody into phrases based on IOI gaps.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Score]</code>           \u2013            <p>List of Score objects representing phrases</p> </li> </ul> Source code in <code>amads/melody/segment.py</code> <pre><code>def fantastic_segmenter(\n    score: Score, phrase_gap: float, units: str\n) -&gt; List[Score]:\n    \"\"\"Segment melody into phrases based on IOI gaps.\n    Parameters\n    ----------\n    score : Score\n        Score object containing melody to segment\n    phrase_gap : float\n        The minimum IOI gap to consider a new phrase\n    units : str\n        The units of the phrase gap, either \"seconds\" or \"quarters\"\n\n    Returns\n    -------\n    list[Score]\n        List of Score objects representing phrases\n    \"\"\"\n    assert units in [\"seconds\", \"quarters\"]\n    if units == \"seconds\":\n        raise NotImplementedError(\n            \"Seconds are not yet implemented, see issue #75: \"\n            \"https://github.com/music-computing/amads/issues/75\"\n        )\n    if units == \"quarters\":\n        # Extract notes from score\n        notes = score.get_sorted_notes()\n\n        # Create a dictionary to store IOI information\n        ioi_data = {}\n\n        # Calculate IOIs\n        for i, note in enumerate(notes):\n            # Initialize entry for this note\n            ioi_data[note] = None\n\n            # first note has no IOI by convention\n            if i &gt; 0:\n                ioi_data[note] = note.onset - notes[i - 1].onset\n            else:\n                ioi_data[note] = None\n\n        phrases = []\n        current_phrase = []\n        for note in notes:\n            # Check whether we need to make a new phrase\n            need_new_phrase = (\n                len(current_phrase) &gt; 0\n                and ioi_data[note]\n                is not None  # Check current note's IOI instead of previous note\n                and ioi_data[note] &gt; phrase_gap\n            )\n            if need_new_phrase:\n                # Create new score for the phrase\n                phrase_score = Score(onset=0, duration=None)\n                part = Part(\n                    parent=None, onset=0, duration=None\n                )  # parent=None is required\n                start_time = current_phrase[0].onset\n                # Adjust note timings relative to phrase start\n                for phrase_note in current_phrase:\n                    # make a parentless copy of the note so we can adjust its onset\n                    # before inserting it into the new part in proper time order\n                    new_note = phrase_note.insert_copy_into(None)\n                    new_note.onset -= start_time\n                    part.insert(new_note)\n                phrase_score.insert(part)  # This will set the parent\n                phrases.append(phrase_score)\n                current_phrase = []\n            current_phrase.append(note)\n\n        # Append final phrase\n        if len(current_phrase) &gt; 0:\n            phrase_score = Score(onset=0, duration=None)\n            part = Part(\n                parent=None, onset=0, duration=None\n            )  # parent=None is required\n            start_time = current_phrase[0].onset\n            for phrase_note in current_phrase:\n                new_note = phrase_note.insert_copy_into(None)\n                new_note.onset -= start_time\n                part.insert(new_note)\n            phrase_score.insert(part)  # This will set the parent\n            phrases.append(phrase_score)\n\n        return phrases\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.segment.fantastic_segmenter(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>Score object containing melody to segment</p>"},{"location":"reference/melody/boundary/#amads.melody.segment.fantastic_segmenter(phrase_gap)","title":"<code>phrase_gap</code>","text":"(<code>float</code>)           \u2013            <p>The minimum IOI gap to consider a new phrase</p>"},{"location":"reference/melody/boundary/#amads.melody.segment.fantastic_segmenter(units)","title":"<code>units</code>","text":"(<code>str</code>)           \u2013            <p>The units of the phrase gap, either \"seconds\" or \"quarters\"</p>"},{"location":"reference/melody/boundary/#amads.melody.segment_gestalt","title":"segment_gestalt","text":"<p>This module implements the segment gestalt function by Tenney &amp; Polansky (1980)</p> <p>We can broadly categorise the algorithm's limitations to 2 categories:</p> <ol> <li> <p>Soft restrictions</p> </li> <li> <p>Hard restrictions on what scores we can take, either because     the algorithm exhibits undefined behavior when these scores are given,     or because it isn't designed for said restrictions.</p> </li> </ol> <p>With these categories in mind, we have the following limitations. The algorithm does not consider these things within its scope (given a monophonic input):</p> <ol> <li> <p>the monophonic music may have stream segregation     (i.e. 1 stream of notes can be interpreted as 2 or     more separate interspersed entities)</p> </li> <li> <p>does not consider harmony or shape (see beginning of section 2     for the OG paper for more details)</p> </li> <li> <p>does not give semantic meaning (we're still stuck giving     arbitrary ideals to arbitrary things)</p> </li> </ol> <p>The algorithm has the following restriction to the score:</p> <ul> <li>the score must be monophonic (perception differences)     If we consider polyphonic scores, we will need a definition of what     a substructure is for said score (in said algorithm) with respect to     how we carve the note strutures. Since, in this algorithm, we don't     consider stream segregation and other features that require larger     context clues, we can just simply define a score substructure     \u201ctemporally\u201d as a contiguous subsequence of notes. Hence, it is safe     to assume that the current algorithm is undefined when it comes to     polyphonic music.</li> </ul> <p>Some thoughts (and questions): (1) Should our output preserve the internal structure of the score for segments and clangs? Probably not. Keep in mind we're dealing with monophonic score structures. we just need to provide sufficient information that allows a caller to potentially verify the result and use it elsewhere, hence we simply return 2 lists of separate scores.</p> <p>Legit think having a separate representation that can index into individual notes will be immensely helpful. But, I'm certain there has to be something I'm missing to decide otherwise (if I had to guess, ambiguity of how musical scores themselves are presented to the musician is chief among them, and maintaining that ambiguity in our internal representation is also paramount)</p> <p>Also legit think we need well-defined rules to split and merge scores...</p> <p>On a completely separate and unrelated note, there are 2 pitchmeans with, the exact same implementation and 2 filenames...</p> <p>Functions:</p> <ul> <li> <code>segment_gestalt</code>             \u2013              <p>Given a monophonic score, returns clang and segment boundary onsets</p> </li> </ul>"},{"location":"reference/melody/boundary/#amads.melody.segment_gestalt-functions","title":"Functions","text":""},{"location":"reference/melody/boundary/#amads.melody.segment_gestalt.segment_gestalt","title":"segment_gestalt","text":"<pre><code>segment_gestalt(score: Score) -&gt; tuple[list[float], list[float]]\n</code></pre> <p>Given a monophonic score, returns clang and segment boundary onsets</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[float], list[float]]</code>           \u2013            <p>None if no clangs can be formed, else, 2-tuple of: (sorted list of onsets denoting clangs boundaries, sorted list of onsets denoting segments segment boundaries)</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the score is not monophonic</p> </li> </ul> Source code in <code>amads/melody/segment_gestalt.py</code> <pre><code>def segment_gestalt(score: Score) -&gt; tuple[list[float], list[float]]:\n    \"\"\"\n    Given a monophonic score, returns clang and segment boundary onsets\n\n    Parameters\n    ----------\n    score: Score\n        The score to be segmented\n\n    Returns\n    -------\n    tuple[list[float], list[float]]\n        None if no clangs can be formed, else, 2-tuple of:\n        (sorted list of onsets denoting clangs boundaries,\n        sorted list of onsets denoting segments segment boundaries)\n\n\n    Raises\n    ------\n    Exception\n        if the score is not monophonic\n    \"\"\"\n    if not score.ismonophonic():\n        raise Exception(\"score not monophonic, input is not valid.\")\n\n    notes: List[Note] = cast(\n        List[Note], score.flatten(collapse=True).list_all(Note)\n    )\n\n    if len(notes) &lt;= 0:\n        return ([], [])\n\n    cl_values = []\n    # calculate clang distances here\n    for note_pair in zip(notes[:-1], notes[1:]):\n        pitch_diff = note_pair[1].key_num - note_pair[0].key_num\n        onset_diff = note_pair[1].onset - note_pair[0].onset\n        cl_values.append(2 * onset_diff + abs(pitch_diff))\n\n    # combines the boolean map and the scan function that was done in matlab\n    if len(cl_values) &lt; 3:\n        return ([], [])\n\n    clang_soft_peaks = _find_peaks(cl_values)\n    cl_indices = [0]\n    # worry about indices here\n    # starting index here\n    # 1 past the end so we can construct score list easier\n    cl_indices.extend([idx + 1 for idx in clang_soft_peaks])\n    cl_indices.append(len(notes))\n\n    clang_onsets = list(map(lambda i: (notes[i].onset), cl_indices[:-1]))\n\n    if len(clang_onsets) &lt;= 2:\n        return (clang_onsets, [])\n\n    # we can probably split the clangs here and organize them into scores\n    clang_scores = _construct_score_list(\n        notes, zip(cl_indices[:-1], cl_indices[1:])\n    )\n    # calculate segment boundaries\n    # we need to basically follow segment_gestalt.m\n    # (1) calculate individual clang pitch means\n    mean_pitches = [pitch_mean(score, weighted=True) for score in clang_scores]\n\n    # (2) calculate segment distances\n    seg_dist_values = []\n    # calculating segment distance...\n    for i in range(len(clang_scores) - 1):\n        local_seg_dist = 0.0\n        # be careful of the indices when calculating segdist here\n        local_seg_dist += abs(mean_pitches[i + 1] - mean_pitches[i])\n        # first first distance\n        local_seg_dist += (\n            notes[cl_indices[i + 1]].onset - notes[cl_indices[i]].onset\n        )\n        # first of next clang to last of distance\n        local_seg_dist += abs(\n            notes[cl_indices[i + 1]].key_num\n            - notes[cl_indices[i + 1] - 1].key_num\n        )\n        local_seg_dist += 2 * (\n            notes[cl_indices[i + 1]].onset - notes[cl_indices[i + 1] - 1].onset\n        )\n        seg_dist_values.append(local_seg_dist)\n    if len(seg_dist_values) &lt; 3:\n        return (clang_onsets, [])\n\n    seg_soft_peaks = _find_peaks(seg_dist_values)\n    assert seg_soft_peaks[-1] &lt; len(cl_indices) - 1\n    seg_indices = [0]\n    # do we need to add 1 here? where do we add 1\n    # worry about indices here\n    seg_indices.extend([cl_indices[idx + 1] for idx in seg_soft_peaks])\n    seg_indices.append(len(notes))\n\n    segment_onsets = list(map(lambda i: (notes[i].onset), seg_indices[:-1]))\n    return (clang_onsets, segment_onsets)\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.segment_gestalt.segment_gestalt(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to be segmented</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim","title":"melsim","text":"<p>This is a Python wrapper for the R package 'melsim'. This wrapper allows the user to easily interface with the melsim package using the AMADS Score object. Melsim is a package for computing similarity between melodies, and is being developed by Sebastian Silas and Klaus Frieler (https://www.aesthetics.mpg.de/en/the-institute/people/klaus-frieler.html).</p> <p>Melsim is based on SIMILE, which was written by Daniel M\u00fcllensiefen and Klaus Frieler in 2003/2004. This package is used to compare two or more melodies pairwise across a range of similarity measures. Not all similarity measures are implemented in melsim, but the ones that are can be used here. All of the following similarity measures are implemented and functional in melsim: Please be aware that the names of the similarity measures are case-sensitive.</p> Num Name 1 Jaccard 2 Kulczynski2 3 Russel 4 Faith 5 Tanimoto 6 Dice 7 Mozley 8 Ochiai 9 Simpson 10 cosine 11 angular 12 correlation 13 Tschuprow 14 Cramer 15 Gower 16 Euclidean 17 Manhattan 18 supremum 19 Canberra 20 Chord 21 Geodesic 22 Bray 23 Soergel 24 Podani 25 Whittaker 26 eJaccard 27 eDice 28 Bhjattacharyya 29 divergence 30 Hellinger 31 edit_sim_utf8 32 edit_sim 33 Levenshtein 34 sim_NCD 35 const 36 sim_dtw <p>The following similarity measures are not currently functional in melsim:</p> Num Name Type 1 count_distinct set-based 2 tversky set-based 3 simple matching 4 braun_blanquet set-based 5 minkowski vector-based 6 ukkon distribution-based 7 sum_common distribution-based 8 distr_sim distribution-based 9 stringdot_utf8 sequence-based 10 pmi special 11 sim_emd special <p>Further to the similarity measures, melsim allows the user to specify which domain the similarity should be calculated for. This is referred to as a \u201ctransformation\u201d in melsim, and all of the following transformations are implemented and functional:</p> Num Name 1 pitch 2 int 3 fuzzy_int 4 parsons 5 pc 6 ioi_class 7 duration_class 8 int_X_ioi_class 9 implicit_harmonies <p>The following transformations are not currently functional in melsim:</p> Num Name 1 ioi 2 phrase_segmentation <p>Functions:</p> <ul> <li> <code>run_script_in_r</code>             \u2013              <p>Run an R script and return its output.</p> </li> <li> <code>check_r_packages_installed</code>             \u2013              <p>Check if required R packages are installed.</p> </li> <li> <code>install_r_package</code>             \u2013              <p>Install an R package.</p> </li> <li> <code>install_dependencies</code>             \u2013              <p>Install all required R packages.</p> </li> <li> <code>check_python_package_installed</code>             \u2013              <p>Check if a Python package is installed.</p> </li> <li> <code>validate_method</code>             \u2013              <p>Validate that the similarity method is supported.</p> </li> <li> <code>validate_transformation</code>             \u2013              <p>Validate that the transformation is supported.</p> </li> <li> <code>get_similarity</code>             \u2013              <p>Calculate similarity between two Score objects using the specified method.</p> </li> <li> <code>score_to_arrays</code>             \u2013              <p>Extract melody attributes from a Score object.</p> </li> <li> <code>get_similarities</code>             \u2013              <p>Calculate pairwise similarities between multiple Score objects.</p> </li> </ul>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim-functions","title":"Functions","text":""},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.run_script_in_r","title":"run_script_in_r","text":"<pre><code>run_script_in_r(script: str, text: bool = True) -&gt; str\n</code></pre> <p>Run an R script and return its output.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Standard output from the R script</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error running the R script</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def run_script_in_r(script: str, text: bool = True) -&gt; str:\n    \"\"\"Run an R script and return its output.\n\n    Parameters\n    ----------\n    script : str\n        R script to run\n\n    Returns\n    -------\n    str\n        Standard output from the R script\n\n    Raises\n    ------\n    RuntimeError\n        If there is an error running the R script\n    \"\"\"\n    global _rscript_path\n    if not _rscript_path:\n        _rscript_path = _find_rscript()\n    result = subprocess.run(\n        [_rscript_path, \"-e\", script],\n        capture_output=True,\n        text=text,\n        check=True,\n    )\n    return result.stdout.strip()\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.run_script_in_r(script)","title":"<code>script</code>","text":"(<code>str</code>)           \u2013            <p>R script to run</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.check_r_packages_installed","title":"check_r_packages_installed","text":"<pre><code>check_r_packages_installed(\n    install_missing: bool = False, n_retries: int = 3\n)\n</code></pre> <p>Check if required R packages are installed.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If required packages are missing and install_missing is False.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error checking or installing packages.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def check_r_packages_installed(\n    install_missing: bool = False, n_retries: int = 3\n):\n    \"\"\"Check if required R packages are installed.\n\n    Parameters\n    ----------\n    install_missing : bool, default=False\n        If True, attempt to install missing packages automatically.\n    n_retries : int, default=3\n        Number of retries for installing each missing package.\n\n    Raises\n    ------\n    ImportError\n        If required packages are missing and install_missing is False.\n    RuntimeError\n        If there is an error checking or installing packages.\n    \"\"\"\n    # Create R script to check package installation using base R only\n    check_script = \"\"\"\n    packages &lt;- c({packages})\n    missing &lt;- packages[!sapply(packages, requireNamespace, quietly = TRUE)]\n    if (length(missing) &gt; 0) {{\n        cat(paste0('\"', missing, '\"', collapse = \",\"))\n    }} else {{\n        cat(\"\")\n    }}\n    \"\"\"\n\n    # Format package list\n    packages_str = \", \".join(\n        [f'\"{p}\"' for p in r_cran_packages + r_github_packages]\n    )\n    check_script = check_script.format(packages=packages_str)\n\n    # Run R script\n    try:\n        output = run_script_in_r(check_script)\n\n        # Parse the output - if empty, no missing packages\n        if not output:\n            missing_packages = []\n        else:\n            # Parse comma-separated quoted strings\n            missing_packages = [pkg.strip('\"') for pkg in output.split(\",\")]\n\n        if missing_packages:\n            if install_missing:\n                for package in missing_packages:\n                    try:\n                        for attempt in Retrying(\n                            stop=stop_after_attempt(n_retries),\n                            wait=wait_exponential(multiplier=1, min=1, max=10),\n                        ):\n                            with attempt:\n                                install_r_package(package)\n                    except RetryError as e:\n                        raise RuntimeError(\n                            f\"Failed to install R package '{package}' after {n_retries} attempts. \"\n                            \"See above for the traceback.\"\n                        ) from e\n            else:\n                raise ImportError(\n                    f\"Packages {missing_packages} are required but not installed. \"\n                    \"You can install them by running: install_dependencies()\"\n                )\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error checking R packages: {e.stderr}\")\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.check_r_packages_installed(install_missing)","title":"<code>install_missing</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, attempt to install missing packages automatically.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.check_r_packages_installed(n_retries)","title":"<code>n_retries</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of retries for installing each missing package.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.install_r_package","title":"install_r_package","text":"<pre><code>install_r_package(package: str)\n</code></pre> <p>Install an R package.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the package type is unknown.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def install_r_package(package: str):\n    \"\"\"Install an R package.\n\n    Parameters\n    ----------\n    package : str\n        Name of the R package to install.\n\n    Raises\n    ------\n    ValueError\n        If the package type is unknown.\n    \"\"\"\n    if package in r_cran_packages:\n        print(f\"Installing CRAN package '{package}'...\")\n        install_script = f\"\"\"\n        utils::chooseCRANmirror(ind=1)\n        utils::install.packages(\"{package}\", dependencies=TRUE)\n        \"\"\"\n        _ = run_script_in_r(install_script)\n    elif package in r_github_packages:\n        print(f\"Installing GitHub package '{package}'...\")\n        repo = github_repos[package]\n        install_script = f\"\"\"\n        if (!requireNamespace(\"remotes\", quietly = TRUE)) {{\n            utils::install.packages(\"remotes\")\n        }}\n        remotes::install_github(\"{repo}\", upgrade=\"always\", dependencies=TRUE)\n        \"\"\"\n        _ = run_script_in_r(install_script)\n    else:\n        raise ValueError(f\"Unknown package type for '{package}'\")\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.install_r_package(package)","title":"<code>package</code>","text":"(<code>str</code>)           \u2013            <p>Name of the R package to install.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.install_dependencies","title":"install_dependencies","text":"<pre><code>install_dependencies()\n</code></pre> <p>Install all required R packages.</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If required packages are missing and install_missing is False.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error checking or installing packages.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def install_dependencies():\n    \"\"\"Install all required R packages.\n\n    Raises\n    ------\n    ImportError\n        If required packages are missing and install_missing is False.\n    RuntimeError\n        If there is an error checking or installing packages.\n    \"\"\"\n    # Check which packages need to be installed using base R only\n    check_script = \"\"\"\n    packages &lt;- c({packages})\n    missing &lt;- packages[!sapply(packages, requireNamespace, quietly = TRUE)]\n    if (length(missing) &gt; 0) {{\n        cat(paste0('\"', missing, '\"', collapse = \",\"))\n    }} else {{\n        cat(\"\")\n    }}\n    \"\"\"\n\n    # Check CRAN packages\n    packages_str = \", \".join([f'\"{p}\"' for p in r_cran_packages])\n    check_script_cran = check_script.format(packages=packages_str)\n\n    try:\n        output = run_script_in_r(check_script_cran)\n\n        # Parse the output - if empty, no missing packages\n        if not output:\n            missing_cran = []\n        else:\n            # Parse comma-separated quoted strings\n            missing_cran = [pkg.strip('\"') for pkg in output.split(\",\")]\n\n        if missing_cran:\n            print(\"Installing missing CRAN packages...\")\n            cran_script = f\"\"\"\n            utils::chooseCRANmirror(ind=1)\n            utils::install.packages(c({\", \".join([f'\"{p}\"' for p in missing_cran])}), dependencies=TRUE)\n            \"\"\"\n            _ = run_script_in_r(cran_script)\n        else:\n            print(\"Skipping install: All CRAN packages are already installed.\")\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error checking CRAN packages: {e.stderr}\")\n\n    # Check GitHub packages\n    packages_str = \", \".join([f'\"{p}\"' for p in r_github_packages])\n    check_script_github = check_script.format(packages=packages_str)\n\n    try:\n        output = run_script_in_r(check_script_github)\n\n        # Parse the output - if empty, no missing packages\n        if not output:\n            missing_github = []\n        else:\n            # Parse comma-separated quoted strings\n            missing_github = [pkg.strip('\"') for pkg in output.split(\",\")]\n\n        if missing_github:\n            print(\"Installing missing GitHub packages...\")\n            for package in missing_github:\n                repo = github_repos[package]\n                print(f\"Installing {package} from {repo}...\")\n                install_script = f\"\"\"\n                if (!requireNamespace(\"remotes\", quietly = TRUE)) {{\n                    utils::install.packages(\"remotes\")\n                }}\n                remotes::install_github(\"{repo}\", upgrade=\"always\", dependencies=TRUE)\n                \"\"\"\n                _ = run_script_in_r(install_script)\n        else:\n            print(\n                \"Skipping install: All GitHub packages are already installed.\"\n            )\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error checking GitHub packages: {e.stderr}\")\n\n    print(\"All dependencies are installed and up to date.\")\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.check_python_package_installed","title":"check_python_package_installed","text":"<pre><code>check_python_package_installed(package: str)\n</code></pre> <p>Check if a Python package is installed.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If the package is not installed.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def check_python_package_installed(package: str):\n    \"\"\"Check if a Python package is installed.\n\n    Parameters\n    ----------\n    package : str\n        Name of the Python package to check.\n\n    Raises\n    ------\n    ImportError\n        If the package is not installed.\n    \"\"\"\n    try:\n        __import__(package)\n    except ImportError:\n        raise ImportError(\n            f\"Package '{package}' is required but not installed. \"\n            f\"Please install it using pip: pip install {package}\"\n        )\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.check_python_package_installed(package)","title":"<code>package</code>","text":"(<code>str</code>)           \u2013            <p>Name of the Python package to check.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.validate_method","title":"validate_method","text":"<pre><code>validate_method(method: str)\n</code></pre> <p>Validate that the similarity method is supported.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the method is not supported.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def validate_method(method: str):\n    \"\"\"Validate that the similarity method is supported.\n\n    Parameters\n    ----------\n    method : str\n        Name of the similarity method to validate.\n\n    Raises\n    ------\n    ValueError\n        If the method is not supported.\n    \"\"\"\n    if method not in VALID_METHODS:\n        raise ValueError(\n            f\"Invalid method '{method}'. Valid methods are: {', '.join(VALID_METHODS)}\"\n        )\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.validate_method(method)","title":"<code>method</code>","text":"(<code>str</code>)           \u2013            <p>Name of the similarity method to validate.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.validate_transformation","title":"validate_transformation","text":"<pre><code>validate_transformation(transformation: str)\n</code></pre> <p>Validate that the transformation is supported.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the transformation is not supported.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def validate_transformation(transformation: str):\n    \"\"\"Validate that the transformation is supported.\n\n    Parameters\n    ----------\n    transformation : str\n        Name of the transformation to validate.\n\n    Raises\n    ------\n    ValueError\n        If the transformation is not supported.\n    \"\"\"\n    if transformation not in VALID_TRANSFORMATIONS:\n        raise ValueError(\n            f\"Invalid transformation '{transformation}'. Valid transformations are: {', '.join(VALID_TRANSFORMATIONS)}\"\n        )\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.validate_transformation(transformation)","title":"<code>transformation</code>","text":"(<code>str</code>)           \u2013            <p>Name of the transformation to validate.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarity","title":"get_similarity","text":"<pre><code>get_similarity(\n    melody_1, melody_2, method: str, transformation: str\n) -&gt; float\n</code></pre> <p>Calculate similarity between two Score objects using the specified method.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Similarity value between the two melodies</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from amads.core.basics import Score\n&gt;&gt;&gt; # Create two simple melodies using from_melody\n&gt;&gt;&gt; melody_1 = Score.from_melody(pitches=[60, 62, 64, 65], durations=1.0)\n&gt;&gt;&gt; melody_2 = Score.from_melody(pitches=[60, 62, 64, 67], durations=1.0)\n&gt;&gt;&gt; # Calculate similarity using Jaccard method\n&gt;&gt;&gt; similarity = get_similarity(melody_1, melody_2, 'Jaccard', 'pitch')\n</code></pre> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def get_similarity(\n    melody_1, melody_2, method: str, transformation: str\n) -&gt; float:\n    \"\"\"Calculate similarity between two Score objects using the specified method.\n\n    Parameters\n    ----------\n    melody_1 : Score\n        First Score object containing a monophonic melody\n    melody_2 : Score\n        Second Score object containing a monophonic melody\n    method : str\n        Name of the similarity method to use from the list in the module docstring.\n    transformation : str\n        Name of the transformation to use from the list in the module docstring.\n\n    Returns\n    -------\n    float\n        Similarity value between the two melodies\n\n    Examples\n    --------\n    &gt;&gt;&gt; from amads.core.basics import Score\n    &gt;&gt;&gt; # Create two simple melodies using from_melody\n    &gt;&gt;&gt; melody_1 = Score.from_melody(pitches=[60, 62, 64, 65], durations=1.0)\n    &gt;&gt;&gt; melody_2 = Score.from_melody(pitches=[60, 62, 64, 67], durations=1.0)\n    &gt;&gt;&gt; # Calculate similarity using Jaccard method\n    &gt;&gt;&gt; similarity = get_similarity(melody_1, melody_2, 'Jaccard', 'pitch')\n    \"\"\"\n    # Validate inputs\n    validate_method(method)\n    validate_transformation(transformation)\n\n    # Convert Score objects to arrays\n    pitches1, starts1, ends1 = score_to_arrays(melody_1)\n    pitches2, starts2, ends2 = score_to_arrays(melody_2)\n\n    # Pass lists directly to _get_similarity\n    return _get_similarity(\n        pitches1,\n        starts1,\n        ends1,\n        pitches2,\n        starts2,\n        ends2,\n        method,\n        transformation,\n    )\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarity(melody_1)","title":"<code>melody_1</code>","text":"(<code>Score</code>)           \u2013            <p>First Score object containing a monophonic melody</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarity(melody_2)","title":"<code>melody_2</code>","text":"(<code>Score</code>)           \u2013            <p>Second Score object containing a monophonic melody</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarity(method)","title":"<code>method</code>","text":"(<code>str</code>)           \u2013            <p>Name of the similarity method to use from the list in the module docstring.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarity(transformation)","title":"<code>transformation</code>","text":"(<code>str</code>)           \u2013            <p>Name of the transformation to use from the list in the module docstring.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.score_to_arrays","title":"score_to_arrays","text":"<pre><code>score_to_arrays(score) -&gt; tuple[list[float], list[float], list[float]]\n</code></pre> <p>Extract melody attributes from a Score object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[int], list[float], list[float]]</code>           \u2013            <p>Tuple of (pitches, start_times, end_times)</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def score_to_arrays(score) -&gt; Tuple[List[float], List[float], List[float]]:\n    \"\"\"Extract melody attributes from a Score object.\n\n    Parameters\n    ----------\n    score : Score\n        Score object containing a monophonic melody\n\n    Returns\n    -------\n    Tuple[List[int], List[float], List[float]]\n        Tuple of (pitches, start_times, end_times)\n    \"\"\"\n    assert score.ismonophonic(), \"Score must be monophonic\"\n\n    notes = score.get_sorted_notes()\n\n    # Extract onset, pitch, duration for each note\n    pitches = [note.pitch.key_num for note in notes]\n    starts = [note.onset for note in notes]\n    ends = [note.onset + note.duration for note in notes]\n\n    return pitches, starts, ends\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.score_to_arrays(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>Score object containing a monophonic melody</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities","title":"get_similarities","text":"<pre><code>get_similarities(\n    scores: dict[str, object],\n    method: str | list[str] = \"Jaccard\",\n    transformation: str | list[str] = \"pitch\",\n    output_file: str | Path | None = None,\n    n_cores: int | None = None,\n    batch_size: int = 1000,\n) -&gt; (\n    dict[str, dict[str, float]]\n    | dict[tuple[str, str], dict[str, dict[str, float]]]\n)\n</code></pre> <p>Calculate pairwise similarities between multiple Score objects.</p> <p>You can provide a single method and transformation, or a list of methods and transformations. The function will return similarity matrices as nested dictionaries.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, float]] | dict[tuple[str, str], dict[str, dict[str, float]]]</code>           \u2013            <p>If single method and transformation: nested dictionary similarity matrix {row_name: {col_name: similarity}} where row_name and col_name are score names. If multiple methods/transformations: dictionary mapping (method, transformation) tuples to similarity matrices</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def get_similarities(\n    scores: Dict[str, object],\n    method: Union[str, List[str]] = \"Jaccard\",\n    transformation: Union[str, List[str]] = \"pitch\",\n    output_file: Union[str, Path, None] = None,\n    n_cores: Optional[int] = None,\n    batch_size: int = 1000,\n) -&gt; Union[\n    Dict[str, Dict[str, float]],\n    Dict[Tuple[str, str], Dict[str, Dict[str, float]]],\n]:\n    \"\"\"Calculate pairwise similarities between multiple Score objects.\n\n    You can provide a single method and transformation, or a list of methods and transformations.\n    The function will return similarity matrices as nested dictionaries.\n\n    Parameters\n    ----------\n    scores : Dict[str, Score]\n        Dictionary mapping score names to Score objects\n    method : Union[str, List[str]], default=\"Jaccard\"\n        Name of the similarity method(s) to use. Can be a single method or a list of methods.\n    transformation : Union[str, List[str]], default=\"pitch\"\n        Name of the transformation(s) to use. Can be a single transformation or a list of transformations.\n    output_file : Union[str, Path], optional\n        If provided, save results to this file. If no extension is provided, .json will be added.\n    n_cores : int, optional\n        Number of CPU cores to use for parallel processing. Defaults to all available cores.\n    batch_size : int, default=1000\n        Number of comparisons to process in each batch\n\n    Returns\n    -------\n    Union[Dict[str, Dict[str, float]], Dict[Tuple[str, str], Dict[str, Dict[str, float]]]]\n        If single method and transformation: nested dictionary similarity\n        matrix {row_name: {col_name: similarity}} where row_name and col_name\n        are score names. If multiple methods/transformations: dictionary mapping\n        (method, transformation) tuples to similarity matrices\n    \"\"\"\n    # Convert single method/transformation to lists\n    methods = [method] if isinstance(method, str) else method\n    transformations = (\n        [transformation] if isinstance(transformation, str) else transformation\n    )\n\n    # Validate all methods and transformations\n    for m in methods:\n        validate_method(m)\n    for t in transformations:\n        validate_transformation(t)\n\n    if len(scores) &lt; 2:\n        raise ValueError(\"Need at least 2 Score objects for comparison\")\n\n    # Extract melody data from all scores (avoid multiprocessing due to Score object pickling issues)\n    print(\"Extracting melody data...\")\n    melody_data = {}\n    for name, score in tqdm(scores.items(), desc=\"Processing Score objects\"):\n        try:\n            melody_data[name] = score_to_arrays(score)\n        except Exception as e:\n            print(\n                f\"Warning: Could not extract melody data for {name}: {str(e)}\"\n            )\n\n    if len(melody_data) &lt; 2:\n        raise ValueError(\"Need at least 2 valid Score objects for comparison\")\n\n    # Prepare arguments for parallel processing\n    print(\"Computing similarities...\")\n    args = []\n    score_pairs = []\n\n    # Pre-compute all combinations for better performance\n    combinations_list = list(combinations(melody_data.items(), 2))\n    for (name1, data1), (name2, data2) in combinations_list:\n        for m in methods:\n            for t in transformations:\n                args.append((data1, data2, m, t))\n                score_pairs.append((name1, name2, m, t))\n\n    # Process in larger batches for better performance\n    similarities_list = []\n    for i in tqdm(range(0, len(args), batch_size), desc=\"Processing batches\"):\n        batch = args[i : i + batch_size]\n        similarities_list.extend(_batch_compute_similarities(batch))\n\n    # Create dictionary of results\n    similarities = dict(zip(score_pairs, similarities_list))\n\n    # Convert to matrix format using native Python types\n    score_names = list(scores.keys())\n\n    # Create similarity matrices as nested dictionaries\n    matrices = {}\n\n    for m in methods:\n        for t in transformations:\n            # Initialize matrix as nested dictionary with 1s on diagonal\n            sim_matrix = {}\n            for name1 in score_names:\n                sim_matrix[name1] = {}\n                for name2 in score_names:\n                    if name1 == name2:\n                        sim_matrix[name1][name2] = 1.0\n                    else:\n                        sim_matrix[name1][name2] = 0.0\n\n            # Fill matrix with pairwise similarities\n            # Since combinations() only gives us each pair once, set both directions\n            for (\n                name1,\n                name2,\n                method_key,\n                transformation_key,\n            ), similarity in similarities.items():\n                if method_key == m and transformation_key == t:\n                    # Handle NaN values consistently\n                    if (\n                        similarity == \"NA\"\n                        or similarity is None\n                        or (\n                            isinstance(similarity, float)\n                            and math.isnan(similarity)\n                        )\n                    ):\n                        sim_value = float(\"nan\")\n                    else:\n                        sim_value = float(similarity)\n\n                    # Set both directions to ensure perfect symmetry\n                    sim_matrix[name1][name2] = sim_value\n                    sim_matrix[name2][name1] = sim_value\n\n            matrices[(m, t)] = sim_matrix\n\n    # Save to file if output file specified\n    if output_file:\n        print(\"Saving results...\")\n\n        # Ensure output file has .json extension\n        output_file = Path(output_file)\n        if not output_file.suffix:\n            output_file = output_file.with_suffix(\".json\")\n\n        # Save matrices to JSON\n        output_data = {}\n        for (m, t), matrix in matrices.items():\n            output_data[f\"{m}_{t}\"] = matrix\n\n        import json\n\n        with open(output_file, \"w\") as f:\n            json.dump(output_data, f, indent=2)\n        print(f\"Results saved to {output_file}\")\n\n    # Return format depends on number of method/transformation combinations\n    if len(methods) == 1 and len(transformations) == 1:\n        # Single method and transformation: return just the matrix\n        return matrices[(methods[0], transformations[0])]\n    else:\n        # Multiple methods/transformations: return dictionary of matrices\n        return matrices\n</code></pre>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities(scores)","title":"<code>scores</code>","text":"(<code>dict[str, Score]</code>)           \u2013            <p>Dictionary mapping score names to Score objects</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities(method)","title":"<code>method</code>","text":"(<code>str | list[str]</code>, default:                   <code>\"Jaccard\"</code> )           \u2013            <p>Name of the similarity method(s) to use. Can be a single method or a list of methods.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities(transformation)","title":"<code>transformation</code>","text":"(<code>str | list[str]</code>, default:                   <code>\"pitch\"</code> )           \u2013            <p>Name of the transformation(s) to use. Can be a single transformation or a list of transformations.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities(output_file)","title":"<code>output_file</code>","text":"(<code>str | Path</code>, default:                   <code>None</code> )           \u2013            <p>If provided, save results to this file. If no extension is provided, .json will be added.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities(n_cores)","title":"<code>n_cores</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of CPU cores to use for parallel processing. Defaults to all available cores.</p>"},{"location":"reference/melody/boundary/#amads.melody.similarity.melsim.get_similarities(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of comparisons to process in each batch</p>"},{"location":"reference/melody/contour/","title":"Contour","text":""},{"location":"reference/melody/contour/#amads.melody.contour.huron_contour.HuronContour","title":"HuronContour","text":"<pre><code>HuronContour(\n    pitches: list[int], times: list[float], method: str = \"amads\"\n)\n</code></pre> <p>The contour classification scheme proposed by Huron (1996) [1]</p> <p>The classification scheme is also included in the FANTASTIC toolbox of M\u00fcllensiefen (2009) [2] (as Feature 19 <code>Huron Contour: h.contour</code>).</p> <p>Huron categorises melodies by identifying the start, mean, and end pitches and describing contour in terms of the two directions: start-mean, and mean-end.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the <code>times</code> and <code>pitches</code> parameters are not the same length.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; happy_birthday_pitches = [\n...     60, 60, 62, 60, 65, 64, 60, 60, 62, 60, 67, 65,\n...     60, 60, 72, 69, 65, 64, 62, 70, 69, 65, 67, 65\n... ]\n&gt;&gt;&gt; happy_birthday_times = [\n...     0, 0.75, 1, 2, 3, 4, 6, 6.75, 7, 8, 9, 10,\n...     12, 12.75, 13, 14, 15, 16, 17, 18, 18.75, 19, 20, 21\n... ]\n&gt;&gt;&gt; hc = HuronContour(\n...     happy_birthday_pitches,\n...     happy_birthday_times,\n... )\n</code></pre> <pre><code>&gt;&gt;&gt; hc.first_pitch\n60\n&gt;&gt;&gt; hc.mean_pitch\n65\n&gt;&gt;&gt; hc.last_pitch\n65\n&gt;&gt;&gt; hc.first_to_mean\n5\n&gt;&gt;&gt; hc.mean_to_last\n0\n&gt;&gt;&gt; hc.contour_class\n'Ascending-Horizontal'\n</code></pre> References <ol> <li> <p>Huron, D (2006). The Melodic Arch in Western Folksongs.      Computing in Musicology 10.</p> </li> <li> <p>M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology Accessing      STatistics (In a Corpus): Technical Report v1.5</p> </li> </ol> <p>Methods:</p> <ul> <li> <code>calculate_mean_attributes</code>             \u2013              <p>Calculate the mean and populate the remaining attributes.</p> </li> <li> <code>class_label</code>             \u2013              <p>Classify a contour into Huron's categories.</p> </li> </ul> Source code in <code>amads/melody/contour/huron_contour.py</code> <pre><code>def __init__(\n    self, pitches: list[int], times: list[float], method: str = \"amads\"\n):\n    \"\"\"Initialize with pitch and time values.\n\n    Parameters\n    ----------\n    pitches : list[int]\n        Pitch values in any numeric format (e.g., MIDI numbers).\n    times : list[float]\n        Onset times in any consistent, proportional scheme\n        (e.g., seconds, quarter notes, etc.)\n\n    Raises\n    ------\n    ValueError\n        If the `times` and `pitches` parameters are not the same length.\n\n    Examples\n    --------\n    &gt;&gt;&gt; happy_birthday_pitches = [\n    ...     60, 60, 62, 60, 65, 64, 60, 60, 62, 60, 67, 65,\n    ...     60, 60, 72, 69, 65, 64, 62, 70, 69, 65, 67, 65\n    ... ]\n    &gt;&gt;&gt; happy_birthday_times = [\n    ...     0, 0.75, 1, 2, 3, 4, 6, 6.75, 7, 8, 9, 10,\n    ...     12, 12.75, 13, 14, 15, 16, 17, 18, 18.75, 19, 20, 21\n    ... ]\n    &gt;&gt;&gt; hc = HuronContour(\n    ...     happy_birthday_pitches,\n    ...     happy_birthday_times,\n    ... )\n\n    &gt;&gt;&gt; hc.first_pitch\n    60\n    &gt;&gt;&gt; hc.mean_pitch\n    65\n    &gt;&gt;&gt; hc.last_pitch\n    65\n    &gt;&gt;&gt; hc.first_to_mean\n    5\n    &gt;&gt;&gt; hc.mean_to_last\n    0\n    &gt;&gt;&gt; hc.contour_class\n    'Ascending-Horizontal'\n\n    References\n    ----------\n      1. Huron, D (2006). The Melodic Arch in Western Folksongs.\n         *Computing in Musicology* 10.\n\n      2. M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology Accessing\n         STatistics (In a Corpus): Technical Report v1.5\n    \"\"\"\n    if len(times) != len(pitches):\n        raise ValueError(\n            f\"Times and pitches must have the same length, \"\n            f\"got {len(times)} and {len(pitches)}\"\n        )\n\n    self.times = times\n    self.pitches = pitches\n    self.first_pitch = pitches[0]\n    self.last_pitch = pitches[-1]\n\n    self.mean_pitch = None\n    self.first_to_mean = None\n    self.mean_to_last = None\n    self.calculate_mean_attributes()\n\n    self.contour_class = None\n    self.class_label()\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.huron_contour.HuronContour(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>Pitch values in any numeric format (e.g., MIDI numbers).</p>"},{"location":"reference/melody/contour/#amads.melody.contour.huron_contour.HuronContour(times)","title":"<code>times</code>","text":"(<code>list[float]</code>)           \u2013            <p>Onset times in any consistent, proportional scheme (e.g., seconds, quarter notes, etc.)</p>"},{"location":"reference/melody/contour/#amads.melody.contour.huron_contour.HuronContour-functions","title":"Functions","text":""},{"location":"reference/melody/contour/#amads.melody.contour.huron_contour.HuronContour.calculate_mean_attributes","title":"calculate_mean_attributes","text":"<pre><code>calculate_mean_attributes()\n</code></pre> <p>Calculate the mean and populate the remaining attributes.</p> <p>Note that the mean pitch is rounded to the nearest integer, and that this rounding happens before calculating comparisons.</p> Source code in <code>amads/melody/contour/huron_contour.py</code> <pre><code>def calculate_mean_attributes(self):\n    \"\"\"\n    Calculate the mean and populate the remaining attributes.\n\n    Note that the mean pitch is rounded to the nearest integer,\n    and that this rounding happens before calculating comparisons.\n    \"\"\"\n    self.mean_pitch = int(\n        sum(x * y for x, y in zip(self.pitches, self.times))\n        / sum(self.times)\n    )\n\n    self.first_to_mean = self.mean_pitch - self.first_pitch\n    self.mean_to_last = self.last_pitch - self.mean_pitch\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.huron_contour.HuronContour.class_label","title":"class_label","text":"<pre><code>class_label()\n</code></pre> <p>Classify a contour into Huron's categories.</p> <p>This is based simply on the two directions from start to mean and mean to last. Huron proposes shorthands for some of these as follows: \"Ascending-Descending\" = \"Convex\", \"Ascending-Horizontal\" = None, \"Ascending-Ascending\": None, \"Horizontal-Descending\": None, \"Horizontal-Horizontal\": \"Horizontal\", \"Horizontal-Ascending\": None, \"Descending-Descending\": \"Descending\", \"Descending-Ascending\": \"Concave\"</p> <p>Where no shorthand is provided, this method return the longhand.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String, exactly as reported in the FANTASTIC library.</p> </li> </ul> Source code in <code>amads/melody/contour/huron_contour.py</code> <pre><code>def class_label(self):\n    \"\"\"Classify a contour into Huron's categories.\n\n    This is based simply on the two directions from start to mean and mean to last.\n    Huron proposes shorthands for some of these as follows:\n    \"Ascending-Descending\" = \"Convex\",\n    \"Ascending-Horizontal\" = None,\n    \"Ascending-Ascending\": None,\n    \"Horizontal-Descending\": None,\n    \"Horizontal-Horizontal\": \"Horizontal\",\n    \"Horizontal-Ascending\": None,\n    \"Descending-Descending\": \"Descending\",\n    \"Descending-Ascending\": \"Concave\"\n\n    Where no shorthand is provided, this method return the longhand.\n\n    Returns\n    -------\n    str\n        String, exactly as reported in the FANTASTIC library.\n\n    \"\"\"\n\n    direction_dict = {-1: \"Descending\", 0: \"Horizontal\", 1: \"Ascending\"}\n\n    first_to_mean_sign = sign(self.first_to_mean)\n    mean_to_last_sign = sign(self.mean_to_last)\n\n    return_string = f\"{direction_dict[first_to_mean_sign]}-{direction_dict[mean_to_last_sign]}\"\n\n    shorthand_dict = {\n        \"Ascending-Descending\": \"Convex\",\n        \"Horizontal-Horizontal\": \"Horizontal\",\n        \"Descending-Descending\": \"Descending\",\n        \"Descending-Ascending\": \"Concave\",\n    }\n\n    if return_string in shorthand_dict:\n        self.contour_class = shorthand_dict[return_string]\n    else:\n        self.contour_class = return_string\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.parsons_contour.ParsonsContour","title":"ParsonsContour","text":"<pre><code>ParsonsContour(\n    pitches: list[int],\n    character_dict: dict | None = None,\n    initial_asterisk: bool = False,\n)\n</code></pre> <p>Implementation of the basic Parsons contour classification scheme.</p> <p>Parsons categorises each step by direction only.</p> <p>Nothing more, nothing less.</p> <p>Author: Mark Gotham</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; happy = [60, 60, 62, 60, 65, 64, 60, 60, 62, 60, 67, 65, 60, 60, 72, 69, 65, 64, 62, 70, 69, 65, 67, 65]\n&gt;&gt;&gt; pc = ParsonsContour(happy)\n&gt;&gt;&gt; pc.interval_sequence\n[None, 0, 2, -2, 5, -1, -4, 0, 2, -2, 7, -2, -5, 0, 12, -3, -4, -1, -2, 8, -1, -4, 2, -2]\n</code></pre> <pre><code>&gt;&gt;&gt; pc.interval_sequence_sign\n[None, 0, 1, -1, 1, -1, -1, 0, 1, -1, 1, -1, -1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1]\n</code></pre> <pre><code>&gt;&gt;&gt; pc.as_string\n'rududdrududdrudddduddud'\n</code></pre> <pre><code>&gt;&gt;&gt; twinkle_ints = [72, 72, 79, 79, 81, 81, 79, 77, 77, 76, 76, 74, 74, 72]\n&gt;&gt;&gt; pc = ParsonsContour(twinkle_ints)\n&gt;&gt;&gt; pc.as_string\n'rururddrdrdrd'\n</code></pre> <pre><code>&gt;&gt;&gt; pc_no_asterisk = ParsonsContour(twinkle_ints, initial_asterisk=True)\n&gt;&gt;&gt; pc_no_asterisk.as_string\n'*rururddrdrdrd'\n</code></pre> <pre><code>&gt;&gt;&gt; pc_symbols = ParsonsContour(twinkle_ints, {1: \"&lt;\", 0: \"=\", -1: \"&gt;\"})\n&gt;&gt;&gt; pc_symbols.as_string\n'=&lt;=&lt;=&gt;&gt;=&gt;=&gt;=&gt;'\n</code></pre> References <p>[1] Parsons, Denys. 1975. The Directory of Tunes and Musical Themes.</p> <p>Methods:</p> <ul> <li> <code>make_string</code>             \u2013              <p>Create a flat, string representation of the contour directions.</p> </li> </ul> Source code in <code>amads/melody/contour/parsons_contour.py</code> <pre><code>def __init__(\n    self,\n    pitches: list[int],\n    character_dict: Optional[dict] = None,\n    initial_asterisk: bool = False,\n):\n    \"\"\"\n    The 'Parsons code' returns simply the direction of each successive melodic interval.\n    It's been used in lookup, and can serve as a useful first entry point to the topic of contour.\n\n    Parameters\n    ----------\n    pitches:\n        A list of integers representing pitches\n        (assumed to be MIDI numbers or equivalent, not pitch classes)\n    character_dict:\n        A dict specifying which characters to use when mapped to a string.\n        Must include keys for [1, 0, -1] corresponding to up, repeat, and down.\n        The default is Parsons' own values: {1: \"u\", 0: \"r\", -1: \"d\"}.\n        Other options could include `&lt;`, `=`, `&gt;`.\n    initial_asterisk:\n        Optionally, include an initial `*` for the start of the sequence (no previous interval).\n\n    Examples\n    --------\n    &gt;&gt;&gt; happy = [60, 60, 62, 60, 65, 64, 60, 60, 62, 60, 67, 65, 60, 60, 72, 69, 65, 64, 62, 70, 69, 65, 67, 65]\n    &gt;&gt;&gt; pc = ParsonsContour(happy)\n    &gt;&gt;&gt; pc.interval_sequence\n    [None, 0, 2, -2, 5, -1, -4, 0, 2, -2, 7, -2, -5, 0, 12, -3, -4, -1, -2, 8, -1, -4, 2, -2]\n\n    &gt;&gt;&gt; pc.interval_sequence_sign\n    [None, 0, 1, -1, 1, -1, -1, 0, 1, -1, 1, -1, -1, 0, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1]\n\n    &gt;&gt;&gt; pc.as_string\n    'rududdrududdrudddduddud'\n\n    &gt;&gt;&gt; twinkle_ints = [72, 72, 79, 79, 81, 81, 79, 77, 77, 76, 76, 74, 74, 72]\n    &gt;&gt;&gt; pc = ParsonsContour(twinkle_ints)\n    &gt;&gt;&gt; pc.as_string\n    'rururddrdrdrd'\n\n    &gt;&gt;&gt; pc_no_asterisk = ParsonsContour(twinkle_ints, initial_asterisk=True)\n    &gt;&gt;&gt; pc_no_asterisk.as_string\n    '*rururddrdrdrd'\n\n    &gt;&gt;&gt; pc_symbols = ParsonsContour(twinkle_ints, {1: \"&lt;\", 0: \"=\", -1: \"&gt;\"})\n    &gt;&gt;&gt; pc_symbols.as_string\n    '=&lt;=&lt;=&gt;&gt;=&gt;=&gt;=&gt;'\n\n    References\n    ----------\n    [1] Parsons, Denys. 1975. *The Directory of Tunes and Musical Themes*.\n    \"\"\"\n\n    self.pitches = pitches\n    self.character_dict = (\n        character_dict if character_dict else {1: \"u\", 0: \"r\", -1: \"d\"}\n    )\n    self.initial_asterisk = initial_asterisk\n\n    self.interval_sequence = None\n    self.interval_sequence_sign = None\n    self.as_string = None\n\n    self.get_intervals()\n    self.make_string()\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.parsons_contour.ParsonsContour(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>A list of integers representing pitches (assumed to be MIDI numbers or equivalent, not pitch classes)</p>"},{"location":"reference/melody/contour/#amads.melody.contour.parsons_contour.ParsonsContour(character_dict)","title":"<code>character_dict</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>A dict specifying which characters to use when mapped to a string. Must include keys for [1, 0, -1] corresponding to up, repeat, and down. The default is Parsons' own values: {1: \"u\", 0: \"r\", -1: \"d\"}. Other options could include <code>&lt;</code>, <code>=</code>, <code>&gt;</code>.</p>"},{"location":"reference/melody/contour/#amads.melody.contour.parsons_contour.ParsonsContour(initial_asterisk)","title":"<code>initial_asterisk</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Optionally, include an initial <code>*</code> for the start of the sequence (no previous interval).</p>"},{"location":"reference/melody/contour/#amads.melody.contour.parsons_contour.ParsonsContour-functions","title":"Functions","text":""},{"location":"reference/melody/contour/#amads.melody.contour.parsons_contour.ParsonsContour.make_string","title":"make_string","text":"<pre><code>make_string()\n</code></pre> <p>Create a flat, string representation of the contour directions.</p> Source code in <code>amads/melody/contour/parsons_contour.py</code> <pre><code>def make_string(self):\n    \"\"\"Create a flat, string representation of the contour directions.\"\"\"\n    self.as_string = \"\"\n    if self.initial_asterisk:\n        self.as_string += \"*\"\n    for i in range(1, len(self.interval_sequence_sign)):\n        self.as_string += self.character_dict[\n            self.interval_sequence_sign[i]\n        ]\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour","title":"StepContour","text":"<pre><code>StepContour(\n    pitches: list[int],\n    durations: list[float],\n    step_contour_length: int = _step_contour_length,\n)\n</code></pre> <p>Class for calculating and analyzing the step contour of a melody.</p> <p>Also related features, as implemented in the FANTASTIC toolbox of M\u00fcllensiefen (2009) [1] (as features 20\u201322). Exemplified in Steinbeck (1982) [2], Juh\u00e1sz (2000) [3], Eerola and Toiviainen (2004) [4].</p> <p>A step contour is a list of MIDI pitch values, repeated proportionally to the duration (measured in tatums) of each note relative to the total melody length. This list is normalized to a user defined length, defaulting to 64 steps as used in FANTASTIC. Rests are considered as extending the duration of the previous note.</p> <p>Author: David Whyatt</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitches = [60, 64, 67]  # C4, E4, G4\n&gt;&gt;&gt; durations = [2.0, 1.0, 1.0]  # First note is 2 beats, others are 1 beat\n&gt;&gt;&gt; sc = StepContour(pitches, durations)\n&gt;&gt;&gt; len(sc.contour)  # Default length is 64\n64\n&gt;&gt;&gt; pitches = [60, 62, 64, 65, 67]  # C4, D4, E4, F4, G4\n&gt;&gt;&gt; durations = [1.0, 1.0, 1.0, 1.0, 1.0]  # Notes have equal durations\n&gt;&gt;&gt; sc = StepContour(pitches, durations)\n&gt;&gt;&gt; sc.contour[:8]  # First 8 values of 64-length contour\n[60, 60, 60, 60, 60, 60, 60, 60]\n&gt;&gt;&gt; sc.global_variation  # Standard deviation of contour\n2.3974\n&gt;&gt;&gt; sc.global_direction  # Correlation with ascending line\n0.9746\n&gt;&gt;&gt; sc.local_variation  # Average absolute difference between adjacent values\n0.1111\n</code></pre> <p>Parameters:</p> References <ol> <li>M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology     Accessing STatistics (In a Corpus): Technical Report v1.5</li> <li>W. Steinbeck, Struktur und \u00c4hnlichkeit: Methoden automatisierter     Melodieanalyse. B\u00e4renreiter, 1982.</li> <li>Juh\u00e1sz, Z. 2000. A model of variation in the music of a Hungarian     ethnic group. Journal of New Music Research 29(2):159-172.</li> <li>Eerola, T. &amp; Toiviainen, P. (2004). MIDI Toolbox: MATLAB Tools for     Music Research. University of Jyv\u00e4skyl\u00e4: Kopijyv\u00e4, Jyv\u00e4skyl\u00e4,     Finland.</li> </ol> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sc = StepContour([60, 62], [2.0, 2.0], step_contour_length=4)\n&gt;&gt;&gt; sc.contour\n[60, 60, 62, 62]\n</code></pre> <p>Attributes:</p> <ul> <li> <code>global_variation</code>               (<code>float</code>)           \u2013            <p>Calculate the global variation of the step contour by taking the standard</p> </li> <li> <code>global_direction</code>               (<code>float</code>)           \u2013            <p>Calculate the global direction of the step contour by taking the correlation</p> </li> <li> <code>local_variation</code>               (<code>float</code>)           \u2013            <p>Calculate the local variation of the step contour, by taking the mean</p> </li> </ul> Source code in <code>amads/melody/contour/step_contour.py</code> <pre><code>def __init__(\n    self,\n    pitches: list[int],\n    durations: list[float],\n    step_contour_length: int = _step_contour_length,\n):\n    \"\"\"Initialize StepContour with melody data.\n\n    Parameters\n    ----------\n    pitches : list[int]\n        List of pitch values in any numeric format (e.g., MIDI numbers).\n    durations : list[float]\n        List of note durations measured in tatums\n    step_contour_length : int, optional\n        Length of the output step contour vector (default is 64)\n\n    References\n    ----------\n\n     1. M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology\n        Accessing STatistics (In a Corpus): Technical Report v1.5\n     2. W. Steinbeck, Struktur und \u00c4hnlichkeit: *Methoden automatisierter\n        Melodieanalyse*. B\u00e4renreiter, 1982.\n     3. Juh\u00e1sz, Z. 2000. A model of variation in the music of a Hungarian\n        ethnic group. *Journal of New Music Research* 29(2):159-172.\n     4. Eerola, T. &amp; Toiviainen, P. (2004). MIDI Toolbox: MATLAB Tools for\n        Music Research. University of Jyv\u00e4skyl\u00e4: Kopijyv\u00e4, Jyv\u00e4skyl\u00e4,\n        Finland.\n\n    Examples\n    --------\n    &gt;&gt;&gt; sc = StepContour([60, 62], [2.0, 2.0], step_contour_length=4)\n    &gt;&gt;&gt; sc.contour\n    [60, 60, 62, 62]\n    \"\"\"\n    if len(pitches) != len(durations):\n        raise ValueError(\n            f\"The length of pitches (currently {len(pitches)}) must be equal to \"\n            f\"the length of durations (currently {len(durations)})\"\n        )\n\n    self._step_contour_length = step_contour_length\n    self.contour = self._calculate_contour(pitches, durations)\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>List of pitch values in any numeric format (e.g., MIDI numbers).</p>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour(durations)","title":"<code>durations</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of note durations measured in tatums</p>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour(step_contour_length)","title":"<code>step_contour_length</code>","text":"(<code>int</code>, default:                   <code>_step_contour_length</code> )           \u2013            <p>Length of the output step contour vector (default is 64)</p>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour-attributes","title":"Attributes","text":""},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour.global_variation","title":"global_variation  <code>property</code>","text":"<pre><code>global_variation: float\n</code></pre> <p>Calculate the global variation of the step contour by taking the standard deviation of the step contour vector.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Float value representing the global variation of the step contour</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sc = StepContour([60, 62, 64], [1.0, 1.0, 1.0])\n&gt;&gt;&gt; sc.global_variation\n1.64\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour.global_direction","title":"global_direction  <code>property</code>","text":"<pre><code>global_direction: float\n</code></pre> <p>Calculate the global direction of the step contour by taking the correlation between the step contour vector and an ascending linear function y = x.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Float value representing the global direction of the step contour Returns 0.0 if the contour is flat</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sc = StepContour([60, 62, 64], [1.0, 1.0, 1.0])\n&gt;&gt;&gt; sc.global_direction\n0.943\n&gt;&gt;&gt; sc = StepContour([60, 60, 60], [1.0, 1.0, 1.0])\n&gt;&gt;&gt; sc.global_direction\n0.0\n&gt;&gt;&gt; sc = StepContour([64, 62, 60], [1.0, 1.0, 1.0])  # Descending melody\n&gt;&gt;&gt; sc.global_direction\n-0.943\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour.local_variation","title":"local_variation  <code>property</code>","text":"<pre><code>local_variation: float\n</code></pre> <p>Calculate the local variation of the step contour, by taking the mean absolute difference between adjacent values.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Float value representing the local variation of the step contour</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sc = StepContour([60, 62, 64], [1.0, 1.0, 1.0])\n&gt;&gt;&gt; sc.local_variation\n0.0634\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.step_contour.StepContour-functions","title":"Functions","text":""},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour","title":"InterpolationContour","text":"<pre><code>InterpolationContour(\n    pitches: list[int], times: list[float], method: str = \"amads\"\n)\n</code></pre> <p>Class for calculating and analyzing interpolated contours of melodies.</p> <p>As implemented in the FANTASTIC toolbox of M\u00fcllensiefen (2009) [1] (as features 23\u201327). This representation was first formalised by Steinbeck (1982) [2], and informed a varient of the present implementation in M\u00fcllensiefen &amp; Frieler (2004) [3].</p> <p>Includes a modified version of the FANTASTIC method that is better suited to short melodies than the original implementation. This 'AMADS' method defines turning points using reversals, and is the default method. All features are returned for either method.</p> <p>An interpolation contour is produced by first identifying turning points in the melody, and then interpolating a linear gradient between each turning point. The resulting list of values represents the gradient of the melody at evenly spaced points in time.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the <code>times</code> and <code>pitches</code> parameters are not the same length. If method is not \"fantastic\" or \"amads\"</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; happy_birthday_pitches = [\n...     60, 60, 62, 60, 65, 64, 60, 60, 62, 60, 67, 65,\n...     60, 60, 72, 69, 65, 64, 62, 70, 69, 65, 67, 65\n... ]\n&gt;&gt;&gt; happy_birthday_times = [\n...     0, 0.75, 1, 2, 3, 4, 6, 6.75, 7, 8, 9, 10,\n...     12, 12.75, 13, 14, 15, 16, 17, 18, 18.75, 19, 20, 21\n... ]\n&gt;&gt;&gt; ic = InterpolationContour(\n...     happy_birthday_pitches,\n...     happy_birthday_times,\n...     method=\"fantastic\",\n... )\n&gt;&gt;&gt; ic.direction_changes\n0.6\n&gt;&gt;&gt; ic.class_label\n'ccbc'\n&gt;&gt;&gt; ic.mean_gradient\n2.702...\n&gt;&gt;&gt; ic.gradient_std\n5.655...\n&gt;&gt;&gt; ic.global_direction\n1\n</code></pre> References <ol> <li> <p>M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology     Accessing STatistics (In a Corpus): Technical Report v1.5</p> </li> <li> <p>W. Steinbeck, Struktur und \u00c4hnlichkeit: Methoden automatisierter     Melodieanalyse. B\u00e4renreiter, 1982.</p> </li> <li> <p>M\u00fcllensiefen, D. &amp; Frieler, K. (2004). Cognitive Adequacy in the     Measurement of Melodic Similarity: Algorithmic vs. Human Judgments</p> </li> </ol> <p>Methods:</p> <ul> <li> <code>calculate_interpolation_contour</code>             \u2013              <p>Calculate the interpolation contour representation of a melody [1].</p> </li> </ul> <p>Attributes:</p> <ul> <li> <code>global_direction</code>               (<code>int</code>)           \u2013            <p>Calculate the global direction of the interpolation contour.</p> </li> <li> <code>mean_gradient</code>               (<code>float</code>)           \u2013            <p>Calculate the absolute mean gradient of the interpolation contour.</p> </li> <li> <code>gradient_std</code>               (<code>float</code>)           \u2013            <p>Calculate the standard deviation of the interpolation contour gradients.</p> </li> <li> <code>direction_changes</code>               (<code>float</code>)           \u2013            <p>Calculate the proportion of interpolated gradient values that consistute</p> </li> <li> <code>class_label</code>               (<code>str</code>)           \u2013            <p>Classify an interpolation contour into gradient categories.</p> </li> </ul> Source code in <code>amads/melody/contour/interpolation_contour.py</code> <pre><code>def __init__(\n    self, pitches: list[int], times: list[float], method: str = \"amads\"\n):\n    \"\"\"Initialize with pitch and time values.\n\n    Parameters\n    ----------\n    pitches : list[int]\n        Pitch values in any numeric format (e.g., MIDI numbers).\n    times : list[float]\n        Onset times in any consistent, proportional scheme (e.g., seconds,\n        quarter notes, etc.)\n    method : str, optional\n        Method to use for contour calculation, either \"fantastic\" or \"amads\".\n        Defaults to \"amads\".\n        The FANTASTIC method is the original implementation, and identifies\n        turning points using contour extrema via a series of rules. The\n        AMADS method instead identifies reversals for all melody lengths,\n        and is the default method.\n\n    Raises\n    ------\n    ValueError\n        If the `times` and `pitches` parameters are not the same length.\n        If method is not \"fantastic\" or \"amads\"\n\n    Examples\n    --------\n    &gt;&gt;&gt; happy_birthday_pitches = [\n    ...     60, 60, 62, 60, 65, 64, 60, 60, 62, 60, 67, 65,\n    ...     60, 60, 72, 69, 65, 64, 62, 70, 69, 65, 67, 65\n    ... ]\n    &gt;&gt;&gt; happy_birthday_times = [\n    ...     0, 0.75, 1, 2, 3, 4, 6, 6.75, 7, 8, 9, 10,\n    ...     12, 12.75, 13, 14, 15, 16, 17, 18, 18.75, 19, 20, 21\n    ... ]\n    &gt;&gt;&gt; ic = InterpolationContour(\n    ...     happy_birthday_pitches,\n    ...     happy_birthday_times,\n    ...     method=\"fantastic\",\n    ... )\n    &gt;&gt;&gt; ic.direction_changes\n    0.6\n    &gt;&gt;&gt; ic.class_label\n    'ccbc'\n    &gt;&gt;&gt; ic.mean_gradient\n    2.702...\n    &gt;&gt;&gt; ic.gradient_std\n    5.655...\n    &gt;&gt;&gt; ic.global_direction\n    1\n\n    References\n    ----------\n     1. M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology\n        Accessing STatistics (In a Corpus): Technical Report v1.5\n\n     2. W. Steinbeck, Struktur und \u00c4hnlichkeit: Methoden automatisierter\n        Melodieanalyse. B\u00e4renreiter, 1982.\n\n     3. M\u00fcllensiefen, D. &amp; Frieler, K. (2004). Cognitive Adequacy in the\n        Measurement of Melodic Similarity: Algorithmic vs. Human Judgments\n    \"\"\"\n    if len(times) != len(pitches):\n        raise ValueError(\n            f\"Times and pitches must have the same length, got {len(times)} and {len(pitches)}\"\n        )\n    if method not in [\"fantastic\", \"amads\"]:\n        raise ValueError(\n            f\"Method must be either 'fantastic' or 'amads', got {method}\"\n        )\n\n    self.times = times\n    self.pitches = pitches\n    self.method = method\n    self.contour = self.calculate_interpolation_contour(\n        pitches, times, method\n    )\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>Pitch values in any numeric format (e.g., MIDI numbers).</p>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour(times)","title":"<code>times</code>","text":"(<code>list[float]</code>)           \u2013            <p>Onset times in any consistent, proportional scheme (e.g., seconds, quarter notes, etc.)</p>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour(method)","title":"<code>method</code>","text":"(<code>str</code>, default:                   <code>'amads'</code> )           \u2013            <p>Method to use for contour calculation, either \"fantastic\" or \"amads\". Defaults to \"amads\". The FANTASTIC method is the original implementation, and identifies turning points using contour extrema via a series of rules. The AMADS method instead identifies reversals for all melody lengths, and is the default method.</p>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour-attributes","title":"Attributes","text":""},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour.global_direction","title":"global_direction  <code>property</code>","text":"<pre><code>global_direction: int\n</code></pre> <p>Calculate the global direction of the interpolation contour.</p> <p>Takes the sign of the sum of all contour values. Can be invoked for either FANTASTIC or AMADS method.</p> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>1 if sum is positive, 0 if sum is zero, -1 if sum is negative</p> </li> </ul> <p>Examples:</p> <p>Flat overall contour direction (returns the same using FANTASTIC method)</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.global_direction\n0\n</code></pre> <p>Upwards contour direction (returns the same using FANTASTIC method)</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 65, 67], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.global_direction\n1\n</code></pre> <p>Downwards contour direction (returns the same using FANTASTIC method)</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([67, 65, 67, 62, 60], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.global_direction\n-1\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour.mean_gradient","title":"mean_gradient  <code>property</code>","text":"<pre><code>mean_gradient: float\n</code></pre> <p>Calculate the absolute mean gradient of the interpolation contour. Can be invoked for either FANTASTIC or AMADS method.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Mean of the absolute gradient values</p> </li> </ul> <p>Examples:</p> <p>Steps of 2 semitones per second</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.mean_gradient\n2.0\n</code></pre> <p>FANTASTIC method returns 0.0 for this example</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4], method=\"fantastic\")\n&gt;&gt;&gt; ic.mean_gradient\n0.0\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour.gradient_std","title":"gradient_std  <code>property</code>","text":"<pre><code>gradient_std: float\n</code></pre> <p>Calculate the standard deviation of the interpolation contour gradients.</p> <p>Can be invoked for either FANTASTIC or AMADS method.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Standard deviation of the gradient values (by default, using Bessel's correction)</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.gradient_std\n2.0254...\n</code></pre> <p>FANTASTIC method returns 0.0 for this example</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4], method=\"fantastic\")\n&gt;&gt;&gt; ic.gradient_std\n0.0\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour.direction_changes","title":"direction_changes  <code>property</code>","text":"<pre><code>direction_changes: float\n</code></pre> <p>Calculate the proportion of interpolated gradient values that consistute a change in direction. For instance, a gradient value of -0.5 to 0.25 is a change in direction. Can be invoked for either FANTASTIC or AMADS method.</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Ratio of the number of changes in contour direction relative to the number of different interpolated gradient values</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.direction_changes\n1.0\n</code></pre> <p>FANTASTIC method returns 0.0 for this example</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4], method=\"fantastic\")\n&gt;&gt;&gt; ic.direction_changes\n0.0\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour.class_label","title":"class_label  <code>property</code>","text":"<pre><code>class_label: str\n</code></pre> <p>Classify an interpolation contour into gradient categories.</p> <p>Can be invoked for either FANTASTIC or AMADS method.</p> <p>The contour is sampled at 4 equally spaced points and each gradient is normalized to units of pitch change per second (expressed in units of semitones per 0.25 seconds.) The result is then classified into one of 5 categories:</p> <ul> <li>'a': Strong downward (-2) - normalized gradient &lt;= -1.45</li> <li>'b': Downward (-1) - normalized gradient between -1.45 and -0.45</li> <li>'c': Flat (0) - normalized gradient between -0.45 and 0.45</li> <li>'d': Upward (1) - normalized gradient between 0.45 and 1.45</li> <li>'e': Strong upward (2) - normalized gradient &gt;= 1.45</li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>String of length 4 containing letters a-e representing the gradient categories at 4 equally spaced points in the contour</p> </li> </ul> <p>Examples:</p> <p>Upwards, then downwards contour</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4])\n&gt;&gt;&gt; ic.class_label\n'ddbb'\n</code></pre> <p>FANTASTIC method returns 'cccc' for this example, as though the contour is flat</p> <pre><code>&gt;&gt;&gt; ic = InterpolationContour([60, 62, 64, 62, 60], [0, 1, 2, 3, 4], method=\"fantastic\")\n&gt;&gt;&gt; ic.class_label\n'cccc'\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour-functions","title":"Functions","text":""},{"location":"reference/melody/contour/#amads.melody.contour.interpolation_contour.InterpolationContour.calculate_interpolation_contour","title":"calculate_interpolation_contour  <code>staticmethod</code>","text":"<pre><code>calculate_interpolation_contour(\n    pitches: list[int], times: list[float], method: str = \"amads\"\n) -&gt; list[float]\n</code></pre> <p>Calculate the interpolation contour representation of a melody [1].</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>Array containing the interpolation contour representation</p> </li> </ul> Source code in <code>amads/melody/contour/interpolation_contour.py</code> <pre><code>@staticmethod\ndef calculate_interpolation_contour(\n    pitches: list[int], times: list[float], method: str = \"amads\"\n) -&gt; list[float]:\n    \"\"\"Calculate the interpolation contour representation of a melody [1].\n\n    Returns\n    -------\n    list[float]\n        Array containing the interpolation contour representation\n    \"\"\"\n    if method == \"fantastic\":\n        return InterpolationContour._calculate_fantastic_contour(\n            pitches, times\n        )\n\n    return InterpolationContour._calculate_amads_contour(pitches, times)\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour","title":"PolynomialContour","text":"<pre><code>PolynomialContour(score: Score)\n</code></pre> <p>A class for computing polynomial contour.</p> <p>As described in the FANTASTIC toolbox [1]. This approach is discussed in detail in M\u00fcllensiefen and Wiggins (2011) [2].</p> <p>Polynomial Contour is constructed in 3 simple steps:</p> <ul> <li> <p>First, the onsets are first centred around the origin of the time axis,    making a symmetry between the first onset and the last.</p> </li> <li> <p>Then, a polynomial model is fit, seeking to predict the pitch values from    a least squares regression of the centred onset times.</p> </li> <li> <p>Finally, the best model is selected using Bayes' Information Criterion,    stepwise and in a backwards direction.</p> </li> </ul> <p>The final output is the coefficients of the first three non-constant terms, i.e. [c1, c2, c3] from p = c0 + c1t + c2t^2 + c3t^3.</p> <p>Author: David Whyatt</p> <p>Attributes:</p> <ul> <li> <code>score</code>               (<code>Score</code>)           \u2013            <p>The score object containing the melody to analyze.</p> </li> <li> <code>coefficients</code>               (<code>list[float]</code>)           \u2013            <p>The polynomial contour coefficients. Returns the first 3 non-constant coefficients [c1, c2, c3] of the final selected polynomial contour model. The constant term is not included as per the FANTASTIC toolbox specification.</p> </li> </ul> References <ol> <li>M\u00fcllensiefen, D. (2009). Fantastic: Feature ANalysis Technology     Accessing STatistics (In a Corpus): Technical Report v1.5</li> <li>M\u00fcllensiefen, D., &amp; Wiggins, G.A. (2011). Polynomial functions as a     representation of melodic phrase contour.</li> </ol> <p>Examples:</p> <p>Single note melodies return [0.0, 0.0, 0.0] since there is no contour:</p> <pre><code>&gt;&gt;&gt; single_note = Score.from_melody([60], [1.0])\n&gt;&gt;&gt; pc = PolynomialContour(single_note)\n&gt;&gt;&gt; pc.coefficients\n[0.0, 0.0, 0.0]\n</code></pre> <p>Real melody examples:</p> <pre><code>&gt;&gt;&gt; the_lick = Score.from_melody([62, 64, 65, 67, 64, 60, 62],\n... [1.0, 1.0, 1.0, 1.0, 2.0, 1.0, 1.0])\n&gt;&gt;&gt; pc2 = PolynomialContour(the_lick)\n&gt;&gt;&gt; pc2.coefficients  # Verified against FANTASTIC toolbox\n[-1.5014826, -0.2661533, 0.1220570]\n</code></pre> <pre><code>&gt;&gt;&gt; twinkle = Score.from_melody([60, 60, 67, 67, 69, 69, 67, 65, 65, 64, 64, 62, 62, 60],\n... [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 2.0])\n&gt;&gt;&gt; pc3 = PolynomialContour(twinkle)\n&gt;&gt;&gt; pc3.coefficients  # Verified against FANTASTIC toolbox\n[-0.9535562, 0.2120971, 0.0000000]\n</code></pre> <p>are returned, as the constant term is not used in the FANTASTIC toolbox. It is believed that the first three polynomial coefficients capture enough variation in the contour to be useful.</p> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Methods:</p> <ul> <li> <code>calculate_coefficients</code>             \u2013              <p>Calculate polynomial contour coefficients for the melody.</p> </li> <li> <code>get_onsets_and_pitches</code>             \u2013              <p>Extract onset times and pitches from a Score object.</p> </li> <li> <code>center_onset_times</code>             \u2013              <p>Center onset times around their midpoint. This produces a symmetric axis</p> </li> <li> <code>fit_polynomial</code>             \u2013              <p>Fit a polynomial model to the melody contour using least squares regression.</p> </li> <li> <code>select_model</code>             \u2013              <p>Select the best polynomial model using BIC in a step-wise backwards fashion.</p> </li> </ul> Source code in <code>amads/melody/contour/polynomial_contour.py</code> <pre><code>def __init__(self, score: Score):\n    \"\"\"Initialize the polynomial contour using a Score object and calculate\n    the Polynomial Contour coefficients. Only the first three non-constant coefficients\n    are returned, as the constant term is not used in the FANTASTIC toolbox. It is\n    believed that the first three polynomial coefficients capture enough variation in\n    the contour to be useful.\n\n    Parameters\n    ----------\n    score : Score\n        The score object containing the melody to analyze.\n    \"\"\"\n    onsets, pitches = self.get_onsets_and_pitches(score)\n    self.coefficients = self.calculate_coefficients(onsets, pitches)\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score object containing the melody to analyze.</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour-functions","title":"Functions","text":""},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.calculate_coefficients","title":"calculate_coefficients","text":"<pre><code>calculate_coefficients(\n    onsets: list[float], pitches: list[int]\n) -&gt; list[float]\n</code></pre> <p>Calculate polynomial contour coefficients for the melody. Main method for the PolynomialContour class.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>First 3 coefficients [c1, c2, c3] of the polynomial contour, with zeros padded if needed. For melodies with fewer than 2 notes, returns [0.0, 0.0, 0.0] since there is no meaningful contour to analyze.</p> </li> </ul> Source code in <code>amads/melody/contour/polynomial_contour.py</code> <pre><code>def calculate_coefficients(\n    self, onsets: list[float], pitches: list[int]\n) -&gt; list[float]:\n    \"\"\"Calculate polynomial contour coefficients for the melody.\n    Main method for the PolynomialContour class.\n\n    Parameters\n    ----------\n    onsets : list[float]\n        List of onset times from the score\n    pitches : list[int]\n        List of pitch values from the score\n\n    Returns\n    -------\n    list[float]\n        First 3 coefficients [c1, c2, c3] of the polynomial contour, with zeros\n        padded if needed. For melodies with fewer than 2 notes, returns [0.0, 0.0, 0.0]\n        since there is no meaningful contour to analyze.\n    \"\"\"\n    if len(onsets) &lt;= 1:\n        return [0.0, 0.0, 0.0]\n\n    # Center onset times\n    centered_onsets = self.center_onset_times(onsets)\n\n    # Calculate polynomial degree\n    m = len(onsets) // 2\n\n    # Select best model using BIC\n    coefficients = self.select_model(centered_onsets, pitches, m)\n    return coefficients\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.calculate_coefficients(onsets)","title":"<code>onsets</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of onset times from the score</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.calculate_coefficients(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>List of pitch values from the score</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.get_onsets_and_pitches","title":"get_onsets_and_pitches","text":"<pre><code>get_onsets_and_pitches(score: Score) -&gt; tuple[list[float], list[int]]\n</code></pre> <p>Extract onset times and pitches from a Score object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[float], list[int]]</code>           \u2013            <p>A tuple containing (onset_times, pitch_values)</p> </li> </ul> Source code in <code>amads/melody/contour/polynomial_contour.py</code> <pre><code>def get_onsets_and_pitches(\n    self, score: Score\n) -&gt; tuple[list[float], list[int]]:\n    \"\"\"Extract onset times and pitches from a Score object.\n\n    Parameters\n    ----------\n    score : Score\n        The Score object to extract data from\n\n    Returns\n    -------\n    tuple[list[float], list[int]]\n        A tuple containing (onset_times, pitch_values)\n    \"\"\"\n    notes = score.get_sorted_notes()\n    return [note.onset for note in notes], [note.key_num for note in notes]\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.get_onsets_and_pitches(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The Score object to extract data from</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.center_onset_times","title":"center_onset_times","text":"<pre><code>center_onset_times(onsets: list[float]) -&gt; list[float]\n</code></pre> <p>Center onset times around their midpoint. This produces a symmetric axis of onset times, which is used later to fit the polynomial.</p> <p>For single-note melodies, returns [0.0] since there is no meaningful contour to analyze.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>List of centered onset times. Returns [0.0] for single-note melodies.</p> </li> </ul> Source code in <code>amads/melody/contour/polynomial_contour.py</code> <pre><code>def center_onset_times(self, onsets: list[float]) -&gt; list[float]:\n    \"\"\"Center onset times around their midpoint. This produces a symmetric axis\n    of onset times, which is used later to fit the polynomial.\n\n    For single-note melodies, returns [0.0] since there is no meaningful contour\n    to analyze.\n\n    Parameters\n    ----------\n    onsets : list[float]\n        List of onset times to center\n\n    Returns\n    -------\n    list[float]\n        List of centered onset times. Returns [0.0] for single-note melodies.\n    \"\"\"\n    if len(onsets) &lt;= 1:\n        return [0.0] * len(onsets)\n\n    # Calculate midpoint using first and last onset times\n    midpoint = (onsets[0] + onsets[-1]) / 2\n    # Subtract midpoint from each onset time\n    centered_onsets = [time - midpoint for time in onsets]\n    return centered_onsets\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.center_onset_times(onsets)","title":"<code>onsets</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of onset times to center</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.fit_polynomial","title":"fit_polynomial","text":"<pre><code>fit_polynomial(\n    centered_onsets: list[float], pitches: list[int], m: int\n) -&gt; list[float]\n</code></pre> <p>Fit a polynomial model to the melody contour using least squares regression.</p> <p>The polynomial has the form: p = c0 + c1t + c2t^2 + ... + cm*t^m</p> <p>where m = n // 2 (n = number of notes) and t are centered onset times.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>The coefficients [c0, c1, ..., cm] of the fitted polynomial</p> </li> </ul> Source code in <code>amads/melody/contour/polynomial_contour.py</code> <pre><code>def fit_polynomial(\n    self, centered_onsets: list[float], pitches: list[int], m: int\n) -&gt; list[float]:\n    \"\"\"Fit a polynomial model to the melody contour using least squares regression.\n\n    The polynomial has the form:\n    p = c0 + c1*t + c2*t^2 + ... + cm*t^m\n\n    where m = n // 2 (n = number of notes) and t are centered onset times.\n\n    Parameters\n    ----------\n    centered_onsets : list[float]\n        List of centered onset times\n    pitches : list[int]\n        List of pitch values\n    m : int\n        Maximum polynomial degree to use\n\n    Returns\n    -------\n    list[float]\n        The coefficients [c0, c1, ..., cm] of the fitted polynomial\n    \"\"\"\n\n    n = len(pitches)\n    if n &lt;= 1:\n        return [float(pitches[0]) if n == 1 else 0.0]\n\n    # Create predictor matrix X where each column is t^i\n    x = np.array(\n        [[t**i for i in range(m + 1)] for t in centered_onsets], dtype=float\n    )\n    y = np.array(pitches, dtype=float)\n\n    # Use numpy's least squares solver\n    coeffs = np.linalg.lstsq(x, y, rcond=None)[0]\n\n    return coeffs.tolist()\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.fit_polynomial(centered_onsets)","title":"<code>centered_onsets</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of centered onset times</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.fit_polynomial(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>List of pitch values</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.fit_polynomial(m)","title":"<code>m</code>","text":"(<code>int</code>)           \u2013            <p>Maximum polynomial degree to use</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.select_model","title":"select_model","text":"<pre><code>select_model(\n    centered_onsets: list[float], pitches: list[int], m: int\n) -&gt; list[float]\n</code></pre> <p>Select the best polynomial model using BIC in a step-wise backwards fashion. Tests polynomials of decreasing degree and selects the one with the best BIC. The max degree is the same as <code>m</code> in the fit_polynomial method.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>The coefficients [c1, c2, c3] of the selected polynomial model</p> </li> </ul> Source code in <code>amads/melody/contour/polynomial_contour.py</code> <pre><code>def select_model(\n    self, centered_onsets: list[float], pitches: list[int], m: int\n) -&gt; list[float]:\n    \"\"\"Select the best polynomial model using BIC in a step-wise backwards fashion.\n    Tests polynomials of decreasing degree and selects the one with the best BIC.\n    The max degree is the same as `m` in the fit_polynomial method.\n\n    Parameters\n    ----------\n    centered_onsets : list[float]\n        List of centered onset times\n    pitches : list[int]\n        List of pitch values\n    m : int\n        Maximum polynomial degree to consider\n\n    Returns\n    -------\n    list[float]\n        The coefficients [c1, c2, c3] of the selected polynomial model\n    \"\"\"\n    max_degree = m\n    pitches_array = np.array(pitches, dtype=float)\n    x_full = np.array(\n        [[t**i for i in range(max_degree + 1)] for t in centered_onsets]\n    )\n\n    # Start with maximum degree model\n    best_fit = self.fit_polynomial(centered_onsets, pitches, m)\n    best_coeffs = np.array(best_fit)\n    best_bic = self._calculate_bic(best_coeffs, x_full, pitches_array)\n\n    # Try all possible combinations of polynomial terms\n    for i in range(1, 2 ** (max_degree + 1)):\n        binary = format(i, f\"0{max_degree + 1}b\")\n        degrees = [j for j in range(1, max_degree + 1) if binary[j] == \"1\"]\n\n        if not degrees:  # Skip if only constant term\n            continue\n\n        # Create design matrix for this combination\n        x = np.ones((len(centered_onsets), len(degrees) + 1))\n        for j, degree in enumerate(degrees):\n            x[:, j + 1] = [t**degree for t in centered_onsets]\n\n        # Fit model with this combination of degrees\n        coeffs = np.linalg.lstsq(x, pitches_array, rcond=None)[0]\n\n        # Create a full coefficient array with zeros for missing degrees\n        test_coeffs = np.zeros(max_degree + 1)\n        test_coeffs[0] = coeffs[0]  # Constant term\n\n        # Fill in the coefficients for the included degrees\n        for j, degree in enumerate(degrees):\n            test_coeffs[degree] = coeffs[j + 1]\n\n        # Calculate BIC\n        bic = self._calculate_bic(test_coeffs, x_full, pitches_array)\n\n        # Keep simpler model if BIC improves\n        if bic &lt; best_bic:\n            best_coeffs = test_coeffs\n            best_bic = bic\n\n    return [\n        best_coeffs[1].item(),  # convert to native float\n        best_coeffs[2].item(),\n        best_coeffs[3].item(),\n    ]  # Return c1, c2, c3 coefficients\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.select_model(centered_onsets)","title":"<code>centered_onsets</code>","text":"(<code>list[float]</code>)           \u2013            <p>List of centered onset times</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.select_model(pitches)","title":"<code>pitches</code>","text":"(<code>list[int]</code>)           \u2013            <p>List of pitch values</p>"},{"location":"reference/melody/contour/#amads.melody.contour.polynomial_contour.PolynomialContour.select_model(m)","title":"<code>m</code>","text":"(<code>int</code>)           \u2013            <p>Maximum polynomial degree to consider</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_pitch_features","title":"fantastic_pitch_features","text":"<pre><code>fantastic_pitch_features(score: Score) -&gt; dict\n</code></pre> <p>Extract pitch features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of pitch features. Dictionary keys:     - pitch_range: The range of pitches in the melody.     - pitch_std: The standard deviation of the pitches in the melody.     - pitch_entropy: A variant of the Shannon entropy of the pitches in the melody.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_pitch_features(score: Score) -&gt; Dict:\n    \"\"\"Extract pitch features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract pitch features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of pitch features.\n        Dictionary keys:\n            - pitch_range: The range of pitches in the melody.\n            - pitch_std: The standard deviation of the pitches in the melody.\n            - pitch_entropy: A variant of the Shannon entropy of the pitches in the melody.\n    \"\"\"\n    notes = score.get_sorted_notes()\n\n    pitches = [note.pitch.key_num for note in notes]\n\n    pitch_range = max(pitches) - min(pitches)\n    pitch_std = np.std(pitches)\n\n    # Calculate pitch entropy using Shannon's formula\n    # First get frequency distribution of pitches\n    pitch_counts = Counter(pitches)\n    total_pitches = len(pitches)\n\n    # Calculate relative frequencies\n    pitch_freqs = {\n        p: count / total_pitches for p, count in pitch_counts.items()\n    }\n\n    # Calculate entropy using the formula from the FANTASTIC toolbox\n    pitch_entropy = -sum(\n        f * np.log2(f) for f in pitch_freqs.values()\n    ) / np.log2(24)\n\n    return {\n        \"pitch_range\": pitch_range,\n        \"pitch_std\": pitch_std,\n        \"pitch_entropy\": pitch_entropy,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_pitch_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract pitch features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_pitch_interval_features","title":"fantastic_pitch_interval_features","text":"<pre><code>fantastic_pitch_interval_features(score: Score) -&gt; dict\n</code></pre> <p>Extract pitch interval features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of pitch interval features. Dictionary keys:     - absolute_interval_range: The range of absolute pitch intervals in the melody.     - mean_absolute_interval: The mean of the absolute pitch intervals in the melody.     - std_absolute_interval: The standard deviation of the absolute pitch intervals in the melody.     - modal_interval: The modal absolute pitch interval in the melody.     - interval_entropy: A variant of the Shannon entropy of the absolute pitch intervals in the melody.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_pitch_interval_features(score: Score) -&gt; Dict:\n    \"\"\"Extract pitch interval features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract pitch interval features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of pitch interval features.\n        Dictionary keys:\n            - absolute_interval_range: The range of absolute pitch intervals in the melody.\n            - mean_absolute_interval: The mean of the absolute pitch intervals in the melody.\n            - std_absolute_interval: The standard deviation of the absolute pitch intervals in the melody.\n            - modal_interval: The modal absolute pitch interval in the melody.\n            - interval_entropy: A variant of the Shannon entropy of the absolute pitch intervals in the melody.\n    \"\"\"\n    notes = score.get_sorted_notes()\n\n    pitches = [note.pitch.key_num for note in notes]\n    # Fantastic defines intervals by looking forwards\n    intervals = [pitches[i + 1] - pitches[i] for i in range(len(pitches) - 1)]\n    # and then always uses the absolute value\n    abs_intervals = [abs(interval) for interval in intervals]\n\n    absolute_interval_range = max(abs_intervals) - min(abs_intervals)\n    mean_absolute_interval = np.mean(abs_intervals)\n    std_absolute_interval = np.std(abs_intervals)\n    modal_interval = max(set(abs_intervals), key=abs_intervals.count)\n\n    # Calculate interval entropy using Shannon's formula\n    # First get frequency distribution of intervals\n    interval_counts = Counter(abs_intervals)\n    total_intervals = len(abs_intervals)\n\n    # Calculate relative frequencies\n    interval_freqs = {\n        i: count / total_intervals for i, count in interval_counts.items()\n    }\n\n    # Calculate entropy using the formula from the FANTASTIC toolbox\n    # Note that the maximum number of different intervals is instead 23 here\n    interval_entropy = -sum(\n        f * np.log2(f) for f in interval_freqs.values()\n    ) / np.log2(23)\n\n    return {\n        \"absolute_interval_range\": absolute_interval_range,\n        \"mean_absolute_interval\": mean_absolute_interval,\n        \"std_absolute_interval\": std_absolute_interval,\n        \"modal_interval\": modal_interval,\n        \"interval_entropy\": interval_entropy,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_pitch_interval_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract pitch interval features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_duration_features","title":"fantastic_duration_features","text":"<pre><code>fantastic_duration_features(score: Score) -&gt; dict\n</code></pre> <p>Extract duration features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of duration features. Dictionary keys:</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_duration_features(score: Score) -&gt; Dict:\n    \"\"\"Extract duration features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract duration features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of duration features.\n        Dictionary keys:\n    \"\"\"\n\n    raise NotImplementedError(\"Not implemented yet\")\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_duration_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract duration features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_global_features","title":"fantastic_global_features","text":"<pre><code>fantastic_global_features(score: Score) -&gt; dict\n</code></pre> <p>Extract global extension features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of global extension features. Dictionary keys:</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_global_features(score: Score) -&gt; Dict:\n    \"\"\"Extract global extension features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract global extension features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of global extension features.\n        Dictionary keys:\n    \"\"\"\n\n    raise NotImplementedError(\"Not implemented yet\")\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_global_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract global extension features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_step_contour_features","title":"fantastic_step_contour_features","text":"<pre><code>fantastic_step_contour_features(score: Score) -&gt; dict\n</code></pre> <p>Extract step contour features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of step contour features. Dictionary keys:     - global_variation: The global variation of the step contour.     - global_direction: The global direction of the step contour.     - local_variation: The local variation of the step contour.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_step_contour_features(score: Score) -&gt; Dict:\n    \"\"\"Extract step contour features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract step contour features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of step contour features.\n        Dictionary keys:\n            - global_variation: The global variation of the step contour.\n            - global_direction: The global direction of the step contour.\n            - local_variation: The local variation of the step contour.\n    \"\"\"\n    notes = score.get_sorted_notes()\n\n    # Extract pitches and times for contour calculation\n    pitches = [note.pitch.key_num for note in notes]\n    durations = [note.duration for note in notes]\n\n    sc = StepContour(pitches, durations)\n\n    return {\n        \"global_variation\": sc.global_variation,\n        \"global_direction\": sc.global_direction,\n        \"local_variation\": sc.local_variation,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_step_contour_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract step contour features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_interpolation_contour_features","title":"fantastic_interpolation_contour_features","text":"<pre><code>fantastic_interpolation_contour_features(score: Score) -&gt; dict\n</code></pre> <p>Extract interpolation contour features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of interpolation contour features. Dictionary keys:     - global_direction: The global direction of the interpolation contour.     - mean_gradient: The mean gradient of the interpolation contour.     - gradient_std: The standard deviation of the gradient of the interpolation contour.     - direction_changes: The number of direction changes in the interpolation contour.     - class_label: The class label of the interpolation contour.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_interpolation_contour_features(score: Score) -&gt; Dict:\n    \"\"\"Extract interpolation contour features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract interpolation contour features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of interpolation contour features.\n        Dictionary keys:\n            - global_direction: The global direction of the interpolation contour.\n            - mean_gradient: The mean gradient of the interpolation contour.\n            - gradient_std: The standard deviation of the gradient of the interpolation contour.\n            - direction_changes: The number of direction changes in the interpolation contour.\n            - class_label: The class label of the interpolation contour.\n    \"\"\"\n    notes = score.get_sorted_notes()\n\n    # Extract pitches and times for contour calculation\n    pitches = [note.pitch.key_num for note in notes]\n    times = [note.onset for note in notes]\n\n    # Calculate contour\n    ic = InterpolationContour(pitches, times, method=\"fantastic\")\n\n    return {\n        # Interpolation contour features\n        \"global_direction\": ic.global_direction,\n        \"mean_gradient\": ic.mean_gradient,\n        \"gradient_std\": ic.gradient_std,\n        \"direction_changes\": ic.direction_changes,\n        \"class_label\": ic.class_label,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_interpolation_contour_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract interpolation contour features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_parsons_contour_features","title":"fantastic_parsons_contour_features","text":"<pre><code>fantastic_parsons_contour_features(\n    score: Score,\n    character_dict: dict = None,\n    initial_asterisk: bool = False,\n) -&gt; dict\n</code></pre> <p>Extract Parsons contour features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of Parsons contour features. Dictionary keys:     - interval_sequence: The interval sequence of the melody.     - interval_sequence_sign: A representation of the direction of the interval sequence         using -1, 0, and 1 to represent down, repeat, and up intervals respectively.     - as_string: The Parsons contour as a string, using the characters u, r, and d         to represent up, repeat, and down intervals respectively.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_parsons_contour_features(\n    score: Score, character_dict: Dict = None, initial_asterisk: bool = False\n) -&gt; Dict:\n    \"\"\"Extract Parsons contour features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract Parsons contour features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of Parsons contour features.\n        Dictionary keys:\n            - interval_sequence: The interval sequence of the melody.\n            - interval_sequence_sign: A representation of the direction of the interval sequence\n                using -1, 0, and 1 to represent down, repeat, and up intervals respectively.\n            - as_string: The Parsons contour as a string, using the characters u, r, and d\n                to represent up, repeat, and down intervals respectively.\n    \"\"\"\n\n    notes = score.get_sorted_notes()\n\n    pitches = [note.pitch.key_num for note in notes]\n    pc = ParsonsContour(\n        pitches,\n        character_dict=character_dict,\n        initial_asterisk=initial_asterisk,\n    )\n\n    return {\n        \"interval_sequence\": pc.interval_sequence,\n        \"interval_sequence_sign\": pc.interval_sequence_sign,\n        \"as_string\": pc.as_string,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_parsons_contour_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract Parsons contour features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_polynomial_contour_features","title":"fantastic_polynomial_contour_features","text":"<pre><code>fantastic_polynomial_contour_features(score: Score) -&gt; dict\n</code></pre> <p>Extract polynomial contour features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of polynomial contour coefficients. Dictionary keys:     - coefficients: The coefficients of the polynomial contour.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_polynomial_contour_features(score: Score) -&gt; Dict:\n    \"\"\"Extract polynomial contour features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract polynomial contour features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of polynomial contour coefficients.\n        Dictionary keys:\n            - coefficients: The coefficients of the polynomial contour.\n    \"\"\"\n\n    pc = PolynomialContour(score)\n\n    return {\n        \"coefficients\": pc.coefficients,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_polynomial_contour_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract polynomial contour features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_huron_contour_features","title":"fantastic_huron_contour_features","text":"<pre><code>fantastic_huron_contour_features(score: Score) -&gt; dict\n</code></pre> <p>Extract Huron contour features from a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of Huron contour features. Dictionary keys:     - first_pitch: The first pitch of the melody.     - mean_pitch: The mean pitch of the melody.     - last_pitch: The last pitch of the melody.     - first_to_mean: The difference between the first and mean pitch.     - mean_to_last: The difference between the mean and last pitch.     - contour_class: The class of the Huron contour.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_huron_contour_features(score: Score) -&gt; Dict:\n    \"\"\"Extract Huron contour features from a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to extract Huron contour features from.\n\n    Returns\n    -------\n    Dict\n        A dictionary of Huron contour features.\n        Dictionary keys:\n            - first_pitch: The first pitch of the melody.\n            - mean_pitch: The mean pitch of the melody.\n            - last_pitch: The last pitch of the melody.\n            - first_to_mean: The difference between the first and mean pitch.\n            - mean_to_last: The difference between the mean and last pitch.\n            - contour_class: The class of the Huron contour.\n    \"\"\"\n    notes = score.get_sorted_notes()\n\n    pitches = [note.pitch.key_num for note in notes]\n    times = [note.onset for note in notes]\n\n    hc = HuronContour(pitches, times)\n\n    return {\n        \"first_pitch\": hc.first_pitch,\n        \"mean_pitch\": hc.mean_pitch,\n        \"last_pitch\": hc.last_pitch,\n        \"first_to_mean\": hc.first_to_mean,\n        \"mean_to_last\": hc.mean_to_last,\n        \"contour_class\": hc.contour_class,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_huron_contour_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to extract Huron contour features from.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_count_mtypes","title":"fantastic_count_mtypes","text":"<pre><code>fantastic_count_mtypes(\n    score: Score, segment: bool, phrase_gap: float, units: str\n) -&gt; NGramCounter\n</code></pre> <p>Count M-Types in a melody.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>NGramCounter</code>           \u2013            <p>An NGramCounter object containing the counts of M-Types. This allows for the computation of the complexity measures, either by accessing the properties of the NGramCounter object or by using the <code>fantastic_mtype_summary_features</code> function.</p> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_count_mtypes(\n    score: Score, segment: bool, phrase_gap: float, units: str\n) -&gt; NGramCounter:\n    \"\"\"Count M-Types in a melody.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to count M-Types in.\n    segment : bool\n        Whether to segment the melody into phrases.\n    phrase_gap : float\n        The minimum IOI gap to consider a new phrase.\n    units : str\n        The units of the phrase gap, either \"seconds\" or \"quarters\".\n\n    Returns\n    -------\n    NGramCounter\n        An NGramCounter object containing the counts of M-Types.\n        This allows for the computation of the complexity measures, either\n        by accessing the properties of the NGramCounter object or by using\n        the `fantastic_mtype_summary_features` function.\n    \"\"\"\n    if segment:\n        segments = fantastic_segmenter(score, phrase_gap, units)\n    else:\n        segments = [score]\n\n    counter = NGramCounter()\n    tokenizer = FantasticTokenizer()\n\n    all_tokens = []\n    for phrase in segments:\n        tokens = tokenizer.tokenize(phrase)\n        all_tokens.extend(tokens)\n\n    counter.count_ngrams(all_tokens, n=[1, 2, 3, 4, 5])\n\n    return counter\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_count_mtypes(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to count M-Types in.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_count_mtypes(segment)","title":"<code>segment</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to segment the melody into phrases.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_count_mtypes(phrase_gap)","title":"<code>phrase_gap</code>","text":"(<code>float</code>)           \u2013            <p>The minimum IOI gap to consider a new phrase.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_count_mtypes(units)","title":"<code>units</code>","text":"(<code>str</code>)           \u2013            <p>The units of the phrase gap, either \"seconds\" or \"quarters\".</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_mtype_summary_features","title":"fantastic_mtype_summary_features","text":"<pre><code>fantastic_mtype_summary_features(\n    score: Score, segment: bool, phrase_gap: float, units: str\n) -&gt; dict\n</code></pre> <p>Count M-Types in a melody and compute summary features.</p> <p>This function provides an easy way to get all the complexity measures at once.</p> <p>Author: David Whyatt</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>A dictionary of summary features. Dictionary keys:</p> <pre><code>- mean_entropy: The mean entropy of the M-Types.\n- mean_productivity: The mean productivity of the M-Types.\n- yules_k: The mean Yules K statistic.\n- simpsons_d: The mean Simpson's D statistic.\n- sichels_s: The mean Sichels S statistic.\n- honores_h: The mean Honores H statistic.\n</code></pre> </li> </ul> Source code in <code>amads/melody/fantastic.py</code> <pre><code>def fantastic_mtype_summary_features(\n    score: Score, segment: bool, phrase_gap: float, units: str\n) -&gt; Dict:\n    \"\"\"Count M-Types in a melody and compute summary features.\n\n    This function provides an easy way to get all the complexity measures\n    at once.\n\n    &lt;small&gt;**Author**: David Whyatt&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The score to count M-Types in.\n    segment : bool\n        Whether to segment the melody into phrases.\n    phrase_gap : float\n        The minimum IOI gap to consider a new phrase.\n    units : str\n        The units of the phrase gap, either \"seconds\" or \"quarters\".\n\n    Returns\n    -------\n    Dict\n        A dictionary of summary features.\n        Dictionary keys:\n\n            - mean_entropy: The mean entropy of the M-Types.\n            - mean_productivity: The mean productivity of the M-Types.\n            - yules_k: The mean Yules K statistic.\n            - simpsons_d: The mean Simpson's D statistic.\n            - sichels_s: The mean Sichels S statistic.\n            - honores_h: The mean Honores H statistic.\n    \"\"\"\n    mtype_counts = fantastic_count_mtypes(score, segment, phrase_gap, units)\n\n    return {\n        \"mean_entropy\": mtype_counts.mean_entropy,\n        \"mean_productivity\": mtype_counts.mean_productivity,\n        \"yules_k\": mtype_counts.yules_k,\n        \"simpsons_d\": mtype_counts.simpsons_d,\n        \"sichels_s\": mtype_counts.sichels_s,\n        \"honores_h\": mtype_counts.honores_h,\n    }\n</code></pre>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_mtype_summary_features(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to count M-Types in.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_mtype_summary_features(segment)","title":"<code>segment</code>","text":"(<code>bool</code>)           \u2013            <p>Whether to segment the melody into phrases.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_mtype_summary_features(phrase_gap)","title":"<code>phrase_gap</code>","text":"(<code>float</code>)           \u2013            <p>The minimum IOI gap to consider a new phrase.</p>"},{"location":"reference/melody/contour/#amads.melody.fantastic.fantastic_mtype_summary_features(units)","title":"<code>units</code>","text":"(<code>str</code>)           \u2013            <p>The units of the phrase gap, either \"seconds\" or \"quarters\".</p>"},{"location":"reference/melody/segment/","title":"Segment","text":""},{"location":"reference/melody/segment/#amads.melody.segment.fantastic_segmenter","title":"fantastic_segmenter","text":"<pre><code>fantastic_segmenter(\n    score: Score, phrase_gap: float, units: str\n) -&gt; list[Score]\n</code></pre> <p>Segment melody into phrases based on IOI gaps.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[Score]</code>           \u2013            <p>List of Score objects representing phrases</p> </li> </ul> Source code in <code>amads/melody/segment.py</code> <pre><code>def fantastic_segmenter(\n    score: Score, phrase_gap: float, units: str\n) -&gt; List[Score]:\n    \"\"\"Segment melody into phrases based on IOI gaps.\n    Parameters\n    ----------\n    score : Score\n        Score object containing melody to segment\n    phrase_gap : float\n        The minimum IOI gap to consider a new phrase\n    units : str\n        The units of the phrase gap, either \"seconds\" or \"quarters\"\n\n    Returns\n    -------\n    list[Score]\n        List of Score objects representing phrases\n    \"\"\"\n    assert units in [\"seconds\", \"quarters\"]\n    if units == \"seconds\":\n        raise NotImplementedError(\n            \"Seconds are not yet implemented, see issue #75: \"\n            \"https://github.com/music-computing/amads/issues/75\"\n        )\n    if units == \"quarters\":\n        # Extract notes from score\n        notes = score.get_sorted_notes()\n\n        # Create a dictionary to store IOI information\n        ioi_data = {}\n\n        # Calculate IOIs\n        for i, note in enumerate(notes):\n            # Initialize entry for this note\n            ioi_data[note] = None\n\n            # first note has no IOI by convention\n            if i &gt; 0:\n                ioi_data[note] = note.onset - notes[i - 1].onset\n            else:\n                ioi_data[note] = None\n\n        phrases = []\n        current_phrase = []\n        for note in notes:\n            # Check whether we need to make a new phrase\n            need_new_phrase = (\n                len(current_phrase) &gt; 0\n                and ioi_data[note]\n                is not None  # Check current note's IOI instead of previous note\n                and ioi_data[note] &gt; phrase_gap\n            )\n            if need_new_phrase:\n                # Create new score for the phrase\n                phrase_score = Score(onset=0, duration=None)\n                part = Part(\n                    parent=None, onset=0, duration=None\n                )  # parent=None is required\n                start_time = current_phrase[0].onset\n                # Adjust note timings relative to phrase start\n                for phrase_note in current_phrase:\n                    # make a parentless copy of the note so we can adjust its onset\n                    # before inserting it into the new part in proper time order\n                    new_note = phrase_note.insert_copy_into(None)\n                    new_note.onset -= start_time\n                    part.insert(new_note)\n                phrase_score.insert(part)  # This will set the parent\n                phrases.append(phrase_score)\n                current_phrase = []\n            current_phrase.append(note)\n\n        # Append final phrase\n        if len(current_phrase) &gt; 0:\n            phrase_score = Score(onset=0, duration=None)\n            part = Part(\n                parent=None, onset=0, duration=None\n            )  # parent=None is required\n            start_time = current_phrase[0].onset\n            for phrase_note in current_phrase:\n                new_note = phrase_note.insert_copy_into(None)\n                new_note.onset -= start_time\n                part.insert(new_note)\n            phrase_score.insert(part)  # This will set the parent\n            phrases.append(phrase_score)\n\n        return phrases\n</code></pre>"},{"location":"reference/melody/segment/#amads.melody.segment.fantastic_segmenter(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>Score object containing melody to segment</p>"},{"location":"reference/melody/segment/#amads.melody.segment.fantastic_segmenter(phrase_gap)","title":"<code>phrase_gap</code>","text":"(<code>float</code>)           \u2013            <p>The minimum IOI gap to consider a new phrase</p>"},{"location":"reference/melody/segment/#amads.melody.segment.fantastic_segmenter(units)","title":"<code>units</code>","text":"(<code>str</code>)           \u2013            <p>The units of the phrase gap, either \"seconds\" or \"quarters\"</p>"},{"location":"reference/melody/segment_gestalt/","title":"Segment gestalt","text":""},{"location":"reference/melody/segment_gestalt/#amads.melody.segment_gestalt","title":"segment_gestalt","text":"<p>This module implements the segment gestalt function by Tenney &amp; Polansky (1980)</p> <p>We can broadly categorise the algorithm's limitations to 2 categories:</p> <ol> <li> <p>Soft restrictions</p> </li> <li> <p>Hard restrictions on what scores we can take, either because     the algorithm exhibits undefined behavior when these scores are given,     or because it isn't designed for said restrictions.</p> </li> </ol> <p>With these categories in mind, we have the following limitations. The algorithm does not consider these things within its scope (given a monophonic input):</p> <ol> <li> <p>the monophonic music may have stream segregation     (i.e. 1 stream of notes can be interpreted as 2 or     more separate interspersed entities)</p> </li> <li> <p>does not consider harmony or shape (see beginning of section 2     for the OG paper for more details)</p> </li> <li> <p>does not give semantic meaning (we're still stuck giving     arbitrary ideals to arbitrary things)</p> </li> </ol> <p>The algorithm has the following restriction to the score:</p> <ul> <li>the score must be monophonic (perception differences)     If we consider polyphonic scores, we will need a definition of what     a substructure is for said score (in said algorithm) with respect to     how we carve the note strutures. Since, in this algorithm, we don't     consider stream segregation and other features that require larger     context clues, we can just simply define a score substructure     \u201ctemporally\u201d as a contiguous subsequence of notes. Hence, it is safe     to assume that the current algorithm is undefined when it comes to     polyphonic music.</li> </ul> <p>Some thoughts (and questions): (1) Should our output preserve the internal structure of the score for segments and clangs? Probably not. Keep in mind we're dealing with monophonic score structures. we just need to provide sufficient information that allows a caller to potentially verify the result and use it elsewhere, hence we simply return 2 lists of separate scores.</p> <p>Legit think having a separate representation that can index into individual notes will be immensely helpful. But, I'm certain there has to be something I'm missing to decide otherwise (if I had to guess, ambiguity of how musical scores themselves are presented to the musician is chief among them, and maintaining that ambiguity in our internal representation is also paramount)</p> <p>Also legit think we need well-defined rules to split and merge scores...</p> <p>On a completely separate and unrelated note, there are 2 pitchmeans with, the exact same implementation and 2 filenames...</p>"},{"location":"reference/melody/segment_gestalt/#amads.melody.segment_gestalt.segment_gestalt","title":"segment_gestalt","text":"<pre><code>segment_gestalt(score: Score) -&gt; tuple[list[float], list[float]]\n</code></pre> <p>Given a monophonic score, returns clang and segment boundary onsets</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[float], list[float]]</code>           \u2013            <p>None if no clangs can be formed, else, 2-tuple of: (sorted list of onsets denoting clangs boundaries, sorted list of onsets denoting segments segment boundaries)</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>Exception</code>             \u2013            <p>if the score is not monophonic</p> </li> </ul> Source code in <code>amads/melody/segment_gestalt.py</code> <pre><code>def segment_gestalt(score: Score) -&gt; tuple[list[float], list[float]]:\n    \"\"\"\n    Given a monophonic score, returns clang and segment boundary onsets\n\n    Parameters\n    ----------\n    score: Score\n        The score to be segmented\n\n    Returns\n    -------\n    tuple[list[float], list[float]]\n        None if no clangs can be formed, else, 2-tuple of:\n        (sorted list of onsets denoting clangs boundaries,\n        sorted list of onsets denoting segments segment boundaries)\n\n\n    Raises\n    ------\n    Exception\n        if the score is not monophonic\n    \"\"\"\n    if not score.ismonophonic():\n        raise Exception(\"score not monophonic, input is not valid.\")\n\n    notes: List[Note] = cast(\n        List[Note], score.flatten(collapse=True).list_all(Note)\n    )\n\n    if len(notes) &lt;= 0:\n        return ([], [])\n\n    cl_values = []\n    # calculate clang distances here\n    for note_pair in zip(notes[:-1], notes[1:]):\n        pitch_diff = note_pair[1].key_num - note_pair[0].key_num\n        onset_diff = note_pair[1].onset - note_pair[0].onset\n        cl_values.append(2 * onset_diff + abs(pitch_diff))\n\n    # combines the boolean map and the scan function that was done in matlab\n    if len(cl_values) &lt; 3:\n        return ([], [])\n\n    clang_soft_peaks = _find_peaks(cl_values)\n    cl_indices = [0]\n    # worry about indices here\n    # starting index here\n    # 1 past the end so we can construct score list easier\n    cl_indices.extend([idx + 1 for idx in clang_soft_peaks])\n    cl_indices.append(len(notes))\n\n    clang_onsets = list(map(lambda i: (notes[i].onset), cl_indices[:-1]))\n\n    if len(clang_onsets) &lt;= 2:\n        return (clang_onsets, [])\n\n    # we can probably split the clangs here and organize them into scores\n    clang_scores = _construct_score_list(\n        notes, zip(cl_indices[:-1], cl_indices[1:])\n    )\n    # calculate segment boundaries\n    # we need to basically follow segment_gestalt.m\n    # (1) calculate individual clang pitch means\n    mean_pitches = [pitch_mean(score, weighted=True) for score in clang_scores]\n\n    # (2) calculate segment distances\n    seg_dist_values = []\n    # calculating segment distance...\n    for i in range(len(clang_scores) - 1):\n        local_seg_dist = 0.0\n        # be careful of the indices when calculating segdist here\n        local_seg_dist += abs(mean_pitches[i + 1] - mean_pitches[i])\n        # first first distance\n        local_seg_dist += (\n            notes[cl_indices[i + 1]].onset - notes[cl_indices[i]].onset\n        )\n        # first of next clang to last of distance\n        local_seg_dist += abs(\n            notes[cl_indices[i + 1]].key_num\n            - notes[cl_indices[i + 1] - 1].key_num\n        )\n        local_seg_dist += 2 * (\n            notes[cl_indices[i + 1]].onset - notes[cl_indices[i + 1] - 1].onset\n        )\n        seg_dist_values.append(local_seg_dist)\n    if len(seg_dist_values) &lt; 3:\n        return (clang_onsets, [])\n\n    seg_soft_peaks = _find_peaks(seg_dist_values)\n    assert seg_soft_peaks[-1] &lt; len(cl_indices) - 1\n    seg_indices = [0]\n    # do we need to add 1 here? where do we add 1\n    # worry about indices here\n    seg_indices.extend([cl_indices[idx + 1] for idx in seg_soft_peaks])\n    seg_indices.append(len(notes))\n\n    segment_onsets = list(map(lambda i: (notes[i].onset), seg_indices[:-1]))\n    return (clang_onsets, segment_onsets)\n</code></pre>"},{"location":"reference/melody/segment_gestalt/#amads.melody.segment_gestalt.segment_gestalt(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to be segmented</p>"},{"location":"reference/melody/similarity/","title":"Similarity","text":""},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim","title":"melsim","text":"<p>This is a Python wrapper for the R package 'melsim'. This wrapper allows the user to easily interface with the melsim package using the AMADS Score object. Melsim is a package for computing similarity between melodies, and is being developed by Sebastian Silas and Klaus Frieler (https://www.aesthetics.mpg.de/en/the-institute/people/klaus-frieler.html).</p> <p>Melsim is based on SIMILE, which was written by Daniel M\u00fcllensiefen and Klaus Frieler in 2003/2004. This package is used to compare two or more melodies pairwise across a range of similarity measures. Not all similarity measures are implemented in melsim, but the ones that are can be used here. All of the following similarity measures are implemented and functional in melsim: Please be aware that the names of the similarity measures are case-sensitive.</p> Num Name 1 Jaccard 2 Kulczynski2 3 Russel 4 Faith 5 Tanimoto 6 Dice 7 Mozley 8 Ochiai 9 Simpson 10 cosine 11 angular 12 correlation 13 Tschuprow 14 Cramer 15 Gower 16 Euclidean 17 Manhattan 18 supremum 19 Canberra 20 Chord 21 Geodesic 22 Bray 23 Soergel 24 Podani 25 Whittaker 26 eJaccard 27 eDice 28 Bhjattacharyya 29 divergence 30 Hellinger 31 edit_sim_utf8 32 edit_sim 33 Levenshtein 34 sim_NCD 35 const 36 sim_dtw <p>The following similarity measures are not currently functional in melsim:</p> Num Name Type 1 count_distinct set-based 2 tversky set-based 3 simple matching 4 braun_blanquet set-based 5 minkowski vector-based 6 ukkon distribution-based 7 sum_common distribution-based 8 distr_sim distribution-based 9 stringdot_utf8 sequence-based 10 pmi special 11 sim_emd special <p>Further to the similarity measures, melsim allows the user to specify which domain the similarity should be calculated for. This is referred to as a \u201ctransformation\u201d in melsim, and all of the following transformations are implemented and functional:</p> Num Name 1 pitch 2 int 3 fuzzy_int 4 parsons 5 pc 6 ioi_class 7 duration_class 8 int_X_ioi_class 9 implicit_harmonies <p>The following transformations are not currently functional in melsim:</p> Num Name 1 ioi 2 phrase_segmentation <p>Functions:</p> <ul> <li> <code>run_script_in_r</code>             \u2013              <p>Run an R script and return its output.</p> </li> <li> <code>check_r_packages_installed</code>             \u2013              <p>Check if required R packages are installed.</p> </li> <li> <code>install_r_package</code>             \u2013              <p>Install an R package.</p> </li> <li> <code>install_dependencies</code>             \u2013              <p>Install all required R packages.</p> </li> <li> <code>check_python_package_installed</code>             \u2013              <p>Check if a Python package is installed.</p> </li> <li> <code>validate_method</code>             \u2013              <p>Validate that the similarity method is supported.</p> </li> <li> <code>validate_transformation</code>             \u2013              <p>Validate that the transformation is supported.</p> </li> <li> <code>get_similarity</code>             \u2013              <p>Calculate similarity between two Score objects using the specified method.</p> </li> <li> <code>score_to_arrays</code>             \u2013              <p>Extract melody attributes from a Score object.</p> </li> <li> <code>get_similarities</code>             \u2013              <p>Calculate pairwise similarities between multiple Score objects.</p> </li> </ul>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim-functions","title":"Functions","text":""},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.run_script_in_r","title":"run_script_in_r","text":"<pre><code>run_script_in_r(script: str, text: bool = True) -&gt; str\n</code></pre> <p>Run an R script and return its output.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Standard output from the R script</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error running the R script</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def run_script_in_r(script: str, text: bool = True) -&gt; str:\n    \"\"\"Run an R script and return its output.\n\n    Parameters\n    ----------\n    script : str\n        R script to run\n\n    Returns\n    -------\n    str\n        Standard output from the R script\n\n    Raises\n    ------\n    RuntimeError\n        If there is an error running the R script\n    \"\"\"\n    global _rscript_path\n    if not _rscript_path:\n        _rscript_path = _find_rscript()\n    result = subprocess.run(\n        [_rscript_path, \"-e\", script],\n        capture_output=True,\n        text=text,\n        check=True,\n    )\n    return result.stdout.strip()\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.run_script_in_r(script)","title":"<code>script</code>","text":"(<code>str</code>)           \u2013            <p>R script to run</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.check_r_packages_installed","title":"check_r_packages_installed","text":"<pre><code>check_r_packages_installed(\n    install_missing: bool = False, n_retries: int = 3\n)\n</code></pre> <p>Check if required R packages are installed.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If required packages are missing and install_missing is False.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error checking or installing packages.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def check_r_packages_installed(\n    install_missing: bool = False, n_retries: int = 3\n):\n    \"\"\"Check if required R packages are installed.\n\n    Parameters\n    ----------\n    install_missing : bool, default=False\n        If True, attempt to install missing packages automatically.\n    n_retries : int, default=3\n        Number of retries for installing each missing package.\n\n    Raises\n    ------\n    ImportError\n        If required packages are missing and install_missing is False.\n    RuntimeError\n        If there is an error checking or installing packages.\n    \"\"\"\n    # Create R script to check package installation using base R only\n    check_script = \"\"\"\n    packages &lt;- c({packages})\n    missing &lt;- packages[!sapply(packages, requireNamespace, quietly = TRUE)]\n    if (length(missing) &gt; 0) {{\n        cat(paste0('\"', missing, '\"', collapse = \",\"))\n    }} else {{\n        cat(\"\")\n    }}\n    \"\"\"\n\n    # Format package list\n    packages_str = \", \".join(\n        [f'\"{p}\"' for p in r_cran_packages + r_github_packages]\n    )\n    check_script = check_script.format(packages=packages_str)\n\n    # Run R script\n    try:\n        output = run_script_in_r(check_script)\n\n        # Parse the output - if empty, no missing packages\n        if not output:\n            missing_packages = []\n        else:\n            # Parse comma-separated quoted strings\n            missing_packages = [pkg.strip('\"') for pkg in output.split(\",\")]\n\n        if missing_packages:\n            if install_missing:\n                for package in missing_packages:\n                    try:\n                        for attempt in Retrying(\n                            stop=stop_after_attempt(n_retries),\n                            wait=wait_exponential(multiplier=1, min=1, max=10),\n                        ):\n                            with attempt:\n                                install_r_package(package)\n                    except RetryError as e:\n                        raise RuntimeError(\n                            f\"Failed to install R package '{package}' after {n_retries} attempts. \"\n                            \"See above for the traceback.\"\n                        ) from e\n            else:\n                raise ImportError(\n                    f\"Packages {missing_packages} are required but not installed. \"\n                    \"You can install them by running: install_dependencies()\"\n                )\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error checking R packages: {e.stderr}\")\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.check_r_packages_installed(install_missing)","title":"<code>install_missing</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, attempt to install missing packages automatically.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.check_r_packages_installed(n_retries)","title":"<code>n_retries</code>","text":"(<code>int</code>, default:                   <code>3</code> )           \u2013            <p>Number of retries for installing each missing package.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.install_r_package","title":"install_r_package","text":"<pre><code>install_r_package(package: str)\n</code></pre> <p>Install an R package.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the package type is unknown.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def install_r_package(package: str):\n    \"\"\"Install an R package.\n\n    Parameters\n    ----------\n    package : str\n        Name of the R package to install.\n\n    Raises\n    ------\n    ValueError\n        If the package type is unknown.\n    \"\"\"\n    if package in r_cran_packages:\n        print(f\"Installing CRAN package '{package}'...\")\n        install_script = f\"\"\"\n        utils::chooseCRANmirror(ind=1)\n        utils::install.packages(\"{package}\", dependencies=TRUE)\n        \"\"\"\n        _ = run_script_in_r(install_script)\n    elif package in r_github_packages:\n        print(f\"Installing GitHub package '{package}'...\")\n        repo = github_repos[package]\n        install_script = f\"\"\"\n        if (!requireNamespace(\"remotes\", quietly = TRUE)) {{\n            utils::install.packages(\"remotes\")\n        }}\n        remotes::install_github(\"{repo}\", upgrade=\"always\", dependencies=TRUE)\n        \"\"\"\n        _ = run_script_in_r(install_script)\n    else:\n        raise ValueError(f\"Unknown package type for '{package}'\")\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.install_r_package(package)","title":"<code>package</code>","text":"(<code>str</code>)           \u2013            <p>Name of the R package to install.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.install_dependencies","title":"install_dependencies","text":"<pre><code>install_dependencies()\n</code></pre> <p>Install all required R packages.</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If required packages are missing and install_missing is False.</p> </li> <li> <code>RuntimeError</code>             \u2013            <p>If there is an error checking or installing packages.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def install_dependencies():\n    \"\"\"Install all required R packages.\n\n    Raises\n    ------\n    ImportError\n        If required packages are missing and install_missing is False.\n    RuntimeError\n        If there is an error checking or installing packages.\n    \"\"\"\n    # Check which packages need to be installed using base R only\n    check_script = \"\"\"\n    packages &lt;- c({packages})\n    missing &lt;- packages[!sapply(packages, requireNamespace, quietly = TRUE)]\n    if (length(missing) &gt; 0) {{\n        cat(paste0('\"', missing, '\"', collapse = \",\"))\n    }} else {{\n        cat(\"\")\n    }}\n    \"\"\"\n\n    # Check CRAN packages\n    packages_str = \", \".join([f'\"{p}\"' for p in r_cran_packages])\n    check_script_cran = check_script.format(packages=packages_str)\n\n    try:\n        output = run_script_in_r(check_script_cran)\n\n        # Parse the output - if empty, no missing packages\n        if not output:\n            missing_cran = []\n        else:\n            # Parse comma-separated quoted strings\n            missing_cran = [pkg.strip('\"') for pkg in output.split(\",\")]\n\n        if missing_cran:\n            print(\"Installing missing CRAN packages...\")\n            cran_script = f\"\"\"\n            utils::chooseCRANmirror(ind=1)\n            utils::install.packages(c({\", \".join([f'\"{p}\"' for p in missing_cran])}), dependencies=TRUE)\n            \"\"\"\n            _ = run_script_in_r(cran_script)\n        else:\n            print(\"Skipping install: All CRAN packages are already installed.\")\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error checking CRAN packages: {e.stderr}\")\n\n    # Check GitHub packages\n    packages_str = \", \".join([f'\"{p}\"' for p in r_github_packages])\n    check_script_github = check_script.format(packages=packages_str)\n\n    try:\n        output = run_script_in_r(check_script_github)\n\n        # Parse the output - if empty, no missing packages\n        if not output:\n            missing_github = []\n        else:\n            # Parse comma-separated quoted strings\n            missing_github = [pkg.strip('\"') for pkg in output.split(\",\")]\n\n        if missing_github:\n            print(\"Installing missing GitHub packages...\")\n            for package in missing_github:\n                repo = github_repos[package]\n                print(f\"Installing {package} from {repo}...\")\n                install_script = f\"\"\"\n                if (!requireNamespace(\"remotes\", quietly = TRUE)) {{\n                    utils::install.packages(\"remotes\")\n                }}\n                remotes::install_github(\"{repo}\", upgrade=\"always\", dependencies=TRUE)\n                \"\"\"\n                _ = run_script_in_r(install_script)\n        else:\n            print(\n                \"Skipping install: All GitHub packages are already installed.\"\n            )\n    except subprocess.CalledProcessError as e:\n        raise RuntimeError(f\"Error checking GitHub packages: {e.stderr}\")\n\n    print(\"All dependencies are installed and up to date.\")\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.check_python_package_installed","title":"check_python_package_installed","text":"<pre><code>check_python_package_installed(package: str)\n</code></pre> <p>Check if a Python package is installed.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ImportError</code>             \u2013            <p>If the package is not installed.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def check_python_package_installed(package: str):\n    \"\"\"Check if a Python package is installed.\n\n    Parameters\n    ----------\n    package : str\n        Name of the Python package to check.\n\n    Raises\n    ------\n    ImportError\n        If the package is not installed.\n    \"\"\"\n    try:\n        __import__(package)\n    except ImportError:\n        raise ImportError(\n            f\"Package '{package}' is required but not installed. \"\n            f\"Please install it using pip: pip install {package}\"\n        )\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.check_python_package_installed(package)","title":"<code>package</code>","text":"(<code>str</code>)           \u2013            <p>Name of the Python package to check.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.validate_method","title":"validate_method","text":"<pre><code>validate_method(method: str)\n</code></pre> <p>Validate that the similarity method is supported.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the method is not supported.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def validate_method(method: str):\n    \"\"\"Validate that the similarity method is supported.\n\n    Parameters\n    ----------\n    method : str\n        Name of the similarity method to validate.\n\n    Raises\n    ------\n    ValueError\n        If the method is not supported.\n    \"\"\"\n    if method not in VALID_METHODS:\n        raise ValueError(\n            f\"Invalid method '{method}'. Valid methods are: {', '.join(VALID_METHODS)}\"\n        )\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.validate_method(method)","title":"<code>method</code>","text":"(<code>str</code>)           \u2013            <p>Name of the similarity method to validate.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.validate_transformation","title":"validate_transformation","text":"<pre><code>validate_transformation(transformation: str)\n</code></pre> <p>Validate that the transformation is supported.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the transformation is not supported.</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def validate_transformation(transformation: str):\n    \"\"\"Validate that the transformation is supported.\n\n    Parameters\n    ----------\n    transformation : str\n        Name of the transformation to validate.\n\n    Raises\n    ------\n    ValueError\n        If the transformation is not supported.\n    \"\"\"\n    if transformation not in VALID_TRANSFORMATIONS:\n        raise ValueError(\n            f\"Invalid transformation '{transformation}'. Valid transformations are: {', '.join(VALID_TRANSFORMATIONS)}\"\n        )\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.validate_transformation(transformation)","title":"<code>transformation</code>","text":"(<code>str</code>)           \u2013            <p>Name of the transformation to validate.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarity","title":"get_similarity","text":"<pre><code>get_similarity(\n    melody_1, melody_2, method: str, transformation: str\n) -&gt; float\n</code></pre> <p>Calculate similarity between two Score objects using the specified method.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Similarity value between the two melodies</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from amads.core.basics import Score\n&gt;&gt;&gt; # Create two simple melodies using from_melody\n&gt;&gt;&gt; melody_1 = Score.from_melody(pitches=[60, 62, 64, 65], durations=1.0)\n&gt;&gt;&gt; melody_2 = Score.from_melody(pitches=[60, 62, 64, 67], durations=1.0)\n&gt;&gt;&gt; # Calculate similarity using Jaccard method\n&gt;&gt;&gt; similarity = get_similarity(melody_1, melody_2, 'Jaccard', 'pitch')\n</code></pre> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def get_similarity(\n    melody_1, melody_2, method: str, transformation: str\n) -&gt; float:\n    \"\"\"Calculate similarity between two Score objects using the specified method.\n\n    Parameters\n    ----------\n    melody_1 : Score\n        First Score object containing a monophonic melody\n    melody_2 : Score\n        Second Score object containing a monophonic melody\n    method : str\n        Name of the similarity method to use from the list in the module docstring.\n    transformation : str\n        Name of the transformation to use from the list in the module docstring.\n\n    Returns\n    -------\n    float\n        Similarity value between the two melodies\n\n    Examples\n    --------\n    &gt;&gt;&gt; from amads.core.basics import Score\n    &gt;&gt;&gt; # Create two simple melodies using from_melody\n    &gt;&gt;&gt; melody_1 = Score.from_melody(pitches=[60, 62, 64, 65], durations=1.0)\n    &gt;&gt;&gt; melody_2 = Score.from_melody(pitches=[60, 62, 64, 67], durations=1.0)\n    &gt;&gt;&gt; # Calculate similarity using Jaccard method\n    &gt;&gt;&gt; similarity = get_similarity(melody_1, melody_2, 'Jaccard', 'pitch')\n    \"\"\"\n    # Validate inputs\n    validate_method(method)\n    validate_transformation(transformation)\n\n    # Convert Score objects to arrays\n    pitches1, starts1, ends1 = score_to_arrays(melody_1)\n    pitches2, starts2, ends2 = score_to_arrays(melody_2)\n\n    # Pass lists directly to _get_similarity\n    return _get_similarity(\n        pitches1,\n        starts1,\n        ends1,\n        pitches2,\n        starts2,\n        ends2,\n        method,\n        transformation,\n    )\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarity(melody_1)","title":"<code>melody_1</code>","text":"(<code>Score</code>)           \u2013            <p>First Score object containing a monophonic melody</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarity(melody_2)","title":"<code>melody_2</code>","text":"(<code>Score</code>)           \u2013            <p>Second Score object containing a monophonic melody</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarity(method)","title":"<code>method</code>","text":"(<code>str</code>)           \u2013            <p>Name of the similarity method to use from the list in the module docstring.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarity(transformation)","title":"<code>transformation</code>","text":"(<code>str</code>)           \u2013            <p>Name of the transformation to use from the list in the module docstring.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.score_to_arrays","title":"score_to_arrays","text":"<pre><code>score_to_arrays(score) -&gt; tuple[list[float], list[float], list[float]]\n</code></pre> <p>Extract melody attributes from a Score object.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[int], list[float], list[float]]</code>           \u2013            <p>Tuple of (pitches, start_times, end_times)</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def score_to_arrays(score) -&gt; Tuple[List[float], List[float], List[float]]:\n    \"\"\"Extract melody attributes from a Score object.\n\n    Parameters\n    ----------\n    score : Score\n        Score object containing a monophonic melody\n\n    Returns\n    -------\n    Tuple[List[int], List[float], List[float]]\n        Tuple of (pitches, start_times, end_times)\n    \"\"\"\n    assert score.ismonophonic(), \"Score must be monophonic\"\n\n    notes = score.get_sorted_notes()\n\n    # Extract onset, pitch, duration for each note\n    pitches = [note.pitch.key_num for note in notes]\n    starts = [note.onset for note in notes]\n    ends = [note.onset + note.duration for note in notes]\n\n    return pitches, starts, ends\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.score_to_arrays(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>Score object containing a monophonic melody</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities","title":"get_similarities","text":"<pre><code>get_similarities(\n    scores: dict[str, object],\n    method: str | list[str] = \"Jaccard\",\n    transformation: str | list[str] = \"pitch\",\n    output_file: str | Path | None = None,\n    n_cores: int | None = None,\n    batch_size: int = 1000,\n) -&gt; (\n    dict[str, dict[str, float]]\n    | dict[tuple[str, str], dict[str, dict[str, float]]]\n)\n</code></pre> <p>Calculate pairwise similarities between multiple Score objects.</p> <p>You can provide a single method and transformation, or a list of methods and transformations. The function will return similarity matrices as nested dictionaries.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>dict[str, dict[str, float]] | dict[tuple[str, str], dict[str, dict[str, float]]]</code>           \u2013            <p>If single method and transformation: nested dictionary similarity matrix {row_name: {col_name: similarity}} where row_name and col_name are score names. If multiple methods/transformations: dictionary mapping (method, transformation) tuples to similarity matrices</p> </li> </ul> Source code in <code>amads/melody/similarity/melsim.py</code> <pre><code>def get_similarities(\n    scores: Dict[str, object],\n    method: Union[str, List[str]] = \"Jaccard\",\n    transformation: Union[str, List[str]] = \"pitch\",\n    output_file: Union[str, Path, None] = None,\n    n_cores: Optional[int] = None,\n    batch_size: int = 1000,\n) -&gt; Union[\n    Dict[str, Dict[str, float]],\n    Dict[Tuple[str, str], Dict[str, Dict[str, float]]],\n]:\n    \"\"\"Calculate pairwise similarities between multiple Score objects.\n\n    You can provide a single method and transformation, or a list of methods and transformations.\n    The function will return similarity matrices as nested dictionaries.\n\n    Parameters\n    ----------\n    scores : Dict[str, Score]\n        Dictionary mapping score names to Score objects\n    method : Union[str, List[str]], default=\"Jaccard\"\n        Name of the similarity method(s) to use. Can be a single method or a list of methods.\n    transformation : Union[str, List[str]], default=\"pitch\"\n        Name of the transformation(s) to use. Can be a single transformation or a list of transformations.\n    output_file : Union[str, Path], optional\n        If provided, save results to this file. If no extension is provided, .json will be added.\n    n_cores : int, optional\n        Number of CPU cores to use for parallel processing. Defaults to all available cores.\n    batch_size : int, default=1000\n        Number of comparisons to process in each batch\n\n    Returns\n    -------\n    Union[Dict[str, Dict[str, float]], Dict[Tuple[str, str], Dict[str, Dict[str, float]]]]\n        If single method and transformation: nested dictionary similarity\n        matrix {row_name: {col_name: similarity}} where row_name and col_name\n        are score names. If multiple methods/transformations: dictionary mapping\n        (method, transformation) tuples to similarity matrices\n    \"\"\"\n    # Convert single method/transformation to lists\n    methods = [method] if isinstance(method, str) else method\n    transformations = (\n        [transformation] if isinstance(transformation, str) else transformation\n    )\n\n    # Validate all methods and transformations\n    for m in methods:\n        validate_method(m)\n    for t in transformations:\n        validate_transformation(t)\n\n    if len(scores) &lt; 2:\n        raise ValueError(\"Need at least 2 Score objects for comparison\")\n\n    # Extract melody data from all scores (avoid multiprocessing due to Score object pickling issues)\n    print(\"Extracting melody data...\")\n    melody_data = {}\n    for name, score in tqdm(scores.items(), desc=\"Processing Score objects\"):\n        try:\n            melody_data[name] = score_to_arrays(score)\n        except Exception as e:\n            print(\n                f\"Warning: Could not extract melody data for {name}: {str(e)}\"\n            )\n\n    if len(melody_data) &lt; 2:\n        raise ValueError(\"Need at least 2 valid Score objects for comparison\")\n\n    # Prepare arguments for parallel processing\n    print(\"Computing similarities...\")\n    args = []\n    score_pairs = []\n\n    # Pre-compute all combinations for better performance\n    combinations_list = list(combinations(melody_data.items(), 2))\n    for (name1, data1), (name2, data2) in combinations_list:\n        for m in methods:\n            for t in transformations:\n                args.append((data1, data2, m, t))\n                score_pairs.append((name1, name2, m, t))\n\n    # Process in larger batches for better performance\n    similarities_list = []\n    for i in tqdm(range(0, len(args), batch_size), desc=\"Processing batches\"):\n        batch = args[i : i + batch_size]\n        similarities_list.extend(_batch_compute_similarities(batch))\n\n    # Create dictionary of results\n    similarities = dict(zip(score_pairs, similarities_list))\n\n    # Convert to matrix format using native Python types\n    score_names = list(scores.keys())\n\n    # Create similarity matrices as nested dictionaries\n    matrices = {}\n\n    for m in methods:\n        for t in transformations:\n            # Initialize matrix as nested dictionary with 1s on diagonal\n            sim_matrix = {}\n            for name1 in score_names:\n                sim_matrix[name1] = {}\n                for name2 in score_names:\n                    if name1 == name2:\n                        sim_matrix[name1][name2] = 1.0\n                    else:\n                        sim_matrix[name1][name2] = 0.0\n\n            # Fill matrix with pairwise similarities\n            # Since combinations() only gives us each pair once, set both directions\n            for (\n                name1,\n                name2,\n                method_key,\n                transformation_key,\n            ), similarity in similarities.items():\n                if method_key == m and transformation_key == t:\n                    # Handle NaN values consistently\n                    if (\n                        similarity == \"NA\"\n                        or similarity is None\n                        or (\n                            isinstance(similarity, float)\n                            and math.isnan(similarity)\n                        )\n                    ):\n                        sim_value = float(\"nan\")\n                    else:\n                        sim_value = float(similarity)\n\n                    # Set both directions to ensure perfect symmetry\n                    sim_matrix[name1][name2] = sim_value\n                    sim_matrix[name2][name1] = sim_value\n\n            matrices[(m, t)] = sim_matrix\n\n    # Save to file if output file specified\n    if output_file:\n        print(\"Saving results...\")\n\n        # Ensure output file has .json extension\n        output_file = Path(output_file)\n        if not output_file.suffix:\n            output_file = output_file.with_suffix(\".json\")\n\n        # Save matrices to JSON\n        output_data = {}\n        for (m, t), matrix in matrices.items():\n            output_data[f\"{m}_{t}\"] = matrix\n\n        import json\n\n        with open(output_file, \"w\") as f:\n            json.dump(output_data, f, indent=2)\n        print(f\"Results saved to {output_file}\")\n\n    # Return format depends on number of method/transformation combinations\n    if len(methods) == 1 and len(transformations) == 1:\n        # Single method and transformation: return just the matrix\n        return matrices[(methods[0], transformations[0])]\n    else:\n        # Multiple methods/transformations: return dictionary of matrices\n        return matrices\n</code></pre>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities(scores)","title":"<code>scores</code>","text":"(<code>dict[str, Score]</code>)           \u2013            <p>Dictionary mapping score names to Score objects</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities(method)","title":"<code>method</code>","text":"(<code>str | list[str]</code>, default:                   <code>\"Jaccard\"</code> )           \u2013            <p>Name of the similarity method(s) to use. Can be a single method or a list of methods.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities(transformation)","title":"<code>transformation</code>","text":"(<code>str | list[str]</code>, default:                   <code>\"pitch\"</code> )           \u2013            <p>Name of the transformation(s) to use. Can be a single transformation or a list of transformations.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities(output_file)","title":"<code>output_file</code>","text":"(<code>str | Path</code>, default:                   <code>None</code> )           \u2013            <p>If provided, save results to this file. If no extension is provided, .json will be added.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities(n_cores)","title":"<code>n_cores</code>","text":"(<code>int</code>, default:                   <code>None</code> )           \u2013            <p>Number of CPU cores to use for parallel processing. Defaults to all available cores.</p>"},{"location":"reference/melody/similarity/#amads.melody.similarity.melsim.get_similarities(batch_size)","title":"<code>batch_size</code>","text":"(<code>int</code>, default:                   <code>1000</code> )           \u2013            <p>Number of comparisons to process in each batch</p>"},{"location":"reference/pitch/hz2midi/","title":"Hz2midi","text":""},{"location":"reference/pitch/hz2midi/#amads.pitch.hz2midi.hz2midi","title":"hz2midi","text":"<pre><code>hz2midi(hertz)\n</code></pre> <p>Convert a frequency in Hertz to the corresponding MIDI note number.</p> <p>Validates input to ensure all frequencies are non-negative.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union[float, list[float]]</code>           \u2013            <p>The corresponding MIDI note number or list of numbers (A4 = 440Hz = 69).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If any frequency is negative.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hz2midi(440.0)\n69.0\n&gt;&gt;&gt; hz2midi([440.0, 880.0])\n[69.0, 81.0]\n</code></pre> Source code in <code>amads/pitch/hz2midi.py</code> <pre><code>def hz2midi(hertz):\n    \"\"\"\n    Convert a frequency in Hertz to the corresponding MIDI note number.\n\n    Validates input to ensure all frequencies are non-negative.\n\n    Parameters\n    ----------\n    hertz : Union[float, list[float]]\n        The frequency or list of frequencies in Hertz.\n\n    Returns\n    -------\n    Union[float, list[float]]\n        The corresponding MIDI note number or list of numbers (A4 = 440Hz = 69).\n\n    Raises\n    ------\n    ValueError\n        If any frequency is negative.\n\n    Examples\n    --------\n    &gt;&gt;&gt; hz2midi(440.0)\n    69.0\n    &gt;&gt;&gt; hz2midi([440.0, 880.0])\n    [69.0, 81.0]\n    \"\"\"\n\n    def validate_hz(hz):\n        if hz &lt; 0:\n            raise ValueError(\n                f\"The frequency of a sound must be non-negative, got {hz}\"\n            )\n\n    if isinstance(hertz, list):\n        for hz in hertz:\n            validate_hz(hz)\n        return [69 + 12 * math.log2(hz / 440.0) for hz in hertz]\n    else:\n        validate_hz(hertz)\n        return 69 + 12 * math.log2(hertz / 440.0)\n</code></pre>"},{"location":"reference/pitch/hz2midi/#amads.pitch.hz2midi.hz2midi(hertz)","title":"<code>hertz</code>","text":"(<code>Union[float, list[float]]</code>)           \u2013            <p>The frequency or list of frequencies in Hertz.</p>"},{"location":"reference/pitch/intervals/","title":"Interval Distributions","text":""},{"location":"reference/pitch/intervals/#amads.pitch.ivdirdist1.interval_direction_distribution_1","title":"interval_direction_distribution_1","text":"<pre><code>interval_direction_distribution_1(\n    score: Score,\n    name: str = \"Interval Direction Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution\n</code></pre> <p>Returns the proportion of upward intervals for each interval size</p> <p>Currently, intervals greater than an octave will be ignored.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>A 12-element distribution representing the proportion of upward intervals for each interval size. The components are spaced at semitone distances with the first component representing a minor second (not unison) and the last component the octave. If the score is empty, the function returns a list with all elements set to zero.</p> </li> </ul> Source code in <code>amads/pitch/ivdirdist1.py</code> <pre><code>def interval_direction_distribution_1(\n    score: Score,\n    name: str = \"Interval Direction Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution:\n    \"\"\"\n    Returns the proportion of upward intervals for each interval size\n\n    Currently, intervals greater than an octave will be ignored.\n\n    Parameters\n    ----------\n    score : Score\n        The music Score object to analyze\n    name : str\n        A name for the resulting distribution (title in distribution plot)\n    weighted : bool, optional\n        If True, the interval distribution is weighted by note durations\n        in seconds that are modified according to Parncutt's durational\n        accent model (1994), by default True.\n    miditoolbox_compatible : bool\n        Invokes interval_distribution_1 using miditoolbox_compatible=True,\n        which performs normalization slightly differently (see\n        [interval_distribution_1]\n        [amads.pitch.ivdist1.interval_distribution_1].\n        Default is False, which simply skips division when the total\n        count is zero (this also returns a zero matrix when the count\n        is zero).\n\n    Returns\n    -------\n    Distribution\n        A 12-element distribution representing the proportion of\n        upward intervals for each interval size. The components\n        are spaced at semitone distances with the first component\n        representing a minor second (not unison) and the last\n        component the octave. If the score is empty, the function\n        returns a list with all elements set to zero.\n    \"\"\"\n\n    id = interval_distribution_1(score, name, weighted, miditoolbox_compatible)\n    id = id.data  # we only need the data from the distribution\n    idd = [0.0] * 12\n\n    for i in range(12):\n        # id[i + 13] is the upward interval\n        # id[11 - i] is the downward interval\n        if (id[i + 13] + id[11 - i]) != 0:\n            idd[i] = id[i + 13] / (id[i + 13] + id[11 - i])\n        else:\n            idd[i] = 0\n\n    x_categories = [str(i) for i in range(1, 13)]\n    return Distribution(\n        name,\n        idd,\n        \"interval_direction\",\n        [12],\n        x_categories,  # type: ignore\n        \"Interval Size\",\n        None,\n        \"Proportion\",\n    )\n</code></pre>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdirdist1.interval_direction_distribution_1(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The music Score object to analyze</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdirdist1.interval_direction_distribution_1(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Interval Direction Distribution'</code> )           \u2013            <p>A name for the resulting distribution (title in distribution plot)</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdirdist1.interval_direction_distribution_1(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the interval distribution is weighted by note durations in seconds that are modified according to Parncutt's durational accent model (1994), by default True.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdirdist1.interval_direction_distribution_1(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Invokes interval_distribution_1 using miditoolbox_compatible=True, which performs normalization slightly differently (see interval_distribution_1. Default is False, which simply skips division when the total count is zero (this also returns a zero matrix when the count is zero).</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist1.interval_distribution_1","title":"interval_distribution_1","text":"<pre><code>interval_distribution_1(\n    score: Score,\n    name: str = \"Interval Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution\n</code></pre> <p>Returns the interval distribution of a musical score.</p> <p>Currently, intervals greater than an octave will be ignored.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>A 25-bin distribution representing the probabilities of each pitch interval. The bins are spaced at semitone distances with the first bin representing the downward octave and the last bin representing the upward octave. If the score is empty, the function returns a list with all elements set to zero.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the score is not monophonic (e.g. contains chords)</p> </li> </ul> Source code in <code>amads/pitch/ivdist1.py</code> <pre><code>def interval_distribution_1(\n    score: Score,\n    name: str = \"Interval Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution:\n    \"\"\"\n    Returns the interval distribution of a musical score.\n\n    Currently, intervals greater than an octave will be ignored.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze\n    name : str\n        A name for the distribution and plot title.\n    weighted : bool, optional\n        If True, the interval distribution is weighted by note durations\n        in seconds that are modified according to Parncutt's durational\n        accent model (1994), by default True.\n    miditoolbox_compatible : bool\n        Matlab MIDI Toolbox avoids zero division by dividing counts\n        by the total count plus (1e-12 times the number of bins).\n        True enables this behavior. Default is False, which simply skips\n        division when the total count is zero (this also returns a\n        zero matrix when the count is zero).\n\n    Returns\n    -------\n    Distribution\n        A 25-bin distribution representing the probabilities of each pitch\n        interval. The bins are spaced at semitone distances with the first\n        bin representing the downward octave and the last bin representing\n        the upward octave. If the score is empty, the function returns a\n        list with all elements set to zero.\n\n    Raises\n    ------\n    ValueError\n        If the score is not monophonic (e.g. contains chords)\n    \"\"\"\n    if not score.ismonophonic():\n        raise ValueError(\"Error: Score must be monophonic\")\n\n    score = cast(Score, score.merge_tied_notes())\n    if weighted:\n        score.convert_to_seconds()\n\n    bin_centers = [float(i - 12) for i in range(25)]  # 25 bins from -12 to +12\n    bin_boundaries = [i - 12 - 0.5 for i in range(26)]  # boundaries\n    x_categories = [str(c) for c in bin_centers]\n    h = Histogram1D(bin_centers, bin_boundaries, \"linear\", True)\n\n    for p in score.find_all(Part):\n        part: Part = cast(Part, p)\n        prev_pitch = None\n        prev_dur = None\n        for n in part.find_all(Note):\n            note: Note = cast(Note, n)\n            if prev_pitch is not None:\n                iv = round(note.key_num - prev_pitch)\n                if miditoolbox_compatible:\n                    iv = (abs(iv) % 12) * ((iv &gt; 0) - (iv &lt; 0))\n                # otherwise, diff may be ignored by h.add_point\n                if weighted:\n                    dur = duraccent(note)\n                    # prev_dur cannot be None here since prev_pitch is not None\n                    h.add_point(iv, prev_dur + dur)  # type: ignore\n                    prev_dur = dur\n                else:\n                    h.add_point(iv, 1.0)\n            prev_pitch = note.key_num\n            if weighted and prev_dur is None:\n                prev_dur = duraccent(note)\n\n    if miditoolbox_compatible:  # miditoolbox \"normalization\"\n        total = sum(h.bins) + len(h.bins) * 1e-12\n        h.bins = [b / total for b in h.bins]\n    else:  # normalize normally\n        h.normalize()\n\n    return Distribution(\n        name,\n        h.bins,\n        \"interval\",\n        [len(h.bins)],\n        x_categories,  # type: ignore\n        \"Interval (semitones)\",\n        None,\n        \"Proportion\",\n    )\n</code></pre>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist1.interval_distribution_1(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist1.interval_distribution_1(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Interval Distribution'</code> )           \u2013            <p>A name for the distribution and plot title.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist1.interval_distribution_1(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the interval distribution is weighted by note durations in seconds that are modified according to Parncutt's durational accent model (1994), by default True.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist1.interval_distribution_1(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Matlab MIDI Toolbox avoids zero division by dividing counts by the total count plus (1e-12 times the number of bins). True enables this behavior. Default is False, which simply skips division when the total count is zero (this also returns a zero matrix when the count is zero).</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist2.interval_distribution_2","title":"interval_distribution_2","text":"<pre><code>interval_distribution_2(\n    score: Score,\n    name: str = \"Interval Transition Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution\n</code></pre> <p>Returns the 2nd-order interval distribution of a musical score.</p> <p>Currently, intervals greater than an octave will be ignored.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>A 25x25 distribution where where (i,j) represents the normalized probabilities of transitioning from interval i to interval j. The bins are spaced at semitone distances with the first bin representing the downward octave and the last bin representing the upward octave. If the score is empty, the function returns a list with all elements set to zero.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the score is not monophonic (e.g. contains chords)</p> </li> </ul> Source code in <code>amads/pitch/ivdist2.py</code> <pre><code>def interval_distribution_2(\n    score: Score,\n    name: str = \"Interval Transition Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution:\n    \"\"\"\n    Returns the 2nd-order interval distribution of a musical score.\n\n    Currently, intervals greater than an octave will be ignored.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze\n    name : str\n        A name for the distribution and plot title.\n    weighted : bool, optional\n        If True, the interval distribution is weighted by note durations\n        in seconds that are modified according to Parncutt's durational\n        accent model (1994), by default True.\n    miditoolbox_compatible : bool\n        miditoolbox_compatible introduces four changes to emulate `ivdist2`\n        in Midi Toolbox: (1) avoid zero division by dividing counts\n        by (total count plus (1e-12 time the number of bins), as\n        opposed to simply skipping division when all bins are zero,\n        (2) assume octave (but not direction) equivalence, so the\n        intervals +1 and +13 update the same bin (as opposed to ignoring\n        intervals larger than an octave), (3) a zero interval (unison) is\n        inserted at the beginning of the sequence, (4) the weight is the\n        sum of the modified durations of the second interval (as opposed to\n        taking the sum of the modified durations of all three notes).\n\n    Returns\n    -------\n    Distribution\n        A 25x25 distribution where where (i,j) represents the normalized\n        probabilities of transitioning from interval i to interval j.\n        The bins are spaced at semitone distances with the first bin\n        representing the downward octave and the last bin representing\n        the upward octave. If the score is empty, the function returns\n        a list with all elements set to zero.\n\n    Raises\n    ------\n    ValueError\n        If the score is not monophonic (e.g. contains chords)\n    \"\"\"\n    if not score.ismonophonic():\n        raise ValueError(\"Error: Score must be monophonic\")\n\n    score = cast(Score, score.merge_tied_notes())\n    if weighted:\n        score.convert_to_seconds()  # need seconds for duraccent function\n\n    bin_centers = [float(i - 12) for i in range(25)]  # 25 bins from -12 to +12\n    bin_boundaries = [i - 12 - 0.5 for i in range(26)]  # boundaries\n    x_categories = [str(c) for c in bin_centers]\n    y_categories = x_categories\n    h = Histogram2D(bin_centers, bin_boundaries, \"linear\", True)\n    for p in score.find_all(Part):\n        part: Part = cast(Part, p)\n        dur = 0.0  # (this value is never used)\n        prev_iv = 0 if miditoolbox_compatible else None  # previous interval\n        prev_pitch = None\n        prev_dur = 0\n        prev_prev_dur = 0\n        prev_bin = None\n        for n in part.find_all(Note):\n            note: Note = cast(Note, n)\n            if weighted:\n                dur = duraccent(note)\n            if prev_pitch is not None:\n                iv = round(note.key_num - prev_pitch)\n                if miditoolbox_compatible:\n                    iv = (abs(iv) % 12) * ((iv &gt; 0) - (iv &lt; 0))\n                if weighted:\n                    dur = duraccent(note)\n                    w = prev_dur + dur\n                    if not miditoolbox_compatible:\n                        w += prev_prev_dur\n                    prev_bin = h.add_point_2d(prev_iv, iv, w, prev_bin)\n                    prev_prev_dur = prev_dur\n                else:\n                    prev_bin = h.add_point_2d(prev_iv, iv, 1.0, prev_bin)\n                prev_iv = None if prev_bin is None else iv\n            prev_pitch = note.key_num\n            prev_dur = dur\n    if miditoolbox_compatible:\n        total = sum(sum(bin) for bin in h.bins) + (\n            len(h.bins) * len(h.bins) * 1e-12\n        )\n        h.bins = [[c / total for c in row] for row in h.bins]\n    else:  # normalize normally\n        h.normalize()\n\n    return Distribution(\n        name,\n        h.bins,\n        \"interval_transition\",\n        [25, 25],\n        x_categories,  # type: ignore\n        \"Interval (from)\",\n        y_categories,  # type: ignore\n        \"Interval (to)\",\n    )\n</code></pre>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist2.interval_distribution_2(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist2.interval_distribution_2(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Interval Transition Distribution'</code> )           \u2013            <p>A name for the distribution and plot title.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist2.interval_distribution_2(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the interval distribution is weighted by note durations in seconds that are modified according to Parncutt's durational accent model (1994), by default True.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivdist2.interval_distribution_2(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>miditoolbox_compatible introduces four changes to emulate <code>ivdist2</code> in Midi Toolbox: (1) avoid zero division by dividing counts by (total count plus (1e-12 time the number of bins), as opposed to simply skipping division when all bins are zero, (2) assume octave (but not direction) equivalence, so the intervals +1 and +13 update the same bin (as opposed to ignoring intervals larger than an octave), (3) a zero interval (unison) is inserted at the beginning of the sequence, (4) the weight is the sum of the modified durations of the second interval (as opposed to taking the sum of the modified durations of all three notes).</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivsizedist1.interval_size_distribution_1","title":"interval_size_distribution_1","text":"<pre><code>interval_size_distribution_1(\n    score: Score,\n    name: str = \"Interval Size Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution\n</code></pre> <p>Returns the interval size distribution of a musical score.</p> <p>Intervals greater than one octave are ignored.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>A 13-element distribution representing proportions of interval sizes. The first element corresponds to unison intervals, and the last element corresponds to octave intervals. If the score is empty, the function returns a Distribution with all elements set to zero.</p> </li> </ul> Source code in <code>amads/pitch/ivsizedist1.py</code> <pre><code>def interval_size_distribution_1(\n    score: Score,\n    name: str = \"Interval Size Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = True,\n) -&gt; Distribution:\n    \"\"\"\n    Returns the interval size distribution of a musical score.\n\n    Intervals greater than one octave are ignored.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze\n    name : str\n        A name for the distribution and plot title.\n    weighted : bool, optional\n        If True, the interval distribution is weighted by note durations\n        in seconds that are modified according to Parncutt's durational\n        accent model (1994), by default True.\n    miditoolbox_compatible : bool\n        Invokes interval_distribution_1 using miditoolbox_compatible=True,\n        which performs normalization slightly differently (see\n        [interval_distribution_1]\n        [amads.pitch.ivdist1.interval_distribution_1].\n        Default is False, which simply skips division when the total\n        count is zero (this also returns a zero matrix when the count\n        is zero).\n\n    Returns\n    -------\n    Distribution\n        A 13-element distribution representing proportions of interval sizes.\n        The first element corresponds to unison intervals, and the last\n        element corresponds to octave intervals. If the score is empty,\n        the function returns a Distribution with all elements set to zero.\n    \"\"\"\n    id = interval_distribution_1(score, name, weighted, miditoolbox_compatible)\n    id = id.data  # we only need the data from the distribution\n    isd = [0.0] * 13\n\n    isd[0] = id[12]\n    for i in range(1, 13):\n        isd[i] = id[i + 12] + id[12 - i]  # merge upward and downward bins\n    # note that isd is normalized because it sums to the same value as isd\n    x_categories = [str(i) for i in range(13)]\n    return Distribution(\n        name,\n        isd,\n        \"interval_size\",\n        [12],\n        x_categories,  # type: ignore\n        \"Interval Size\",\n        None,\n        \"Proportion\",\n    )\n</code></pre>"},{"location":"reference/pitch/intervals/#amads.pitch.ivsizedist1.interval_size_distribution_1(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivsizedist1.interval_size_distribution_1(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Interval Size Distribution'</code> )           \u2013            <p>A name for the distribution and plot title.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivsizedist1.interval_size_distribution_1(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, the interval distribution is weighted by note durations in seconds that are modified according to Parncutt's durational accent model (1994), by default True.</p>"},{"location":"reference/pitch/intervals/#amads.pitch.ivsizedist1.interval_size_distribution_1(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Invokes interval_distribution_1 using miditoolbox_compatible=True, which performs normalization slightly differently (see interval_distribution_1. Default is False, which simply skips division when the total count is zero (this also returns a zero matrix when the count is zero).</p>"},{"location":"reference/pitch/ismonophonic/","title":"ismonophonic","text":""},{"location":"reference/pitch/ismonophonic/#amads.pitch.ismonophonic.ismonophonic","title":"ismonophonic","text":"<pre><code>ismonophonic(score: Score)\n</code></pre> <p>Determine if a musical score is monophonic.</p> <p>A monophonic score has no overlapping notes (e.g., chords).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the score is monophonic, False otherwise.</p> </li> </ul> Source code in <code>amads/pitch/ismonophonic.py</code> <pre><code>def ismonophonic(score: Score):\n    \"\"\"\n    Determine if a musical score is monophonic.\n\n    A monophonic score has no overlapping notes (e.g., chords).\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze.\n\n    Returns\n    -------\n    bool\n        True if the score is monophonic, False otherwise.\n    \"\"\"\n    return _ismonophonic(score.find_all(Note))\n</code></pre>"},{"location":"reference/pitch/ismonophonic/#amads.pitch.ismonophonic.ismonophonic(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/pitch/key/","title":"Key Profiles","text":""},{"location":"reference/pitch/key/#amads.pitch.key.profiles","title":"profiles","text":"<p>Pitch class usage profiles (PCP) from the literature.</p> <p>In almost all cases reported here, keys are assumed to be transpositionally equivalent, so the first (0th) entry is the tonic, and no key-specific information is given.  The exception is QuinnWhite which provides key-specific data.  In the key-specific case, we instead store the distributions as a tuple of tuples of distributions representing each individual key profile.</p> <p>The profiles here provide the values exactly as reported in the literature.  Where a profile does not sum to 1, an additional \"_sum\" entry is provided with that normalisation.</p> <p>The profiles appear below in approximately chronological order. For reference, the alphabetical ordering is:</p> <ul> <li>AardenEssen</li> <li>AlbrechtShanahan</li> <li>BellmanBudge</li> <li>deClerqTemperley</li> <li>KrumhanslKessler</li> <li>KrumhanslSchmuckler</li> <li>PrinceSchumuckler</li> <li>QuinnWhite</li> <li>SappSimple</li> <li>TemperleyKostkaPayne</li> <li>TemperleyDeClerq</li> <li>Vuvan</li> <li>VuvanHughes</li> </ul> <p>The variable <code>source_list</code> contains a list of all of these profiles.</p> <p>Each profile is a dataclass object with the following attributes:</p> <ul> <li><code>name</code> (str) - the class name</li> <li><code>about</code> (str) - a short description</li> <li><code>literature</code> (str) - reference to the relevant publication</li> <li><code>major</code> (tuple[float]) - original weights for 12 pitch classes, major keys    (in KrumhanslKessler, KrumhanslSchmuckler, AardenEssen, BellmanBudge,     TemperleyKostkaPayne, Sapp, AlbrechtShanahan only)</li> <li><code>major_sum</code>  (tuple[float]) - weights that sum to 1, major keys    (in KrumhanslKessler, KrumhanslSchmuckler, AardenEssen, BellmanBudge,     TemperleyKostkaPayne, Sapp only)</li> <li><code>minor</code> (tuple[float]) - original weights for 12 pitch classes, minor keys    (in KrumhanslKessler, KrumhanslSchmuckler, AardenEssen, BellmanBudge,     TemperleyKostkaPayne, Sapp, AlbrechtShanahan only)</li> <li><code>minor_sum</code>  (tuple[float]) - weights that sum to 1, minor keys    (in KrumhanslKessler, KrumhanslSchmuckler, AardenEssen, BellmanBudge,     TemperleyKostkaPayne, Sapp only)</li> <li><code>natural_minor</code> (tuple[float]) - original weights, natural minor keys    (in <code>Vuvan</code> only)</li> <li><code>natural_minor_sum</code> (tuple[float]) - weights that sum to 1, natural minor keys    (in <code>Vuvan</code> only)</li> <li><code>harmonic_minor</code> (tuple[float]) - original weights, harmonic minor keys    (in <code>Vuvan</code> only)</li> <li><code>harmonic_minor_sum</code> (tuple[float]) - weights that sum to 1, harmonic minor keys    (in <code>Vuvan</code> only)</li> <li><code>melodic_minor</code> (tuple[float]) - original weights, melodic minor keys    (in <code>Vuvan</code> only)</li> <li><code>melodic_minor_sum</code> (tuple[float]) - weights that sum to 1, melodic minor keys    (in <code>Vuvan</code> only)</li> <li><code>roots</code> (tuple[float]) - original weights that sum to 1, chord roots in rock    harmony (in DeClerqTemperley only)</li> <li><code>melody_major</code> (tuple[float]) - original weights that sum to 1, major melodies    (in <code>TemperleyDeClerq</code> only)</li> <li><code>melody_minor</code> (tuple[float]) - original weights that sum to 1, minor melodies    (in <code>TemperleyDeClerq</code> only)</li> <li><code>harmony_major</code> (tuple[float]) - original weights that sum to 1, major melodies    (in <code>TemperleyDeClerq</code> only)</li> <li><code>harmony_minor</code> (tuple[float]) - original weights that sum to 1, minor melodies    (in <code>TemperleyDeClerq</code> only)</li> <li><code>downbeat_major</code> (tuple[float]) - original weights,    major on downbeats (in <code>PrinceSchumuckler</code> only)</li> <li><code>downbeat_major_sum</code> (tuple[float]) - original weights that sum to 1,    major on downbeats (in <code>PrinceSchumuckler</code> only)</li> <li><code>downbeat_minor</code> (tuple[float]) - original weights,    minor on downbeats (in <code>PrinceSchumuckler</code> only)</li> <li><code>downbeat_minor_sum</code> (tuple[float]) - original weights that sum to 1,    minor on downbeats (in <code>PrinceSchumuckler</code> only)</li> <li><code>all_beats_major</code> (tuple[float]) - original weights,    major on all beats (in <code>PrinceSchumuckler</code> only)</li> <li><code>all_beats_major_sum</code> (tuple[float]) - original weights that sum to 1,    major on all beats (in <code>PrinceSchumuckler</code> only)</li> <li><code>all_beats_minor</code> (tuple[float]) - original weights,    minor on all_beats (in <code>PrinceSchumuckler</code> only)</li> <li><code>all_beats_minor_sum</code> (tuple[float]) - original weights that sum to 1,    minor on all_beats (in <code>PrinceSchumuckler</code> only)</li> <li><code>major_all</code> (tuple[float]) - original weights that sum to 1, all keys    (in QuinnWhite only)</li> <li><code>major_0</code> (tuple[float]) - original weights that sum to 1, C Major    (in QuinnWhite only)</li> <li><code>major_1</code> (tuple[float]) - original weights that sum to 1, C#/Db Major    (in QuinnWhite only)</li> <li><code>major_2</code> (tuple[float]) - original weights that sum to 1, D Major    (in QuinnWhite only)</li> <li><code>major_3</code> (tuple[float]) - original weights that sum to 1, D#/Eb Major    (in QuinnWhite only)</li> <li><code>major_4</code> (tuple[float]) - original weights that sum to 1, E Major    (in QuinnWhite only)</li> <li><code>major_5</code> (tuple[float]) - original weights that sum to 1, F Major    (in QuinnWhite only)</li> <li><code>major_6</code> (tuple[float]) - original weights that sum to 1, F#/Gb Major    (in QuinnWhite only)</li> <li><code>major_7</code> (tuple[float]) - original weights that sum to 1, G Major    (in QuinnWhite only)</li> <li><code>major_8</code> (tuple[float]) - original weights that sum to 1, G#/Ab Major    (in QuinnWhite only)</li> <li><code>major_9</code> (tuple[float]) - original weights that sum to 1, A Major,    (in QuinnWhite only)</li> <li><code>major_10</code> (tuple[float]) - original weights that sum to 1, A#/Bb Major    (in QuinnWhite only)</li> <li><code>major_11</code> (tuple[float]) - original weights that sum to 1, B Major    (in QuinnWhite only)</li> <li><code>minor_all</code> (tuple[float]) - original weights that sum to 1, all keys    (in QuinnWhite only)</li> <li><code>minor_0</code> (tuple[float]) - original weights that sum to 1, C Minor    (in QuinnWhite only)</li> <li><code>minor_1</code> (tuple[float]) - original weights that sum to 1, C#/Db Minor    (in QuinnWhite only)</li> <li><code>minor_2</code> (tuple[float]) - original weights that sum to 1, D Minor    (in QuinnWhite only)</li> <li><code>minor_3</code> (tuple[float]) - original weights that sum to 1, D#/Eb Minor    (in QuinnWhite only)</li> <li><code>minor_4</code> (tuple[float]) - original weights that sum to 1, E Minor    (in QuinnWhite only)</li> <li><code>minor_5</code> (tuple[float]) - original weights that sum to 1, F Minor    (in QuinnWhite only)</li> <li><code>minor_6</code> (tuple[float]) - original weights that sum to 1, F#/Gb Minor    (in QuinnWhite only)</li> <li><code>minor_7</code> (tuple[float]) - original weights that sum to 1, G Minor    (in QuinnWhite only)</li> <li><code>minor_8</code> (tuple[float]) - original weights that sum to 1, G#/Ab Minor    (in QuinnWhite only)</li> <li><code>minor_9</code> (tuple[float]) - original weights that sum to 1, A Minor,    (in QuinnWhite only)</li> <li><code>minor_10</code> (tuple[float]) - original weights that sum to 1, A#/Bb Minor    (in QuinnWhite only)</li> <li><code>minor_11</code> (tuple[float]) - original weights that sum to 1, B Minor    (in QuinnWhite only)</li> <li><code>classical</code> (tuple[float]) - original weights for 12 pitch classes,    all classical keys    (in VuvanHuges only)</li> <li><code>classical_sum</code>  (tuple[float]) - weights that sum to 1, all classical keys    (in VuvanHuges only)</li> <li><code>rock</code> (tuple[float]) - original weights for 12 pitch classes, all rock keys    (in VuvanHuges only)</li> <li><code>rock_sum</code>  (tuple[float]) - weights that sum to 1, all rock keys    (in VuvanHuges only)</li> </ul> <p>Author: Mark Gotham, 2021, Huw Cheston, 2025</p> REFERENCE <p>Gotham et al. \"What if the 'When' Implies the 'What'?\". ISMIR, 2021 (see README.md)</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile","title":"PitchProfile","text":"<pre><code>PitchProfile(\n    name: str,\n    profile_tuple: tuple[float, ...] | tuple[tuple[float, ...], ...],\n)\n</code></pre> <p>               Bases: <code>Distribution</code></p> <p>A set of weights for each pitch class denoting the expected frequency  of pitches for collections of notes (typically songs, can be chords)  of a given key.</p> <p>We provide methods to allow users to obtain or visualize this information  in a useful state.</p> <p>Definitions:  Define a canonical order of pitches as the order of pitches specified in  relative chromatic degree.</p> <p>In our implementation, a pitch profile is a collection of pitch class  distributions stored in a canonical form convenient for conversion  into other useful forms, whether to provide methods in a useful state  or for custom visualization.  We store the pitch profile canonically in one of two forms:</p> <ol> <li>In the transpositionally equivalent case, we store the data as a      list of 12 (float) weights beginning with the tonic.</li> <li>In the case of profiles that are not transpositionally equivalent,      there is are weights for each key which are collectively stored      as a list of 12 key profiles, each a list of 12 weights. Each      profile begins with the tonic. Therefore <code>data[2][5]</code> represents      the 5th weight (for pitch class G) in the 2nd key (D).</li> </ol> <p>For visualization, our design envisions the following use-cases:</p> <ol> <li>Compare and contrast data within a single PitchProfile object,      especially between different key profiles beginning at their      respecive tonic. Hence, our custom plot method allows a list      of keys to plot the data side by side in a heatmap.</li> <li>Compare and contrast PitchProfile data with other pitch-class      distributions, hence why we also satisfy the specifications      for both singular plot and multiple plots from its parent      class Distribution.</li> </ol> <p>Attributes:</p> <ul> <li> <code>_profile_label</code>               (<code>str, class attribute</code>)           \u2013            <p>histogram label for 1-D histogram (x-axis), or representing the key of the current profile in the 2-D heatmap (y-axis)</p> </li> <li> <code>_data_cats_2d</code>               (<code>List[int], class attribute</code>)           \u2013            <p>data categories for the 2-D heatmap, which are labelled in terms of relative chromatic degree</p> </li> <li> <code>_data_labels</code>               (<code>List[str], class attribute</code>)           \u2013            <p>possible data labels, Relative Chromatic Degree for 2-D case (x-axis), and Weights for 1-D case (y-axis)</p> </li> </ul> <p>Methods:</p> <ul> <li> <code>normalize</code>             \u2013              <p>Normalize the pitch-class distributions within the PitchProfile.</p> </li> <li> <code>key_to_weights</code>             \u2013              <p>Given a key, computes the corresponding weights for the key profile.</p> </li> <li> <code>as_canonical_matrix</code>             \u2013              <p>Computes a 12x12 matrix of the profile data.</p> </li> <li> <code>plot</code>             \u2013              <p>Virtual plot function for Distribution.</p> </li> <li> <code>show</code>             \u2013              <p>Print information about the distribution</p> </li> <li> <code>plot_multiple</code>             \u2013              <p>Plot multiple distributions into a single Figure using vertically</p> </li> <li> <code>plot_grouped_1d</code>             \u2013              <p>Overlay multiple 1-D distributions on a single axes.</p> </li> </ul> Source code in <code>amads/pitch/key/profiles.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    profile_tuple: Union[Tuple[float, ...], Tuple[Tuple[float, ...], ...]],\n):\n    if not PitchProfile._check_init_data_integrity(profile_tuple):\n        raise ValueError(f\"invalid profile tuple {profile_tuple}\")\n    profile_data = None\n    profile_shape = None\n    dist_type = None\n\n    x_cats = None\n    x_label = None\n    y_cats = None\n    y_label = None\n    if isinstance(profile_tuple[0], float):\n        profile_data = list(profile_tuple)\n        profile_shape = [len(profile_data)]\n        dist_type = \"symmetric_key_profile\"\n        x_cats = CHROMATIC_NAMES\n        x_label = PitchProfile._profile_label\n        y_cats = None\n        y_label = PitchProfile._data_labels[1]\n\n    elif isinstance(profile_tuple[0], tuple):\n        # convert data from tonic-first to non-rotated canonical order\n        profile_data = [\n            elem[-idx:] + elem[:-idx]  # type: ignore\n            for idx, elem in enumerate(profile_tuple)\n        ]\n        profile_shape = [len(profile_data), len(profile_data[0])]\n        dist_type = \"asymmetric_key_profile\"\n        x_cats = PitchProfile._data_cats_2d\n        x_label = PitchProfile._data_labels[0]\n        y_cats = CHROMATIC_NAMES\n        y_label = PitchProfile._profile_label\n\n    else:\n        raise ValueError(f\"invalid profile tuple {profile_tuple}\")\n    super().__init__(\n        name,\n        profile_data,\n        dist_type,\n        profile_shape,\n        x_cats,  # type: ignore (strings are ok)\n        x_label,\n        y_cats,  # type: ignore (strings are ok)\n        y_label,\n    )\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile-functions","title":"Functions","text":""},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.normalize","title":"normalize","text":"<pre><code>normalize()\n</code></pre> <p>Normalize the pitch-class distributions within the PitchProfile.</p> <p>For each key, the sum of all weights in the corresponding key profile is normalized to 1.</p> Source code in <code>amads/pitch/key/profiles.py</code> <pre><code>def normalize(self):\n    \"\"\"\n    Normalize the pitch-class distributions within the PitchProfile.\n\n    For each key, the sum of all weights in the corresponding key profile\n    is normalized to 1.\n    \"\"\"\n    if self.distribution_type == \"symmetric_key_profile\":\n        self.data = norm.normalize(self.data, \"sum\").tolist()\n        return self\n    else:\n        self.data = [\n            norm.normalize(elem, \"sum\").tolist() for elem in self.data\n        ]\n        return self\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.key_to_weights","title":"key_to_weights","text":"<pre><code>key_to_weights(key: str) -&gt; list[float]\n</code></pre> <p>Given a key, computes the corresponding weights for the key profile.</p> <p>The key profile is rotated to the key as the tonic and organized in relative chromatic degree.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>weights: list of 12 floats</p> </li> </ul> Source code in <code>amads/pitch/key/profiles.py</code> <pre><code>def key_to_weights(self, key: str) -&gt; List[float]:\n    \"\"\"\n    Given a key, computes the corresponding weights for the key profile.\n\n    The key profile is rotated to the key as the tonic and organized in\n    relative chromatic degree.\n\n    Parameters\n    ----------\n    key: str\n        pitch string denoting the key of the key profile data we want to retrieve\n\n    Returns\n    -------\n    list[float]\n        weights: list of 12 floats\n    \"\"\"\n    key_idx = None\n    try:  # C -&gt; 0, C# -&gt; 1, D -&gt; 2, ..., B -&gt; 11\n        key_idx = CHROMATIC_NAMES.index(key.capitalize())\n    except ValueError:\n        raise ValueError(\n            f\"invalid key {key}, expected one of {CHROMATIC_NAMES}\"\n        )\n    assert key_idx is not None\n    assert key_idx &gt;= 0 and key_idx &lt; 12\n    if self.distribution_type == \"symmetric_key_profile\":\n        # symmetrical case\n        return self.data\n    elif self.distribution_type != \"asymmetric_key_profile\":\n        ValueError(f\"invalid distribution type {self.distribution_type}\")\n        # asymmetrical case\n    return self.data[key_idx]\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.key_to_weights(key)","title":"<code>key</code>","text":"(<code>str</code>)           \u2013            <p>pitch string denoting the key of the key profile data we want to retrieve</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.as_canonical_matrix","title":"as_canonical_matrix","text":"<pre><code>as_canonical_matrix() -&gt; ndarray\n</code></pre> <p>Computes a 12x12 matrix of the profile data.</p> <pre><code>1. The i-th row corresponds to the key profile of the\n   i-th chromatic degree\n\n2. Each row's weights begin from C and are ordered by\n   relative chromatic degree)\n</code></pre> <p>Returns:</p> <ul> <li> <code>ndarray</code>           \u2013            <p>a 12x12 numpy matrix of floats</p> </li> </ul> Source code in <code>amads/pitch/key/profiles.py</code> <pre><code>def as_canonical_matrix(self) -&gt; np.ndarray:\n    \"\"\"\n    Computes a 12x12 matrix of the profile data.\n\n        1. The i-th row corresponds to the key profile of the\n           i-th chromatic degree\n\n        2. Each row's weights begin from C and are ordered by\n           relative chromatic degree)\n\n    Returns\n    -------\n    np.ndarray\n        a 12x12 numpy matrix of floats\n    \"\"\"\n    assert self.dimensions[0] == 12\n    if self.distribution_type == \"symmetric_key_profile\":\n        # in this case, symmetric profile is transpositionally equivalent,\n        # so for instance, in C# major, the pitch weights would be\n        # transposed (rotated) as B -&gt; C, C -&gt; C#, C# -&gt; D, ...\n        profile_matrix = np.zeros((self.dimensions[0], self.dimensions[0]))\n        for i in range(12):\n            data = self.data[-i:] + self.data[:-i]\n            profile_matrix[i] = data\n        return profile_matrix\n    else:\n        assert self.distribution_type == \"asymmetric_key_profile\"\n        assert self.dimensions == [12, 12]\n        return np.array(self.data)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot","title":"plot","text":"<pre><code>plot(\n    color: str | None = None,\n    option: str | None = None,\n    show: bool = True,\n    fig: Figure | None = None,\n    ax: Axes | None = None,\n) -&gt; Figure\n</code></pre> <p>Virtual plot function for Distribution. Allows standalone plotting of a Distribution (when fig and ax are None), while providing enough extensibility to invoke this plot function or its overwritten variants for subplotting when fig and ax are provided as arguments.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>A ValueError is raised if:</p> <ul> <li><code>ax</code> (axes) but not <code>fig</code> (Figure) is provided</li> <li><code>dims</code> is not 1 or 2</li> </ul> </li> </ul> Notes <p>Behavior to this specific plot method:</p> <ul> <li>1-D: bar (default) or line when kind is \"line\"</li> <li>2-D: heatmap</li> </ul> Source code in <code>amads/core/distribution.py</code> <pre><code>def plot(\n    self,\n    color: Optional[str] = None,\n    option: Optional[str] = None,\n    show: bool = True,\n    fig: Optional[Figure] = None,\n    ax: Optional[Axes] = None,\n) -&gt; Figure:\n    \"\"\"\n    Virtual plot function for Distribution.\n    Allows standalone plotting of a Distribution (when fig and ax are None),\n    while providing enough extensibility to invoke this plot function or its\n    overwritten variants for subplotting when fig and ax are provided as\n    arguments.\n\n    Parameters\n    ----------\n    color : Optional[str]\n        Plot color string specification. In this particular plot function,\n        it is handled in 1-D distributions and ignored in 2-D distributions.\n        None for default option (Distribution.DEFAULT_BAR_COLOR).\n    option : Optional[str]\n        Plot style string specification. In this particular plot function,\n        only {\"bar\", \"line\"} are valid string arguments that will be handled\n        in a 1-D distribution, while any argument is ignored in 2-D\n        distributions. None for default option (\"bar\").\n    show : bool\n        Whether to call ``plt.show()`` at the end.\n    fig : Figure\n        Provide existing Figure to draw on; if omitted, a new\n        figure is created.\n    ax : Axes\n        Provide existing axes to draw on; if omitted, a new\n        figure and axes are created.\n\n    Raises\n    ------\n    ValueError\n        A ValueError is raised if:\n\n        - `ax` (axes) but not `fig` (Figure) is provided\n        - `dims` is not 1 or 2\n\n    Notes\n    -----\n    Behavior to this specific plot method:\n\n    - 1-D: bar (default) or line when kind is \"line\"\n    - 2-D: heatmap\n    \"\"\"\n    dims = len(self.dimensions)\n    if dims not in (1, 2):\n        raise ValueError(\n            \"Unsupported number of dimensions for Distribution class\"\n        )\n\n    # Figure/axes handling: either both `fig` and `ax` are provided, or\n    # neither; in the latter case, create a new figure/axes pair.\n    if fig is None:\n        if ax is not None:\n            raise ValueError(\"invalid figure/axis combination\")\n        fig, ax = plt.subplots()\n    else:\n        if ax is None:\n            raise ValueError(\"invalid figure/axis combination\")\n\n    if dims == 1:\n        if color is None:\n            color = Distribution.DEFAULT_BAR_COLOR\n        if option is None:\n            option = \"bar\"\n        x = range(len(self.x_categories))\n        # 1-D distributions: draw either a bar chart or a line chart.\n        if option == \"bar\":\n            ax.bar(x, self.data, color=color)\n        elif option == \"line\":\n            ax.plot(x, self.data, color=color, marker=\"o\")\n        else:\n            raise ValueError(f\"unknown kind for 1D plot: {option}\")\n\n        ax.set_xticks(list(x))\n        ax.set_xticklabels([str(label) for label in self.x_categories])\n        ax.set_xlabel(self.x_label)\n        ax.set_ylabel(self.y_label)\n        ax.set_title(self.name)\n\n    else:  # dims == 2\n        # 2-D distributions: render as a heatmap with a colorbar.\n        data = np.asarray(self.data)\n        cax = ax.imshow(\n            data, cmap=\"gray_r\", aspect=\"auto\", interpolation=\"nearest\"\n        )\n        fig.colorbar(cax, ax=ax, label=\"Proportion\")\n\n        ax.set_xlabel(self.x_label)\n        ax.set_ylabel(self.y_label)\n        ax.set_title(self.name)\n\n        ax.set_xticks(range(len(self.x_categories)))\n        ax.set_xticklabels([str(label) for label in self.x_categories])\n        if self.y_categories is not None:\n            ax.set_yticks(range(len(self.y_categories)))\n            ax.set_yticklabels([str(label) for label in self.y_categories])\n\n        ax.invert_yaxis()\n\n    fig.tight_layout()\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot(color)","title":"<code>color</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Plot color string specification. In this particular plot function, it is handled in 1-D distributions and ignored in 2-D distributions. None for default option (Distribution.DEFAULT_BAR_COLOR).</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot(option)","title":"<code>option</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Plot style string specification. In this particular plot function, only {\"bar\", \"line\"} are valid string arguments that will be handled in a 1-D distribution, while any argument is ignored in 2-D distributions. None for default option (\"bar\").</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to call <code>plt.show()</code> at the end.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot(fig)","title":"<code>fig</code>","text":"(<code>Figure</code>, default:                   <code>None</code> )           \u2013            <p>Provide existing Figure to draw on; if omitted, a new figure is created.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot(ax)","title":"<code>ax</code>","text":"(<code>Axes</code>, default:                   <code>None</code> )           \u2013            <p>Provide existing axes to draw on; if omitted, a new figure and axes are created.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.show","title":"show","text":"<pre><code>show() -&gt; None\n</code></pre> <p>Print information about the distribution</p> Source code in <code>amads/core/distribution.py</code> <pre><code>def show(self) -&gt; None:\n    \"\"\"Print information about the distribution\"\"\"\n    plural = \"\" if len(self.dimensions) == 1 else \"s\"\n    print(\n        f'Distribution: \"{self.name}\" has dimension{plural} '\n        f'{self.dimensions}, x_label: \"{self.x_label}\", '\n        f'y_label: \"{self.y_label}\", '\n        f'distribution_type: \"{self.distribution_type}\"'\n    )\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_multiple","title":"plot_multiple  <code>classmethod</code>","text":"<pre><code>plot_multiple(\n    dists: list[Distribution],\n    show: bool = True,\n    options: str | list[str] | None = None,\n    colors: str | list[str] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Plot multiple distributions into a single Figure using vertically stacked subplots.</p> <p>Returns:</p> <ul> <li> <code>Figure or None</code>           \u2013            <p>A matplotlib Figure when at least one distribution is plotted; otherwise None when <code>dists</code> is empty.</p> </li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> Notes <ul> <li>distributions are plotted in the same order they were presented in   dists list</li> <li>as long as a Distribution or inherited class has a valid plot function   implemented, the relevant plot will be added to the figure at the   specified axes.</li> <li><code>options</code> and <code>colors</code> apply to all distributions</li> <li>Although the original plot function is only limited to   <code>option</code> and <code>color</code> being used in the 1-D case, it is not to say   that a class inheriting Distribution won't leverage these arguments.</li> <li>You can pass either a list (per-series) or a single string. When a   single string is provided, it will be broadcast to all inputs.   For example, kinds=\"line\" makes all 1-D plots line charts.</li> </ul> Source code in <code>amads/core/distribution.py</code> <pre><code>@classmethod\ndef plot_multiple(\n    cls,\n    dists: List[\"Distribution\"],\n    show: bool = True,\n    options: Optional[Union[str, List[str]]] = None,\n    colors: Optional[Union[str, List[str]]] = None,\n) -&gt; Optional[Figure]:\n    \"\"\"\n    Plot multiple distributions into a single Figure using vertically\n    stacked subplots.\n\n    Returns\n    -------\n    Figure or None\n        A matplotlib Figure when at least one distribution is plotted;\n        otherwise None when `dists` is empty.\n\n    Parameters\n    ----------\n    dists : list[Distribution]\n        Distributions to plot. 2-D are rendered as heatmaps; 1-D below them.\n    show : bool\n        Whether to call ``plt.show()`` at the end.\n    options : str | list[str] | None\n        plot style per distribution (e.g. \"bar\" or \"line\"). If a single\n        string is given, it is broadcast to all distributions. If None,\n        defaults to \"bar\".\n    colors : str | list[str] | None\n        color option per distribution. If a single string is given, it is\n        broadcast to all 1-D distributions. If None, defaults to\n        the single color Distribution.DEFAULT_BAR_COLOR.\n\n    Notes\n    -----\n    - distributions are plotted in the same order they were presented in\n      dists list\n    - as long as a Distribution or inherited class has a valid plot function\n      implemented, the relevant plot will be added to the figure at the\n      specified axes.\n    - `options` and `colors` apply to all distributions\n    - Although the original plot function is only limited to\n      `option` and `color` being used in the 1-D case, it is not to say\n      that a class inheriting Distribution won't leverage these arguments.\n    - You can pass either a list (per-series) or a single string. When a\n      single string is provided, it will be broadcast to all inputs.\n      For example, kinds=\"line\" makes all 1-D plots line charts.\n    \"\"\"\n    if not dists:\n        return None\n\n    # when single string, broadcast to all distributions\n    options = options or [\"bar\"] * len(dists)\n    colors = colors or [Distribution.DEFAULT_BAR_COLOR] * len(dists)\n    if isinstance(options, str):\n        options = [options] * len(dists)\n    if isinstance(colors, str):\n        colors = [colors] * len(dists)\n    if len(options) != len(dists) or len(colors) != len(dists):\n        raise ValueError(\n            \"kinds/colors must match number of distributions in list case\"\n        )\n\n    # Create a vertical stack of subplots sized to total count\n    fig, axes = plt.subplots(len(dists), 1, squeeze=False)\n    axes = axes.ravel()\n    # use an axes iterator here\n    ax_iter = iter(axes)\n    for d, k, c in zip(dists, options, colors):\n        ax = next(ax_iter)\n        d.plot(color=c, option=k, show=False, fig=fig, ax=ax)\n\n    fig.tight_layout()\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_multiple(dists)","title":"<code>dists</code>","text":"(<code>list[Distribution]</code>)           \u2013            <p>Distributions to plot. 2-D are rendered as heatmaps; 1-D below them.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_multiple(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to call <code>plt.show()</code> at the end.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_multiple(options)","title":"<code>options</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>plot style per distribution (e.g. \"bar\" or \"line\"). If a single string is given, it is broadcast to all distributions. If None, defaults to \"bar\".</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_multiple(colors)","title":"<code>colors</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>color option per distribution. If a single string is given, it is broadcast to all 1-D distributions. If None, defaults to the single color Distribution.DEFAULT_BAR_COLOR.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_grouped_1d","title":"plot_grouped_1d  <code>classmethod</code>","text":"<pre><code>plot_grouped_1d(\n    dists: list[Distribution],\n    show: bool = True,\n    options: str | list[str] | None = None,\n    colors: str | list[str] | None = None,\n) -&gt; Figure | None\n</code></pre> <p>Overlay multiple 1-D distributions on a single axes.</p> <p>This function draws all input 1-D distributions in one matplotlib Axes so that each category (x bin) shows a \"group\" of values\u2014one per distribution. You can mix plotting styles using the <code>kinds</code> argument (for example, some as bars and others as lines with markers. Colors are controlled via the <code>colors</code> argument.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure or None</code>           \u2013            <p>A matplotlib Figure if any distributions are plotted; None when <code>dists</code> is empty.</p> </li> </ul> Constraints <ul> <li>Only 1-D distributions are accepted. All inputs must have the same   length (number of categories) so they can be grouped per category.</li> <li>The x/y labels and category names are taken from the first   distribution in <code>dists</code>. Hence, this function does not support   overlaying 1-D distributions with different categories and labels.</li> </ul> How this differs from plot_multiple <ul> <li>plot_grouped_1d overlays all 1-D distributions on a single axes   to allow:<ol> <li>per-category (bin-by-bin) comparison intuitive and compact    for grouped bar graphs</li> <li>intuitive and compact gradient comparison for overlaid line    graphs.</li> </ol> </li> </ul> <p>Since all distributions are plotted in a single plot, we can   compare all plots within a single legend. - plot_multiple creates a vertical stack of subplots, one per   distribution, while leveraging the plot attribute of each   Distribution (and also supports 2-D heatmaps).</p> Source code in <code>amads/core/distribution.py</code> <pre><code>@classmethod\ndef plot_grouped_1d(\n    cls,\n    dists: List[\"Distribution\"],\n    show: bool = True,\n    options: Optional[Union[str, List[str]]] = None,\n    colors: Optional[Union[str, List[str]]] = None,\n) -&gt; Optional[Figure]:\n    \"\"\"Overlay multiple 1-D distributions on a single axes.\n\n    This function draws all input 1-D distributions in one matplotlib\n    Axes so that each category (x bin) shows a \"group\" of values\u2014one\n    per distribution. You can mix plotting styles using the `kinds`\n    argument (for example, some as bars and others as lines with\n    markers. Colors are controlled via the `colors` argument.\n\n    Parameters\n    ----------\n    dists : list[Distribution]\n        1-D distributions to compare in a single plot.\n    show : bool\n        Whether to call ``plt.show()`` at the end.\n    options : str | list[str] | None\n        Per-distribution plot style. Allowed values: \"bar\" or \"line\".\n        You can provide a single string to apply to all series (broadcast),\n        or a list with length `len(dists)`. If None, all series default to\n        \"bar\".\n    colors : str | list[str] | None\n        Per-distribution color list. You can provide a single string to\n        apply to all series (broadcast), or a list with length `len(dists)`.\n        If None, a distinct default color palette is applied (rcParams cycle\n        or the tab10 palette).\n\n    Returns\n    -------\n    Figure or None\n        A matplotlib Figure if any distributions are plotted; None when\n        `dists` is empty.\n\n    Constraints\n    -----------\n    - Only 1-D distributions are accepted. All inputs must have the same\n      length (number of categories) so they can be grouped per category.\n    - The x/y labels and category names are taken from the first\n      distribution in `dists`. Hence, this function does not support\n      overlaying 1-D distributions with different categories and labels.\n\n    How this differs from plot_multiple\n    -----------------------------------\n    - plot_grouped_1d overlays all 1-D distributions on a single axes\n      to allow:\n        1. per-category (bin-by-bin) comparison intuitive and compact\n           for grouped bar graphs\n        2. intuitive and compact gradient comparison for overlaid line\n           graphs.\n\n      Since all distributions are plotted in a single plot, we can\n      compare all plots within a single legend.\n    - plot_multiple creates a vertical stack of subplots, one per\n      distribution, while leveraging the plot attribute of each\n      Distribution (and also supports 2-D heatmaps).\n    \"\"\"\n    # Validate inputs\n    if not dists:\n        return None\n    if any(len(d.dimensions) != 1 for d in dists):\n        raise ValueError(\n            \"All distributions must be 1-D for grouped plotting\"\n        )\n    # number of categories for each plot in the 1d distribution\n    dimension = dists[0].dimensions[0]\n    if any(d.dimensions[0] != dimension for d in dists):\n        raise ValueError(\"All 1-D distributions must have the same length\")\n    # labels and categories will need to be the same...\n    # or else some of the data visualization for axes will be misleading\n    # since this function does not support plotting multiple axes labels\n    # and categories on the same plot\n    if any(\n        d.x_label != dists[0].x_label or d.y_label != dists[0].y_label\n        for d in dists\n    ):\n        raise ValueError(\"All 1-D distributions must have same axes labels\")\n    if any(\n        d.x_categories != dists[0].x_categories\n        or d.y_categories != dists[0].y_categories\n        for d in dists\n    ):\n        raise ValueError(\n            \"All 1-D distributions must have same axes categories\"\n        )\n\n    # when single string, broadcast to all\n    if isinstance(options, str):\n        options = [options] * len(dists)\n    if isinstance(colors, str):\n        colors = [colors] * len(dists)\n    if options is None:\n        options = [\"bar\"] * len(dists)\n    if colors is None:\n        # get the default ListedColormap; get_cmap does not always\n        # return an object with .colors, so we have to ignore the type:\n        base_colors = plt.get_cmap(\"tab10\").colors  # type: ignore\n        colors = [\n            base_colors[i % len(base_colors)] for i in range(len(dists))\n        ]\n    if len(options) != len(dists) or len(colors) != len(dists):\n        raise ValueError(\n            \"kinds and colors must match number of distributions\"\n        )\n\n    bar_graph_info = None\n    line_graph_info = None\n    # partition bar graphs and line graphs to be plotted separately\n    # (so that line graphs don't each take up a bin themselves)\n    if isinstance(options, list):\n        bar_graph_info = [\n            (dist, color)\n            for dist, kind, color in zip(dists, options, colors)\n            if kind == \"bar\"\n        ]\n        line_graph_info = [\n            (dist, color)\n            for dist, kind, color in zip(dists, options, colors)\n            if kind in (\"line\", \"plot\")\n        ]\n\n    fig, ax = plt.subplots()\n\n    # Grouped bar arithmetic (unit bar width, grouped per category)\n    # must have at least 1 bin for the line plot to be valid\n    n = max(len(bar_graph_info), 1)\n    # bar_width does not matter here, since everything in the grouped bar\n    # graph is scaled according to this variable\n    bar_width = 1\n    x_coords = np.arange(dimension) * bar_width * n\n    bottom_half, upper_half = n // 2, n - n // 2\n    width_idxes = range(-bottom_half, upper_half + 1)\n    is_even_offset = ((n + 1) % 2) * bar_width / 2\n\n    # setting plot axes\n    ax.set_xticks(x_coords)\n    ax.set_xticklabels([str(d) for d in dists[0].x_categories])\n    ax.set_xlabel(dists[0].x_label)\n    ax.set_ylabel(dists[0].y_label)\n    ax.set_title(\"Grouped Histogram Plot for 1-D Distributions\")\n\n    for width_idx, (dist, color) in zip(width_idxes, bar_graph_info):\n        x_axis = x_coords + width_idx * bar_width + is_even_offset\n        ax.bar(\n            x_axis, dist.data, width=bar_width, label=dist.name, color=color\n        )\n\n    for dist, color in line_graph_info:\n        ax.plot(\n            x_coords, dist.data, color=color, marker=\"o\", label=dist.name\n        )\n\n    ax.legend()\n    fig.tight_layout()\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_grouped_1d(dists)","title":"<code>dists</code>","text":"(<code>list[Distribution]</code>)           \u2013            <p>1-D distributions to compare in a single plot.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_grouped_1d(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to call <code>plt.show()</code> at the end.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_grouped_1d(options)","title":"<code>options</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Per-distribution plot style. Allowed values: \"bar\" or \"line\". You can provide a single string to apply to all series (broadcast), or a list with length <code>len(dists)</code>. If None, all series default to \"bar\".</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.PitchProfile.plot_grouped_1d(colors)","title":"<code>colors</code>","text":"(<code>str | list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Per-distribution color list. You can provide a single string to apply to all series (broadcast), or a list with length <code>len(dists)</code>. If None, a distinct default color palette is applied (rcParams cycle or the tab10 palette).</p>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.KeyProfile","title":"KeyProfile  <code>dataclass</code>","text":"<pre><code>KeyProfile(name: str = '', literature: str = '', about: str = '')\n</code></pre> <p>This is the base class for all key profiles.</p> <p>Attributes:     name (str): the name of the profile     literature (str): citations for the profile in the literature     about (str): a longer description of the profile.</p> <p>Methods:</p> <ul> <li> <code>__getitem__</code>             \u2013              <p>This is added for (some) backwards compatibility, allowing objects</p> </li> </ul>"},{"location":"reference/pitch/key/#amads.pitch.key.profiles.KeyProfile-functions","title":"Functions","text":""},{"location":"reference/pitch/key/#amads.pitch.key.profiles.KeyProfile.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(key: str)\n</code></pre> <p>This is added for (some) backwards compatibility, allowing objects to be accessed as dictionaries using bracket notation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; kp = KrumhanslKessler()\n&gt;&gt;&gt; kp[\"name\"]\n'KrumhanslKessler'\n</code></pre> Source code in <code>amads/pitch/key/profiles.py</code> <pre><code>def __getitem__(self, key: str):\n    \"\"\"This is added for (some) backwards compatibility, allowing objects\n    to be accessed as dictionaries using bracket notation.\n\n    Examples\n    --------\n        &gt;&gt;&gt; kp = KrumhanslKessler()\n        &gt;&gt;&gt; kp[\"name\"]\n        'KrumhanslKessler'\n    \"\"\"\n    try:\n        return getattr(self, key)\n    # Slightly nicer error handling\n    except AttributeError:\n        raise AttributeError(\n            f\"Key Profile '{self.__str__()}' has no attribute '{key}'\"\n        )\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.transpose2c","title":"transpose2c","text":"<p>transposes a given score to C after we've attained the maximum correlation key of the score from the krumhansl-kessler algorithm (kkcc with default parameters).</p> <p>Author: Tai Nakamura, Di Wang</p> Reference <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=93</p>"},{"location":"reference/pitch/key/#amads.pitch.key.transpose2c.transpose2c","title":"transpose2c","text":"<pre><code>transpose2c(\n    score: Score, profile_name: str = \"KRUMHANSL-KESSLER\"\n) -&gt; Score\n</code></pre> <p>returns a copy of score transposed to C-major/minor with the key from the original krumhansl-kessler algorithm (kkcc with default parameters).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>a copy of the input score transposed to C-major/minor</p> </li> </ul> Source code in <code>amads/pitch/key/transpose2c.py</code> <pre><code>def transpose2c(score: Score, profile_name: str = \"KRUMHANSL-KESSLER\") -&gt; Score:\n    \"\"\"\n    returns a copy of score transposed to C-major/minor with the key from the\n    original krumhansl-kessler algorithm (kkcc with default parameters).\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze.\n    profile_name : str\n        string argument denoting the relevant profile for key estimation\n\n    Returns\n    -------\n    Score\n        a copy of the input score transposed to C-major/minor\n    \"\"\"\n    # kkcc fails when an empty score is supplied.\n    # However, an empty score transposes to an empty score regardless of what key\n    # you're transposing to, so we treat this as a special case here.\n    if next(score.find_all(Note), None) is None:\n        return score.deepcopy()\n    corr_vals = kkcc(score, profile_name)\n\n    key_idx = corr_vals.index(max(corr_vals)) % 12\n    # TODO: need to use pitch_shift which is to be implemented in Score\n    score_copy = score.deepcopy()\n    for note in score_copy.find_all(Note):\n        keynum, alt = note.pitch.as_tuple()\n        # since Pitches with same alt and keynum are equivalent\n        # and Pitches themselves are considered \"immutable\" in\n        # our representation scheme\n        note.pitch = Pitch(keynum - key_idx, alt)\n    return score_copy\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.transpose2c.transpose2c(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.transpose2c.transpose2c(profile_name)","title":"<code>profile_name</code>","text":"(<code>str</code>, default:                   <code>'KRUMHANSL-KESSLER'</code> )           \u2013            <p>string argument denoting the relevant profile for key estimation</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkkey","title":"kkkey","text":"<p>Maximal correlation value's attribute and index pair from key_cc algorithm.</p> <p>Corresponds to kkkey in miditoolbox.</p> Reference <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=68</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkkey.kkkey","title":"kkkey","text":"<pre><code>kkkey(\n    score: Score,\n    profile: KeyProfile = krumhansl_kessler,\n    attribute_names: list[str] | None = [\"major\", \"minor\"],\n    salience_flag: bool = False,\n) -&gt; tuple[str, int]\n</code></pre> <p>Finds the pitch profile with the highest correlation value.</p> <p>Within <code>profile</code> there are multiple profiles named by attributes. This function returns the \"best\" attribute (string) and the best key (int) where the int corresponds to the 12 keys in order: 0 -&gt; C, 1 -&gt; C#, ..., 11 -&gt; B. (see key_cc.py for more details)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[str, int]</code>           \u2013            <p>The attribute name and key with the highest correlation coefficient.</p> </li> </ul> See Also <p>key_cc</p> Source code in <code>amads/pitch/key/kkkey.py</code> <pre><code>def kkkey(\n    score: Score,\n    profile: prof.KeyProfile = prof.krumhansl_kessler,\n    attribute_names: Optional[List[str]] = [\"major\", \"minor\"],\n    salience_flag: bool = False,\n) -&gt; Tuple[str, int]:\n    \"\"\"\n    Finds the pitch profile with the highest correlation value.\n\n    Within `profile` there are multiple profiles named by attributes.\n    This function returns the \"best\" attribute (string) and the best\n    key (int) where the int corresponds to the 12 keys in order:\n    0 -&gt; C, 1 -&gt; C#, ..., 11 -&gt; B. (see key_cc.py for more details)\n\n    Parameters\n    ----------\n    score: Score\n        The musical score to analyze.\n    profile: Profile\n        The key profile to use for analysis.\n    attribute_names: Optional[List[str]]\n        List of attribute names that denote the particular PitchProfiles\n        within the KeyProfile to compute correlations for.\n        See key_cc for more details\n    salience_flag: bool\n        indicate whether we want to turn on salience weights in key_cc\n\n    Returns\n    -------\n    tuple[str, int]\n        The attribute name and key with the highest correlation coefficient.\n\n    See Also\n    --------\n    key_cc\n    \"\"\"\n    corrcoef_pairs = key_cc(score, profile, attribute_names, salience_flag)\n    # list of pairs (attribute_name, [correlation coefficients])\n    max_val_iter = (coefs for (_, coefs) in corrcoef_pairs if coefs is not None)\n    # This code is a little unexpected: it first searches for the maximum\n    # correlation value across all attributes and keys, then finds the\n    # attribute and key index corresponding to that maximum value.\n    max_val = max(chain.from_iterable(max_val_iter))\n    nested_coefs_iter = (\n        (attr, coefs.index(max_val))\n        for (attr, coefs) in corrcoef_pairs\n        if coefs is not None and max_val in coefs\n    )\n    return next(nested_coefs_iter)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.kkkey.kkkey(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkkey.kkkey(profile)","title":"<code>profile</code>","text":"(<code>KeyProfile</code>, default:                   <code>krumhansl_kessler</code> )           \u2013            <p>The key profile to use for analysis.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkkey.kkkey(attribute_names)","title":"<code>attribute_names</code>","text":"(<code>list[str] | None</code>, default:                   <code>['major', 'minor']</code> )           \u2013            <p>List of attribute names that denote the particular PitchProfiles within the KeyProfile to compute correlations for. See key_cc for more details</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkkey.kkkey(salience_flag)","title":"<code>salience_flag</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>indicate whether we want to turn on salience weights in key_cc</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keymode","title":"keymode","text":"<p>Assuming key of C, find a score's mode based on key profiles using key_cc.</p> <p>This function is primarily used to estimate the mode, an attribute of a given KeyProfile collection. The key of C is assumed, and cross-correlation with profiles for other keys are ignored.</p> Reference <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=65</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keymode.keymode","title":"keymode","text":"<pre><code>keymode(\n    score: Score,\n    profile: KeyProfile = krumhansl_kessler,\n    attribute_names: list[str] | None = [\"major\", \"minor\"],\n    salience_flag: bool = False,\n) -&gt; list[str]\n</code></pre> <p>Find the mode based on cross-correlation values.</p> <p>Returns the list of mode(s) whose profile(s) have a maximal cross-correlation with the score's pitch distribution.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of attribute names that have maximal cross-correlation with the score's profile (usually, length will be 1).</p> </li> </ul> See Also <p>key_cc</p> Source code in <code>amads/pitch/key/keymode.py</code> <pre><code>def keymode(\n    score: Score,\n    profile: prof.KeyProfile = prof.krumhansl_kessler,\n    attribute_names: Optional[List[str]] = [\"major\", \"minor\"],\n    salience_flag: bool = False,\n) -&gt; List[str]:\n    \"\"\"\n    Find the mode based on cross-correlation values.\n\n    Returns the list of mode(s) whose profile(s) have a maximal\n    cross-correlation with the score's pitch distribution.\n\n    Parameters\n    ----------\n    score: Score\n        The musical score to analyze.\n    profile: Profile\n        collection of profile data for different modes (attributes)\n    attribute_names: Optional[List[str]]\n        List of attribute names that denote the particular PitchProfiles\n        within the KeyProfile and generally indicate different modes.\n        See profiles.py for more details.\n    salience_flag: bool\n        Indicate whether we want to turn on salience weights in key_cc\n        which is used to compute the cross-correlations.\n\n    Returns\n    -------\n    List[str]\n        List of attribute names that have maximal cross-correlation with\n        the score's profile (usually, length will be 1).\n\n    See Also\n    --------\n    key_cc\n    \"\"\"\n\n    # This algorithm is not very efficient: It computes 12 correlations\n    # for each mode, but only uses one. Then, it iterates through the\n    # results, once to find the maximum, and again to form a list of\n    # modes that achieve that maximum.\n\n    corrcoef_pairs = key_cc(score, profile, attribute_names, salience_flag)\n\n    c_max_val_iter = (\n        coefs[0] for (_, coefs) in corrcoef_pairs if coefs is not None\n    )\n    c_max_val = max(c_max_val_iter)\n    keymode_attributes = [\n        attr\n        for (attr, coefs) in corrcoef_pairs\n        if coefs is not None and coefs[0] == c_max_val\n    ]\n    return keymode_attributes\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keymode.keymode(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keymode.keymode(profile)","title":"<code>profile</code>","text":"(<code>KeyProfile</code>, default:                   <code>krumhansl_kessler</code> )           \u2013            <p>collection of profile data for different modes (attributes)</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keymode.keymode(attribute_names)","title":"<code>attribute_names</code>","text":"(<code>list[str] | None</code>, default:                   <code>['major', 'minor']</code> )           \u2013            <p>List of attribute names that denote the particular PitchProfiles within the KeyProfile and generally indicate different modes. See profiles.py for more details.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keymode.keymode(salience_flag)","title":"<code>salience_flag</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicate whether we want to turn on salience weights in key_cc which is used to compute the cross-correlations.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.key_cc","title":"key_cc","text":"<p>Cross-correlations between pitch-class distributions and key profiles.</p> <p>Author: Tai Nakamura, Di Wang</p> Reference <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=68 for more details</p>"},{"location":"reference/pitch/key/#amads.pitch.key.key_cc.key_cc","title":"key_cc","text":"<pre><code>key_cc(\n    score: Score,\n    profile: KeyProfile = krumhansl_kessler,\n    attribute_names: list[str] | None = None,\n    salience_flag: bool = False,\n) -&gt; list[tuple[str, tuple[float] | None]]\n</code></pre> <p>Calculate the correlation coefficients with specific pitch profiles.</p> <p>A score's pitch-class distribution is computed and generally, KeyProfiles come from existing data in profiles.py. Within each KeyProfile are one or more distributions, e.g. for \"major\" and \"minor\" keys, so you must specify which distributions you want correlations for.  Return a list of tuples, each containing the attribute name (e.g., \"major\") and the corresponding 12 correlation coefficients.</p> <p>When <code>salience_flag</code> is True, the pitch class distribution from the score (pcd) is replaced by a new one (pcd2) where each element is a weighted sum of the elements of pcd. The weights are rotated for each element. Thus, pcd2[i] = sum(pcd[j] * weight[(j + i) mod 12].</p> <p>The idea here is that the perception of significance of a certain pitch in a score depends not only on its naive unweighted frequency, but also (to a lesser extent) on the frequency of functionally harmonic pitches present in the score.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[tuple[str, tuple[float] | None]]</code>           \u2013            <p>A list of tuples where each tuple contains the attribute name, from parameter <code>attribute_names</code>, and the corresponding 12-tuple of correlation coefficients. If an attribute name does not reference a valid data field within the specified key profile, it will yield <code>(</code>attribute_name<code>, None)</code>.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>RuntimeError</code>             \u2013            <p>If the score or key profile contains equal pitch weights, resulting in correlation not being able to be computed.</p> </li> </ul> Source code in <code>amads/pitch/key/key_cc.py</code> <pre><code>def key_cc(\n    score: Score,\n    profile: prof.KeyProfile = prof.krumhansl_kessler,\n    attribute_names: Optional[List[str]] = None,\n    salience_flag: bool = False,\n) -&gt; List[Tuple[str, Optional[Tuple[float]]]]:\n    \"\"\"\n    Calculate the correlation coefficients with specific pitch profiles.\n\n    A score's pitch-class distribution is computed and generally,\n    KeyProfiles come from existing data in profiles.py. Within each\n    KeyProfile are one or more distributions, e.g. for \"major\" and\n    \"minor\" keys, so you must specify which distributions you want\n    correlations for.  Return a list of tuples, each containing the\n    attribute name (e.g., \"major\") and the corresponding 12 correlation\n    coefficients.\n\n    When `salience_flag` is True, the pitch class distribution from the score\n    (pcd) is replaced by a new one (pcd2) where each element is a weighted sum\n    of the elements of pcd. The weights are rotated for each element. Thus,\n    pcd2[i] = sum(pcd[j] * weight[(j + i) mod 12].\n\n    The idea here is that the perception of significance of a certain pitch in\n    a score depends not only on its naive unweighted frequency, but also (to a\n    lesser extent) on the frequency of functionally harmonic pitches present\n    in the score.\n\n    Parameters\n    ----------\n    score: Score\n        The score to analyze.\n\n    profile: prof.KeyProfile\n        The key profile to use for analysis.\n\n    attribute_names: Optional[List[str]]\n        List of attribute names that denote the particular PitchProfiles\n        within the KeyProfile to compute correlations for. An example\n        `attribute_names` for profile prof.vuvan could be\n        `[\"natural_minor\", \"harmonic_minor\"]`, which says to\n        compute the cross-correlation between the pitch-class distribution\n        of the score and both prof.vuvan's natural_minor and prof.vuvan's\n        harmonic_minor. `None` can be supplied when we want to specify all\n        valid pitch profiles within a given key profile.\n\n    salience_flag: bool\n        If True, apply salience pitch-wise bias weights to the score's\n        pitch-class distribution.\n\n    Returns\n    -------\n    List[Tuple[str, Optional[Tuple[float]]]]\n        A list of tuples where each tuple contains the attribute name, from\n        parameter `attribute_names`, and the corresponding 12-tuple of\n        correlation coefficients. If an attribute name does not reference\n        a valid data field within the specified key profile, it will yield\n        `(`*attribute_name*`, None)`.\n\n    Raises\n    ------\n    RuntimeError\n        If the score or key profile contains equal pitch weights,\n        resulting in correlation not being able to be computed.\n    \"\"\"\n\n    # Get pitch-class distribution\n    pcd = np.array([pitch_class_distribution_1(score, weighted=False).data])\n\n    # Apply salience weighting if requested\n    if salience_flag:\n        # NOTE: this is not the weight vector,\n        # the salience weights for the c-pitch in the pitch-class distribution\n        # is [1, 0, 0.2, 0.17, 0.33, 0, 0, 0.5, 0, 0, 0.25, 0].\n        # These weights form the first column of the 12x12 matrix salm.\n        sal2 = [1, 0, 0.25, 0, 0, 0.5, 0, 0, 0.33, 0.17, 0.2, 0] * 2\n        salm = np.zeros((12, 12))\n        for i in range(salm.shape[0]):\n            salm[i] = sal2[12 - i : 24 - i]\n        pcd = np.matmul(pcd, salm.T)  # shape (1, 12)\n\n    results = []\n\n    true_attribute_names = attribute_names\n\n    if true_attribute_names is None:\n        true_attribute_names = [\n            f.name\n            for f in fields(profile)\n            if f.name not in [\"name\", \"literature\", \"about\"]\n        ]\n\n    for attr_name in true_attribute_names:\n        # ! we should probably treat the special attributes as proper attribute names\n        if attr_name in [\"name\", \"literature\", \"about\"]:\n            print(\n                f\"Warning! Attempting to access metadata in profile '{profile.name}\"\n            )\n            results.append((attr_name, None))\n            continue\n        # Get the attribute from the profile\n        attr_value = getattr(profile, attr_name, None)\n\n        if attr_value is None:\n            print(\n                f\"Warning: Attribute '{attr_name}' is invalid or None in profile '{profile.name}'\"\n            )\n            results.append((attr_name, None))\n            continue\n        profiles_matrix = attr_value.as_canonical_matrix()\n        correlations = tuple(_compute_correlations(pcd, profiles_matrix))\n        if any(math.isnan(val) for val in correlations):\n            raise RuntimeError(\n                \"key_cc has encountered either an invalid or equal weight\"\n                \" score, or invalid pitch profile\\n\"\n                f\"correlations = {list(correlations)}\\n\"\n                f\"score pitch-class distribution = {list(pcd)}\\n\"\n                f\"profiles matrix = \\n{profiles_matrix}\\n\"\n            )\n        results.append((attr_name, correlations))\n\n    return results\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.key_cc.key_cc(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The score to analyze.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.key_cc.key_cc(profile)","title":"<code>profile</code>","text":"(<code>KeyProfile</code>, default:                   <code>krumhansl_kessler</code> )           \u2013            <p>The key profile to use for analysis.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.key_cc.key_cc(attribute_names)","title":"<code>attribute_names</code>","text":"(<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute names that denote the particular PitchProfiles within the KeyProfile to compute correlations for. An example <code>attribute_names</code> for profile prof.vuvan could be <code>[\"natural_minor\", \"harmonic_minor\"]</code>, which says to compute the cross-correlation between the pitch-class distribution of the score and both prof.vuvan's natural_minor and prof.vuvan's harmonic_minor. <code>None</code> can be supplied when we want to specify all valid pitch profiles within a given key profile.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.key_cc.key_cc(salience_flag)","title":"<code>salience_flag</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, apply salience pitch-wise bias weights to the score's pitch-class distribution.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkcc","title":"kkcc","text":"<p>This is a wrapper for key_cc to mimic the functionality of kkcc from miditoolbox for convenience.</p> <p>Author: Tai Nakamura, Di Wang</p> Reference <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=68</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkcc.kkcc","title":"kkcc","text":"<pre><code>kkcc(\n    score: Score,\n    profile_name: str = \"KRUMHANSL-KESSLER\",\n    salience_flag: bool = False,\n) -&gt; tuple[float]\n</code></pre> <p>kkcc wrapper on key_cc that provides the exact behavior of miditoolbox kkcc</p> <p>This module:</p> <ol> <li>Provides 3 string options for profile names</li> <li>maps the <code>profile_name</code> option to the relevant profile and attribute      name list combination for key_cc, replicating the behavior of      the relevant kkcc function call in miditoolbox.</li> </ol> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[float, ...]</code>           \u2013            <p>This denotes the 12 major correlation coefficients and 12 minor correlation coefficients from C to B in both major and minor keys, respectively (dim=24).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the score is not a valid Score object or if the profile_name is invalid.</p> </li> </ul> See Also <p>key_cc</p> Source code in <code>amads/pitch/key/kkcc.py</code> <pre><code>def kkcc(\n    score: Score,\n    profile_name: str = \"KRUMHANSL-KESSLER\",\n    salience_flag: bool = False,\n) -&gt; Tuple[float]:\n    \"\"\"\n    kkcc wrapper on key_cc that provides the exact behavior of miditoolbox kkcc\n\n    This module:\n\n      1. Provides 3 string options for profile names\n      2. maps the `profile_name` option to the relevant profile and attribute\n         name list combination for key_cc, replicating the behavior of\n         the relevant kkcc function call in miditoolbox.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze.\n    profile_name : str\n        String argument denoting the relevant miditoolbox\n        string option for kkcc. Must be one of \"KRUMHANSL-KESSLER\",\n        \"TEMPERLEY\", or \"ALBRECHT-SHANAHAN\".\n    salience_flag : bool\n        If True, apply salience weighting to the pitch-class\n        according to Huron &amp; Parncutt (1993).\n\n    Returns\n    -------\n    tuple[float, ...]\n        This denotes the 12 major correlation coefficients and 12 minor correlation\n        coefficients from C to B in both major and minor keys, respectively (dim=24).\n\n    Raises\n    ------\n    ValueError\n        If the score is not a valid Score object or if the profile_name is invalid.\n\n    See Also\n    --------\n    key_cc\n    \"\"\"\n    if not isinstance(score, Score):\n        raise ValueError(\"invalid score type!\")\n    # default is krumhansl kessler, and is what profile_name is set to by default\n    profile = None\n    attribute_list = None\n    if profile_name == \"KRUMHANSL-KESSLER\":\n        profile = profiles.krumhansl_kessler\n        attribute_list = [\"major\", \"minor\"]\n    elif profile_name == \"TEMPERLEY\":\n        profile = profiles.temperley\n        attribute_list = [\"major\", \"minor\"]\n    elif profile_name == \"ALBRECHT-SHANAHAN\":\n        profile = profiles.albrecht_shanahan\n        attribute_list = [\"major\", \"minor\"]\n    else:\n        raise ValueError(f'profile_name = \"{profile_name}\" is not valid')\n\n    # these checks are paranoia mainly to prevent future changes\n    # from breaking the code after\n    assert not (profile is None or attribute_list is None)\n    assert isinstance(profile, profiles.KeyProfile)\n    assert len(attribute_list) == 2\n\n    corrcoef_pairs = key_cc(score, profile, attribute_list, salience_flag)\n    # check integrity of corrcoef correspondences and whether or not they abide\n    # to the output agreed on in key_cc\n    assert len(corrcoef_pairs) == len(attribute_list)\n    assert all(\n        attr_name == target_attr and len(coefs) == 12\n        for ((attr_name, coefs), target_attr) in zip(\n            corrcoef_pairs, attribute_list\n        )\n    )\n\n    # pattern match, then collect individual coefficients into\n    # a single tuple to get our final corrcoefs\n    nested_coefs_iter = (coefs for (_, coefs) in corrcoef_pairs)\n    corrcoefs = tuple(chain.from_iterable(nested_coefs_iter))\n\n    return corrcoefs\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.kkcc.kkcc(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkcc.kkcc(profile_name)","title":"<code>profile_name</code>","text":"(<code>str</code>, default:                   <code>'KRUMHANSL-KESSLER'</code> )           \u2013            <p>String argument denoting the relevant miditoolbox string option for kkcc. Must be one of \"KRUMHANSL-KESSLER\", \"TEMPERLEY\", or \"ALBRECHT-SHANAHAN\".</p>"},{"location":"reference/pitch/key/#amads.pitch.key.kkcc.kkcc(salience_flag)","title":"<code>salience_flag</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, apply salience weighting to the pitch-class according to Huron &amp; Parncutt (1993).</p>"},{"location":"reference/pitch/key/#amads.pitch.key.max_key_cc","title":"max_key_cc","text":"<p>Maximal correlation value from key_cc algorithm.</p> <p>Corresponds to maxkkcc in miditoolbox</p> Reference <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=69</p>"},{"location":"reference/pitch/key/#amads.pitch.key.max_key_cc.max_key_cc","title":"max_key_cc","text":"<pre><code>max_key_cc(\n    score: Score,\n    profile: KeyProfile = krumhansl_kessler,\n    attribute_names: list[str] | None = [\"major\", \"minor\"],\n    salience_flag: bool = False,\n) -&gt; float\n</code></pre> <p>Find the maximal correlation value after calling key_cc with relevant parameters (see key_cc.py for more details)</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>the maximum correlation value computed in key_cc</p> </li> </ul> Source code in <code>amads/pitch/key/max_key_cc.py</code> <pre><code>def max_key_cc(\n    score: Score,\n    profile: prof.KeyProfile = prof.krumhansl_kessler,\n    attribute_names: Optional[List[str]] = [\"major\", \"minor\"],\n    salience_flag: bool = False,\n) -&gt; float:\n    \"\"\"\n    Find the maximal correlation value after calling key_cc\n    with relevant parameters (see key_cc.py for more details)\n\n    Parameters\n    ----------\n    score: Score\n        The musical score to analyze.\n    profile: Profile\n        The key profile to use for analysis.\n    attribute_names: Optional[List[str]]\n        List of attribute names that denote the particular PitchProfiles\n        within the KeyProfile to compute correlations for.\n        See key_cc for more details\n    salience_flag: bool\n        indicate whether we want to turn on salience weights in key_cc\n\n    Returns\n    -------\n    float\n        the maximum correlation value computed in key_cc\n    \"\"\"\n    corrcoef_pairs = key_cc(score, profile, attribute_names, salience_flag)\n    nested_coefs_iter = (\n        coefs for (_, coefs) in corrcoef_pairs if coefs is not None\n    )\n    return max(chain.from_iterable(nested_coefs_iter))\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.max_key_cc.max_key_cc(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.max_key_cc.max_key_cc(profile)","title":"<code>profile</code>","text":"(<code>KeyProfile</code>, default:                   <code>krumhansl_kessler</code> )           \u2013            <p>The key profile to use for analysis.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.max_key_cc.max_key_cc(attribute_names)","title":"<code>attribute_names</code>","text":"(<code>list[str] | None</code>, default:                   <code>['major', 'minor']</code> )           \u2013            <p>List of attribute names that denote the particular PitchProfiles within the KeyProfile to compute correlations for. See key_cc for more details</p>"},{"location":"reference/pitch/key/#amads.pitch.key.max_key_cc.max_key_cc(salience_flag)","title":"<code>salience_flag</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>indicate whether we want to turn on salience weights in key_cc</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom","title":"keysom","text":"<p>Projection of pitch-class distribution on a self-organizing map.</p> <p>Computes the projection of a pitch-class distribution on a trained self-organizing map, and visualize it in a 2-D heatmap with a custom color gradient.</p> <p>Unlike the original miditoolbox implementation in matlab, the SOM here is allowed to use any key profile as long as it contains major and minor pitch profile attributes. See key/profiles.py for more details.</p> Warnings <p>(Remove this after testing and experimentation)</p> References <p>https://citeseerx.ist.psu.edu/document?repid=rep1&amp;type=pdf&amp;doi=6e06906ca1ba0bf0ac8f2cb1a929f3be95eeadfa#page=66 for more details</p> <p>Toiviainen &amp; Krumhansl, 2003</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom","title":"keysom","text":"<pre><code>keysom(\n    note_collection: Score,\n    map: KeyProfileSOM | str,\n    has_legend: bool = True,\n    scaled_legend: bool = True,\n    font_size: float | str | None = None,\n    color_map: str | LinearSegmentedColormap | None = None,\n    show: bool = True,\n) -&gt; tuple[ndarray, Figure]\n</code></pre> <p>Projects the pitch-class distribution of a note-collection to a SOM.</p> <p>The SOM (self-organized map) is trained on key profile data. Returns the resulting projection matrix.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>array[float]</code>           \u2013            <p>Returns a 2-D numpy array that contains the projection of the input data onto the self-organizing map.</p> </li> <li> <code>Figure</code>           \u2013            <p>Matplotlib figure that contains a plot of the projection. (The axes are also accessible because they are contained within the figure.)</p> </li> </ul> Source code in <code>amads/pitch/key/keysom.py</code> <pre><code>def keysom(\n    note_collection: Score,\n    map: Union[ksom.KeyProfileSOM, str],\n    has_legend: bool = True,\n    scaled_legend: bool = True,\n    font_size: Optional[Union[float, str]] = None,\n    color_map: Optional[Union[str, mcolors.LinearSegmentedColormap]] = None,\n    show: bool = True,\n) -&gt; Tuple[np.ndarray, Figure]:\n    \"\"\"\n    Projects the pitch-class distribution of a note-collection to a SOM.\n\n    The SOM (self-organized map) is trained on key profile data.\n    Returns the resulting projection matrix.\n\n    Parameters\n    ----------\n    note_collection : Score\n        Collection of notes to calculate the pitch-class distribution of and\n        project onto the pre-trained SOM.\n    map : KeyProfileSOM\n        A pretrained self-organizing map trained on major + minor pitch profiles.\n        Or, a path string to a .npz file with the map.\n    has_legend : bool\n        Whether or not the plot should include a color legend\n    scaled_legend: bool\n        Whether or not the color legend scales with the projection's minimum\n        and maximum, or (by default) scales with the trained SOM's global\n        minimum and maximum. Use the default to get consistent color scales\n        across multiple graphs of differing data.\n    font_size: Optional[Union[float, str]] = None,\n        Font size, either:\n        (1) Font size of the labels (in points) or a string option from\n        matplotlib\n        (2) None for the default font size provided by matplotlib\n        Shares the same effects as the option of the same name in the\n        project_and_visualize method of KeyProfileSOM.\n    color_map: Optional[Union[str, mcolors.LinearSegmentedColormap]]\n        Color map describing the color gradient of the resulting visualization.\n        Option has same functionality as the `color_map` argument of the\n        `project_and_visualize` method of `KeyProfileSOM`.\n    show : bool\n        Whether or not we suspend execution and display the plot before returning\n        from this function\n\n    Returns\n    -------\n    np.array[float]\n        Returns a 2-D numpy array that contains the projection of the input\n        data onto the self-organizing map.\n    Figure\n        Matplotlib figure that contains a plot of the projection. (The axes\n        are also accessible because they are contained within the figure.)\n    \"\"\"\n    target_map = None\n    if isinstance(map, str):\n        target_map = ksom.KeyProfileSOM.from_trained_SOM(map)\n    elif isinstance(map, ksom.KeyProfileSOM):\n        target_map = map\n    else:\n        raise ValueError(\"invalid map argument!\")\n    input = tuple(pitch_class_distribution_1(note_collection).data)\n    projection, Figure = target_map.project_and_visualize(\n        input, has_legend, scaled_legend, font_size, color_map, show\n    )\n    # a good idea would probably be to return a tuple containing projection and\n    # Figure/axes\n    return projection, Figure\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(note_collection)","title":"<code>note_collection</code>","text":"(<code>Score</code>)           \u2013            <p>Collection of notes to calculate the pitch-class distribution of and project onto the pre-trained SOM.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(map)","title":"<code>map</code>","text":"(<code>KeyProfileSOM</code>)           \u2013            <p>A pretrained self-organizing map trained on major + minor pitch profiles. Or, a path string to a .npz file with the map.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(has_legend)","title":"<code>has_legend</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not the plot should include a color legend</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(scaled_legend)","title":"<code>scaled_legend</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not the color legend scales with the projection's minimum and maximum, or (by default) scales with the trained SOM's global minimum and maximum. Use the default to get consistent color scales across multiple graphs of differing data.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(font_size)","title":"<code>font_size</code>","text":"(<code>float | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Font size, either: (1) Font size of the labels (in points) or a string option from matplotlib (2) None for the default font size provided by matplotlib Shares the same effects as the option of the same name in the project_and_visualize method of KeyProfileSOM.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(color_map)","title":"<code>color_map</code>","text":"(<code>str | LinearSegmentedColormap | None</code>, default:                   <code>None</code> )           \u2013            <p>Color map describing the color gradient of the resulting visualization. Option has same functionality as the <code>color_map</code> argument of the <code>project_and_visualize</code> method of <code>KeyProfileSOM</code>.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysom.keysom(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not we suspend execution and display the plot before returning from this function</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata","title":"keysomdata","text":"<p>Key Profile Based Self-Organizing Maps</p> <p>Self-organizing maps trained on pitch class usage profiles from literature.</p> <p>A self-organizing map can be trained on key profile with 'major' and 'minor' data fields. The caller can define the decay rate and neighborhood function that the profile is trained on. A projection of a pitch-class distribution (pc_projection) onto a self-organizing map given the constituent input weights (input_weights) and their corresponding pitch-class distribution weights (pcdist), is defined for all valid row, column = i, j as pc_projection[i, j, :] = sum(input_weights[i, j, k] * pcdist[k] for all k in range(12)).</p> <p>When visualizing a projection of a pitch-class profile onto a trained self-organizing map, there are 24 key labels scattered across the map. The positions of these key labels (upper-case for major, lower-case for minor) are determined by the position of the best matching unit of the corresponding pitch profile in the trained map.</p> Reference <p>Toiviainen, P. &amp; Krumhansl, C. L. (2003). Measuring and modeling real-time responses to music: the dynamics of tonality induction. Perception, 32(6), 741-766.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM","title":"KeyProfileSOM","text":"<pre><code>KeyProfileSOM(\n    output_layer_dimensions: tuple[int] = _default_output_dimensions,\n)\n</code></pre> <p>The primary use-case for Key Profile SOM is to extract tonal features of a pair of major and minor pitch profiles and project them onto a 2-D map.</p> <p>We provide methods to allows users to do the following:</p> <ol> <li> <p>For initialization, supply the structure of the key profile SOM.</p> </li> <li> <p>For training, the following is customizeable:</p> <p>2.1 Customize the key profile used for training data. Only the 'major' and 'minor' PitchProfile attributes within the supplied key profile are used. If either attribute does not exist, a value error is raised before training.</p> <p>2.2 Customize training behavior by supplying functions denoting both the neighborhood propagation function and global decay function.</p> <p>2.3 Record a log of information to track the training process. This feature is not implemented completely.</p> </li> <li> <p>Projection of a supplied pitch-class distribution onto a trained SOM.</p> </li> <li> <p>Visualization facilities, primarily:</p> <p>4.1 Visualization of projection from a single pitch-class distribution onto the internal SOM.</p> <p>4.2 Animation of projections from a sequence of pitch-class distributions onto the internal SOM.</p> </li> </ol> <p>The internal data unique to each KeyProfileSOM object is as follows:</p> <ol> <li> <p>SOM structural specifications (output layer dimensions), stored as a 2-tuple of ints specifying the width and height of the SOM output layer.</p> </li> <li> <p>The trained SOM according to the structural specifications, stored as a 3-D numpy array with shape (output_width, output_height, input_length).</p> </li> <li> <p>A list of 2-D coordinates for the trained SOM, where each list element at index i specifies the location of the ith label in the trained SOM. The coordinate is the BMU of the ith pitch's corresponding pitch-class profile in the trained SOM. Note that capital pitches denote major key pitches, while lower-case pitches denote minor key pitches.</p> </li> <li> <p>Training log containing simple training information per update instance of the SOM (for debugging purposes if logging is turned on during training).</p> </li> <li> <p>A name (string identifier) for the SOM that can be optionally specified.</p> </li> </ol> <p>Attributes:</p> <ul> <li> <code>_input_length</code>               (<code>int, class attribute</code>)           \u2013            <p>the number of pitches in a pitch-class distribution, or the number of tonal pitches in a western music system</p> </li> <li> <code>_default_output_dimensions</code>               (<code>Tuple[int], class attribute</code>)           \u2013            <p>output dimensions for the pretrained SOM in the original MATLAB version of miditoolbox</p> </li> <li> <code>_labels</code>               (<code>List[str], class attribute</code>)           \u2013            <p>list of strings denoting the pitch labels</p> </li> </ul> <p>Examples:</p> <p>Load a set of pretrained weights and visualize the pitch-class distribution of a small score:</p> <pre><code>&gt;&gt;&gt; from amads.core.basics import Score\n&gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65, 67, 69, 71, 72])\n&gt;&gt;&gt; from amads.pitch.pcdist1 import pitch_class_distribution_1\n&gt;&gt;&gt; pcdist_of_score = pitch_class_distribution_1(score)\n&gt;&gt;&gt; example_SOM = pretrained_weights_script()\n&gt;&gt;&gt; _ = example_SOM.project_and_visualize(tuple(pcdist_of_score.data),\n...                                       show=False)\n</code></pre> <p>Train a set of weights from a key profile with 'major' and 'minor' attributes with supplied training parameters:</p> <pre><code>&gt;&gt;&gt; training_profile = prof.krumhansl_kessler # from key/profiles.py\n&gt;&gt;&gt; test_SOM = KeyProfileSOM() # default output dimensions used\n&gt;&gt;&gt; _ = test_SOM.train_SOM(training_profile) # use default parameters\n</code></pre> <p>Methods:</p> <ul> <li> <code>save_trained_SOM</code>             \u2013              <p>Save a trained key profile SOM.</p> </li> <li> <code>from_trained_SOM</code>             \u2013              <p>Create a new KeyProfileSOM object containing the trained KeyProfileSOM.</p> </li> <li> <code>update_SOM</code>             \u2013              <p>Update the SOM on the input data based off of the best matching unit.</p> </li> <li> <code>find_best_matching_unit</code>             \u2013              <p>Find best matching unit given a self-organizing map and input data.</p> </li> <li> <code>train_SOM</code>             \u2013              <p>Train a self-organizing map using the given training data and parameters.</p> </li> <li> <code>project_input_onto_SOM</code>             \u2013              <p>Compute the resulting projection weights of the input on a trained SOM.</p> </li> <li> <code>project_and_visualize</code>             \u2013              <p>Project a pitch-class distribution and visualizes it.</p> </li> <li> <code>project_and_animate</code>             \u2013              <p>Animate a collection of pitch-class distributions.</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def __init__(\n    self, output_layer_dimensions: Tuple[int] = _default_output_dimensions\n):\n    self.SOM_output_dims = output_layer_dimensions\n    self.SOM = None\n    # best matching units to each of the corresponding coordinates\n    self.label_coord_list = None\n    self.log_info = []\n    self.name = None\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM-functions","title":"Functions","text":""},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.save_trained_SOM","title":"save_trained_SOM  <code>classmethod</code>","text":"<pre><code>save_trained_SOM(\n    obj: KeyProfileSOM,\n    dir_path: str = \"./\",\n    file_name: str | None = None,\n)\n</code></pre> <p>Save a trained key profile SOM.</p> <p>Raises a value exception if the object does not contain a proper trained SOM or the directory path is not valid.</p> <p>Parameters:</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>@classmethod\ndef save_trained_SOM(\n    cls,\n    obj: \"KeyProfileSOM\",\n    dir_path: str = \"./\",\n    file_name: Optional[str] = None,\n):\n    \"\"\"\n    Save a trained key profile SOM.\n\n    Raises a value exception if the object\n    does not contain a proper trained SOM or the directory path is not valid.\n\n    Parameters\n    ----------\n    obj: KeyProfileSOM\n        Key Profile SOM object containing a trained SOM\n    dir_path: str\n        Path to directory to store the trained SOM (in npz format)\n    file_name: Optional[str]\n        Optional file name argument to save the trained SOM\n    \"\"\"\n\n    if file_name is None:\n        file_name = f\"{obj.name}_data.npz\"\n\n    file_path = os.path.join(dir_path, file_name)\n\n    if obj.SOM is None or not obj.label_coord_list:\n        raise ValueError(\"input SOM is not trained!\")\n\n    np.savez(\n        file_path,\n        SOM=obj.SOM,\n        name=np.array(obj.name),\n        label_coords=np.array(obj.label_coord_list),\n    )\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.save_trained_SOM(obj)","title":"<code>obj</code>","text":"(<code>KeyProfileSOM</code>)           \u2013            <p>Key Profile SOM object containing a trained SOM</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.save_trained_SOM(dir_path)","title":"<code>dir_path</code>","text":"(<code>str</code>, default:                   <code>'./'</code> )           \u2013            <p>Path to directory to store the trained SOM (in npz format)</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.save_trained_SOM(file_name)","title":"<code>file_name</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional file name argument to save the trained SOM</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.from_trained_SOM","title":"from_trained_SOM  <code>classmethod</code>","text":"<pre><code>from_trained_SOM(\n    file_path: str = \"./amads/pitch/key/KrumhanslKessler_SOM_data.npz\",\n) -&gt; KeyProfileSOM\n</code></pre> <p>Create a new KeyProfileSOM object containing the trained KeyProfileSOM.</p> <p>Data is loaded from the specified file.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>KeyProfileSOM</code>           \u2013            <p>Key Profile SOM object containing the trained SOM from the file</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>@classmethod\ndef from_trained_SOM(\n    cls, file_path: str = \"./amads/pitch/key/KrumhanslKessler_SOM_data.npz\"\n) -&gt; \"KeyProfileSOM\":\n    \"\"\"\n    Create a new KeyProfileSOM object containing the trained KeyProfileSOM.\n\n    Data is loaded from the specified file.\n\n    Parameters\n    ----------\n    file_path: str\n        Path to directory containing stored SOM (in npz format)\n\n    Returns\n    -------\n    KeyProfileSOM\n        Key Profile SOM object containing the trained SOM from the file\n    \"\"\"\n    load_table = np.load(file_path)\n    SOM = load_table[\"SOM\"]\n    (dim0, dim1, _) = SOM.shape\n    output_dims = (dim0, dim1)\n    name = str(load_table[\"name\"])\n    label_coord_list = [\n        tuple(coord) for coord in load_table[\"label_coords\"]\n    ]\n\n    obj = KeyProfileSOM(output_dims)\n    obj.SOM = SOM\n    obj.name = name\n    obj.label_coord_list = label_coord_list\n    obj.vmin = np.min(obj.SOM)\n    obj.vmax = np.max(obj.SOM)\n\n    return obj\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.from_trained_SOM(file_path)","title":"<code>file_path</code>","text":"(<code>str</code>, default:                   <code>'./amads/pitch/key/KrumhanslKessler_SOM_data.npz'</code> )           \u2013            <p>Path to directory containing stored SOM (in npz format)</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.update_SOM","title":"update_SOM","text":"<pre><code>update_SOM(\n    best_match: tuple[int],\n    input_data: array,\n    idx: int,\n    neighborhood: Callable[\n        [Tuple[int], Tuple[int], Tuple[int], int], float\n    ],\n    global_decay: Callable[[int], float],\n) -&gt; KeyProfileSOM\n</code></pre> <p>Update the SOM on the input data based off of the best matching unit.</p> <p>Uses the current global training iteration.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>KeyProfileSOM</code>           \u2013            <p>Current object</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def update_SOM(\n    self,\n    best_match: Tuple[int],\n    input_data: np.array,\n    idx: int,\n    neighborhood: Callable[\n        [Tuple[int], Tuple[int], Tuple[int], int], float\n    ],\n    global_decay: Callable[[int], float],\n) -&gt; \"KeyProfileSOM\":\n    \"\"\"\n    Update the SOM on the input data based off of the best matching unit.\n\n    Uses the current global training iteration.\n\n    Parameters\n    ----------\n    best_match: Tuple[int]\n        Coordinate of the best-matching node in the output layer of the\n        self-organizing map and its corresponding connector weights\n        (to the input)\n    input_data: np.array\n        data vector that was selected to train on for the current\n        training iteration\n    idx: int\n        Current training iteration in training session.\n    neighborhood: Callable[[Tuple[int], Tuple[int], Tuple[int], int], float]\n        Neighborhood function, denoting the update rate component depending\n        on coordinate differences to the best matching unit and training\n        iteration.\n    global_decay: Callable[[int], float]\n        Global decay function, denoting the update rate component dependent\n        solely on training iteration.\n\n    Returns\n    -------\n    KeyProfileSOM\n        Current object\n    \"\"\"\n    if input_data.shape != (KeyProfileSOM._input_length,):\n        raise ValueError(\n            f\"input {input_data} is of invalid shape {input_data.shape}\"\n        )\n\n    dim0, dim1, input_length = self.SOM.shape\n    if input_length != KeyProfileSOM._input_length:\n        raise ValueError(\n            f\"Corrupted SOM =\\n{self.SOM}\\nof shape {self.SOM.shape}\"\n        )\n    if len(best_match) != 2:\n        raise ValueError(f\"Invalid best matching unit coords {best_match}\")\n\n    # update all weights in the SOM based on competitive learning\n    # (where the only things that truly matter in a training iteration\n    # is the BMU and the input data)\n    for i in range(dim0):\n        for j in range(dim1):\n            rate = global_decay(idx) * neighborhood(\n                (i, j), best_match, self.SOM.shape, idx\n            )\n            self.SOM[i, j, :] = (1 - rate) * self.SOM[\n                i, j, :\n            ] + rate * input_data\n\n    return self\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.update_SOM(best_match)","title":"<code>best_match</code>","text":"(<code>tuple[int]</code>)           \u2013            <p>Coordinate of the best-matching node in the output layer of the self-organizing map and its corresponding connector weights (to the input)</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.update_SOM(input_data)","title":"<code>input_data</code>","text":"(<code>array</code>)           \u2013            <p>data vector that was selected to train on for the current training iteration</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.update_SOM(idx)","title":"<code>idx</code>","text":"(<code>int</code>)           \u2013            <p>Current training iteration in training session.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.update_SOM(neighborhood)","title":"<code>neighborhood</code>","text":"(<code>Callable[[Tuple[int], Tuple[int], Tuple[int], int], float]</code>)           \u2013            <p>Neighborhood function, denoting the update rate component depending on coordinate differences to the best matching unit and training iteration.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.update_SOM(global_decay)","title":"<code>global_decay</code>","text":"(<code>Callable[[int], float]</code>)           \u2013            <p>Global decay function, denoting the update rate component dependent solely on training iteration.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.find_best_matching_unit","title":"find_best_matching_unit","text":"<pre><code>find_best_matching_unit(input_data: array) -&gt; tuple[int]\n</code></pre> <p>Find best matching unit given a self-organizing map and input data.</p> <p>Finds the coordinate of the output node whose weights has the smallest Euclidean distance from the input data.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[int]</code>           \u2013            <p>Coordinates of the node that has the connector weights with the smallest Euclidean distance to the input data</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def find_best_matching_unit(self, input_data: np.array) -&gt; Tuple[int]:\n    \"\"\"\n    Find best matching unit given a self-organizing map and input data.\n\n    Finds the coordinate of the output node whose weights has the smallest\n    Euclidean distance from the input data.\n\n    Parameters\n    ----------\n    input_data: np.array\n        1-D data vector of input length containing the input weights\n\n    Returns\n    -------\n    Tuple[int]\n        Coordinates of the node that has the connector weights with the\n        smallest Euclidean distance to the input data\n    \"\"\"\n    # input data length needs to match\n    if input_data.shape != (KeyProfileSOM._input_length,):\n        raise ValueError(\n            f\"input {input_data} is of invalid shape {input_data.shape}\"\n        )\n\n    dim0, dim1, input_length = self.SOM.shape\n    if input_length != KeyProfileSOM._input_length:\n        raise ValueError(\n            f\"Corrupted SOM =\\n{self.SOM}\\nof shape {self.SOM.shape}\"\n        )\n\n    best_i, best_j = 0, 0\n    best_distance = euclidean_distance(\n        input_data, self.SOM[best_i, best_j, :], False\n    )\n    for i in range(dim0):\n        for j in range(dim1):\n            distance = euclidean_distance(\n                input_data, self.SOM[i, j, :], False\n            )\n            if best_distance &gt; distance:\n                best_i, best_j = i, j\n                best_distance = distance\n    return (best_i, best_j)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.find_best_matching_unit(input_data)","title":"<code>input_data</code>","text":"(<code>array</code>)           \u2013            <p>1-D data vector of input length containing the input weights</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.train_SOM","title":"train_SOM","text":"<pre><code>train_SOM(\n    profile: KeyProfile = krumhansl_kessler,\n    max_iterations: int = 24 * 64,\n    neighborhood: Callable[\n        [Tuple[int], Tuple[int], Tuple[int], int], float\n    ] = keysom_toroid_clamped,\n    global_decay: Callable[\n        [int], float\n    ] = keysom_stepped_log_inverse_decay,\n    weights_initialization: Callable[\n        [Tuple[int, int, int]], array\n    ] = random_SOM_init,\n    log_training: bool = False,\n) -&gt; KeyProfileSOM\n</code></pre> <p>Train a self-organizing map using the given training data and parameters.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>KeyProfileSOM</code>           \u2013            <p>Current object</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def train_SOM(\n    self,\n    profile: prof.KeyProfile = prof.krumhansl_kessler,\n    max_iterations: int = 24 * 64,\n    neighborhood: Callable[\n        [Tuple[int], Tuple[int], Tuple[int], int], float\n    ] = keysom_toroid_clamped,\n    global_decay: Callable[[int], float] = keysom_stepped_log_inverse_decay,\n    weights_initialization: Callable[\n        [Tuple[int, int, int]], np.array\n    ] = random_SOM_init,\n    log_training: bool = False,\n) -&gt; \"KeyProfileSOM\":\n    \"\"\"\n    Train a self-organizing map using the given training data and parameters.\n\n    Parameters\n    ----------\n    profile: prof.KeyProfile\n        The key profile to use for analysis.\n    max_iterations: int\n        The number of iterations to train the self-organizing map for\n\n        Neighborhood function, denoting the update rate component dependent\n        on coordinate differences to the best matching unit and training\n        iteration.\n    global_decay: Callable[[int], float]\n        Global decay function, denoting the update rate component dependent\n        solely on training iteration.\n    weights_initialization: Callable[[Tuple[int, int, int]], np.array]\n        SOM weights initialization function, returning a numpy array of the\n        initial SOM weights dependent on its input shape.\n    log_training: bool\n        Indicator flag for whether or not to keep a semi-detailed log of the\n        training process\n\n    Returns\n    -------\n    KeyProfileSOM\n        Current object\n    \"\"\"\n    attribute_names = [\"major\", \"minor\"]\n\n    data_multiplier = 6\n\n    # multiplied by 6 which is the expected value of randomly initializing\n    # the values of each neuron's map weights to a random value between\n    # [0, 1]\n    # think of this as \"normalizing\" the input data to the same scale as\n    # the original map weights\n\n    # this will not affect the visualization of projections of a pitch-class\n    # distribution in any way, since we can simply multiply the SOM\n    # globally by the requisite multiplier after it is trained\n    # in order to obtain normalized neuron weights.\n    list_of_canonicals = [\n        profile[attribute].normalize().as_canonical_matrix()\n        * data_multiplier\n        for attribute in attribute_names\n    ]\n    self.name = profile.name + \"_SOM\"\n\n    # stack into matrix representation to satisfy _data_selector argument\n    # specification\n    # Additionally, training data here is ordered (per row) in chromatic\n    # scale order, first in major pitch profile weights then minor pitch\n    # profile weights.\n    training_data = np.vstack(list_of_canonicals)\n\n    # 12 is the input length\n    # 36 is data width/feature width/something else?\n    # 24 is the 12 major and 12 minor keys for the profile data\n    #\n    # SOM indices have been rearranged from matlab version for convenience\n    # in this implementation\n    self.SOM = weights_initialization(\n        (*self.SOM_output_dims, KeyProfileSOM._input_length)\n    )\n\n    for training_idx in range(max_iterations):\n        data_idx, data_vector = self._data_selector(\n            training_data, training_idx\n        )\n        best_match = self.find_best_matching_unit(data_vector)\n        self.update_SOM(\n            best_match=best_match,\n            input_data=data_vector,\n            idx=training_idx,\n            neighborhood=neighborhood,\n            global_decay=global_decay,\n        )\n        if log_training:\n            self._log_training_iteration(training_idx, data_idx, best_match)\n\n    self.label_coord_list = []\n    # need to find BMU to each of the key profile input vectors in the trained SOM\n    # since training_data is already ordered properly, we just need to find BMU\n    # over all the inputs\n    for label, input in zip(KeyProfileSOM._labels, training_data):\n        best_match = self.find_best_matching_unit(input)\n        self.label_coord_list.append(best_match)\n        # print(f\"label: {label}, best_match: {best_match}\")\n\n    # setting colorbar scale here\n    self.vmin = np.min(self.SOM)\n    self.vmax = np.max(self.SOM)\n\n    return self\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.train_SOM(profile)","title":"<code>profile</code>","text":"(<code>KeyProfile</code>, default:                   <code>krumhansl_kessler</code> )           \u2013            <p>The key profile to use for analysis.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.train_SOM(max_iterations)","title":"<code>max_iterations</code>","text":"(<code>int</code>, default:                   <code>24 * 64</code> )           \u2013            <p>The number of iterations to train the self-organizing map for</p> <p>Neighborhood function, denoting the update rate component dependent on coordinate differences to the best matching unit and training iteration.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.train_SOM(global_decay)","title":"<code>global_decay</code>","text":"(<code>Callable[[int], float]</code>, default:                   <code>keysom_stepped_log_inverse_decay</code> )           \u2013            <p>Global decay function, denoting the update rate component dependent solely on training iteration.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.train_SOM(weights_initialization)","title":"<code>weights_initialization</code>","text":"(<code>Callable[[Tuple[int, int, int]], array]</code>, default:                   <code>random_SOM_init</code> )           \u2013            <p>SOM weights initialization function, returning a numpy array of the initial SOM weights dependent on its input shape.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.train_SOM(log_training)","title":"<code>log_training</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Indicator flag for whether or not to keep a semi-detailed log of the training process</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_input_onto_SOM","title":"project_input_onto_SOM","text":"<pre><code>project_input_onto_SOM(input_data: array) -&gt; array\n</code></pre> <p>Compute the resulting projection weights of the input on a trained SOM.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>array[float]</code>           \u2013            <p>Returns a 2-D numpy array that contains the projection of the input data onto the self-organizing map.</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def project_input_onto_SOM(self, input_data: np.array) -&gt; np.array:\n    \"\"\"\n    Compute the resulting projection weights of the input on a trained SOM.\n\n    Parameters\n    ----------\n    input_data: np.array\n        1-D data vector of input length containing the input weights\n\n    Returns\n    -------\n    np.array[float]\n        Returns a 2-D numpy array that contains the projection of the input\n        data onto the self-organizing map.\n    \"\"\"\n    # input data length needs to match\n    if input_data.shape != (KeyProfileSOM._input_length,):\n        raise ValueError(\n            f\"input {input_data} is of invalid shape {input_data.shape}\"\n        )\n\n    dim0, dim1, input_length = self.SOM.shape\n    if input_length != KeyProfileSOM._input_length:\n        raise ValueError(\n            f\"Corrupted SOM =\\n{self.SOM}\\nof shape {self.SOM.shape}\"\n        )\n    # projection of input data onto current self-organizing map\n    # matrix multiplication (tensor extension)\n    application = self.SOM @ input_data\n    assert application.shape == (dim0, dim1)\n    return application\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_input_onto_SOM(input_data)","title":"<code>input_data</code>","text":"(<code>array</code>)           \u2013            <p>1-D data vector of input length containing the input weights</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize","title":"project_and_visualize","text":"<pre><code>project_and_visualize(\n    input: tuple[float],\n    has_legend: bool = True,\n    scaled_legend: bool = False,\n    font_size: float | str | None = None,\n    color_map: str | LinearSegmentedColormap | None = None,\n    show: bool = True,\n) -&gt; tuple[array, Figure]\n</code></pre> <p>Project a pitch-class distribution and visualizes it.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[array, Figure]</code>           \u2013            <p>Returns a tuple consisting of:</p> <ol> <li>the 2-D numpy array that contains the projection of the input     data onto the self-organizing map.</li> <li>Matplotlib figure that contains the axes with a plot of the     projection</li> </ol> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def project_and_visualize(\n    self,\n    input: Tuple[float],\n    has_legend: bool = True,\n    scaled_legend: bool = False,\n    font_size: Optional[Union[float, str]] = None,\n    color_map: Optional[Union[str, mcolors.LinearSegmentedColormap]] = None,\n    show: bool = True,\n) -&gt; Tuple[np.array, Figure]:\n    \"\"\"\n    Project a pitch-class distribution and visualizes it.\n\n    Parameters\n    ----------\n    input: Tuple[float]\n        a singular pitch-class distribution, in which case the visualization\n        is simply a heatmap of its projection onto the trained SOM.\n    has_legend: bool\n        Whether or not the plot should include a color legend\n    scaled_legend: bool\n        Whether or not the color legend scales with the projection's minimum\n        and maximum, or (by default) scales with the trained SOM's global\n        minimum and maximum.\n    font_size: Optional[Union[float, str]] = None,\n        Font size, either:\n        (1) Font size of the labels (in points) or a string option from\n        matplotlib\n        (2) None for the default font size provided by matplotlib\n    color_map: Optional[Union[str, mcolors.LinearSegmentedColormap]]\n        Color map, either:\n         (1) a color map provided by the matplotlib package\n         (2) a custom linear segmented colormap\n         (3) None for the default color scheme provided by matplotlib\n    show: bool\n        Whether or not we suspend execution and display the plot before\n        returning from this function\n\n    Returns\n    -------\n    Tuple[np.array, Figure]\n        Returns a tuple consisting of:\n\n        1. the 2-D numpy array that contains the projection of the input\n            data onto the self-organizing map.\n        2. Matplotlib figure that contains the axes with a plot of the\n            projection\n    \"\"\"\n    if not input:\n        raise ValueError(\"empty input not allowed\")\n    if isinstance(input[0], Tuple):\n        raise ValueError(\"only takes pitch-class distribution data\")\n    # prep data\n    projection = self.project_input_onto_SOM(np.array(input))\n\n    dim0, dim1, _ = self.SOM.shape\n    assert projection.shape == (dim0, dim1)\n\n    fig, ax = plt.subplots()\n\n    # there should be some thought put into the actual interpolation formula\n    # cax = ax.contourf(projection)\n    cax = ax.imshow(\n        projection,\n        aspect=\"auto\",\n        origin=\"lower\",\n        interpolation=\"nearest\",\n        cmap=color_map,\n    )\n    assert len(self.label_coord_list) == len(KeyProfileSOM._labels)\n\n    # key labels in the plot\n    for (i, j), label in zip(self.label_coord_list, KeyProfileSOM._labels):\n        ax.text(\n            j,\n            i,\n            label,\n            ha=\"center\",\n            va=\"center\",\n            color=\"w\",\n            fontsize=font_size,\n        )\n\n    # legend\n    if has_legend:\n        actual_vmin, actual_vmax = self.vmin, self.vmax\n\n        if scaled_legend:\n            actual_vmin = np.min(projection)\n            actual_vmax = np.max(projection)\n\n        cax.set_clim(actual_vmin, actual_vmax)\n        fig.colorbar(cax, ax=ax, label=\"Proportion\")\n\n    if show:\n        plt.show()\n\n    return projection, fig\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize(input)","title":"<code>input</code>","text":"(<code>tuple[float]</code>)           \u2013            <p>a singular pitch-class distribution, in which case the visualization is simply a heatmap of its projection onto the trained SOM.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize(has_legend)","title":"<code>has_legend</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not the plot should include a color legend</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize(scaled_legend)","title":"<code>scaled_legend</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether or not the color legend scales with the projection's minimum and maximum, or (by default) scales with the trained SOM's global minimum and maximum.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize(font_size)","title":"<code>font_size</code>","text":"(<code>float | str | None</code>, default:                   <code>None</code> )           \u2013            <p>Font size, either: (1) Font size of the labels (in points) or a string option from matplotlib (2) None for the default font size provided by matplotlib</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize(color_map)","title":"<code>color_map</code>","text":"(<code>str | LinearSegmentedColormap | None</code>, default:                   <code>None</code> )           \u2013            <p>Color map, either:  (1) a color map provided by the matplotlib package  (2) a custom linear segmented colormap  (3) None for the default color scheme provided by matplotlib</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_visualize(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not we suspend execution and display the plot before returning from this function</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_animate","title":"project_and_animate","text":"<pre><code>project_and_animate(\n    input_list: list[tuple[float]],\n    has_legend: bool = True,\n    font_size: float | str = 10.0,\n    color_map: str | LinearSegmentedColormap | None = None,\n    show: bool = True,\n) -&gt; tuple[list[array], FuncAnimation]\n</code></pre> <p>Animate a collection of pitch-class distributions.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>tuple[list[array], ArtistAnimation]</code>           \u2013            <ol> <li>A list of 2-D numpy arrays that contain the sequence of     projections from the list of input data onto the     self-organizing map</li> <li>The artist animation object of these data</li> </ol> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def project_and_animate(\n    self,\n    input_list: List[Tuple[float]],\n    has_legend: bool = True,\n    font_size: Union[float, str] = 10.0,\n    color_map: Optional[Union[str, mcolors.LinearSegmentedColormap]] = None,\n    show: bool = True,\n) -&gt; Tuple[List[np.array], FuncAnimation]:\n    \"\"\"\n    Animate a collection of pitch-class distributions.\n\n    Parameters\n    ----------\n    input_list: List[Tuple[float]]\n        a list of pitch-class distributions, in which case the visualization\n        is an animation of the sequence of projections of the pitch-class\n        distributions onto the trained SOM.\n    has_legend: bool\n        Whether or not the plot should include a color legend\n    font_size: Union[float, str]\n        Font size, either:\n\n        1. Font size of the labels (in points) or a string option from\n            matplotlib\n        2. None for the default font size provided by matplotlib\n    color_map: Optional[Union[str, mcolors.LinearSegmentedColormap]]\n        Color map, either:\n\n         1. a color map provided by the matplotlib package\n         2. a custom linear segmented colormap\n             (see matplotlib.LinearSegmentedColormap for more details)\n         3. None for the default color scheme provided by matplotlib\n    show: bool\n        Whether or not we suspend execution and display the plot before\n        returning from this function\n\n    Returns\n    -------\n    Tuple[List[np.array], ArtistAnimation]\n\n        1. A list of 2-D numpy arrays that contain the sequence of\n            projections from the list of input data onto the\n            self-organizing map\n        2. The artist animation object of these data\n    \"\"\"\n    # visualize\n    projection_list = [\n        self.project_input_onto_SOM(np.array(input)) for input in input_list\n    ]\n    print(projection_list)\n    if not projection_list:\n        print(\"Warning! No distributions provided to animate!\")\n        return\n\n    fig, ax = plt.subplots()\n\n    cax = ax.imshow(\n        projection_list[0],\n        aspect=\"auto\",\n        origin=\"lower\",\n        interpolation=\"nearest\",\n        cmap=color_map,\n    )\n    cax.set_clim(self.vmin, self.vmax)\n    # key labels in the plot\n    for (i, j), label in zip(self.label_coord_list, KeyProfileSOM._labels):\n        ax.text(\n            j,\n            i,\n            label,\n            ha=\"center\",\n            va=\"center\",\n            color=\"w\",\n            fontsize=font_size,\n        )\n    if has_legend:\n        fig.colorbar(cax, ax=ax, label=\"Score Expectation\", ticks=None)\n\n    def frame_func(frame_idx):\n        idx = frame_idx % len(projection_list)\n        cax.set_data(projection_list[idx])\n\n    ani = FuncAnimation(\n        fig,\n        frame_func,\n        frames=len(input_list),\n        interval=500,\n        repeat=True,\n        repeat_delay=2000,\n    )\n\n    if show:\n        plt.show()\n\n    return projection_list, ani\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_animate(input_list)","title":"<code>input_list</code>","text":"(<code>list[tuple[float]]</code>)           \u2013            <p>a list of pitch-class distributions, in which case the visualization is an animation of the sequence of projections of the pitch-class distributions onto the trained SOM.</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_animate(has_legend)","title":"<code>has_legend</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not the plot should include a color legend</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_animate(font_size)","title":"<code>font_size</code>","text":"(<code>float | str</code>, default:                   <code>10.0</code> )           \u2013            <p>Font size, either:</p> <ol> <li>Font size of the labels (in points) or a string option from     matplotlib</li> <li>None for the default font size provided by matplotlib</li> </ol>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_animate(color_map)","title":"<code>color_map</code>","text":"(<code>str | LinearSegmentedColormap | None</code>, default:                   <code>None</code> )           \u2013            <p>Color map, either:</p> <ol> <li>a color map provided by the matplotlib package</li> <li>a custom linear segmented colormap      (see matplotlib.LinearSegmentedColormap for more details)</li> <li>None for the default color scheme provided by matplotlib</li> </ol>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.KeyProfileSOM.project_and_animate(show)","title":"<code>show</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether or not we suspend execution and display the plot before returning from this function</p>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.pretrained_weights_script","title":"pretrained_weights_script","text":"<pre><code>pretrained_weights_script() -&gt; KeyProfileSOM\n</code></pre> <p>Simple script that generates a SOM from a hand-crafted initial SOM.</p> <p>This gives us a SOM with key labels in a determinstic grid adjacent to the axes of the grid.</p> <p>Returns:</p> <ul> <li> <code>KeyProfileSOM</code>           \u2013            <p>Object with training weights</p> </li> </ul> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def pretrained_weights_script() -&gt; KeyProfileSOM:\n    \"\"\"\n    Simple script that generates a SOM from a hand-crafted initial SOM.\n\n    This gives us a SOM with key labels in a determinstic grid adjacent to the\n    axes of the grid.\n\n    Returns\n    -------\n    KeyProfileSOM\n        Object with training weights\n    \"\"\"\n\n    # for the pretrained version, hand-craft initialization value for the\n    # SOM so that we get the rotation and orientation desired for the resulting\n    # trained weights\n    obj = KeyProfileSOM()\n    if obj.SOM_output_dims != KeyProfileSOM._default_output_dimensions:\n        raise RuntimeError(\"invalid output dimensions for default SOM\")\n\n    obj.train_SOM(weights_initialization=handcrafted_SOM_init)\n\n    return obj\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.zero_SOM_init","title":"zero_SOM_init","text":"<pre><code>zero_SOM_init(shape: tuple[int, int, int]) -&gt; array\n</code></pre> <p>Constructs all-zero self-organizing map weights.</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def zero_SOM_init(shape: Tuple[int, int, int]) -&gt; np.array:\n    \"\"\"\n    Constructs all-zero self-organizing map weights.\n    \"\"\"\n    # zero SOM init...\n    return np.zeros(shape)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.random_SOM_init","title":"random_SOM_init","text":"<pre><code>random_SOM_init(shape: tuple[int, int, int]) -&gt; array\n</code></pre> <p>Constructs random self-organizing map weights.</p> <p>Initial values are between 0 and 0.5 inclusive.</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def random_SOM_init(shape: Tuple[int, int, int]) -&gt; np.array:\n    \"\"\"\n    Constructs random self-organizing map weights.\n\n    Initial values are between 0 and 0.5 inclusive.\n    \"\"\"\n    return np.random.rand(*shape) / 2\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.handcrafted_SOM_init","title":"handcrafted_SOM_init","text":"<pre><code>handcrafted_SOM_init(shape: tuple[int, int, int]) -&gt; array\n</code></pre> <p>Bespoke initialization for the pretrained weights.</p> <p>These initial weights are intended to bias the resulting SOM to a nicely symmetrical map with well-placed keys.</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def handcrafted_SOM_init(shape: Tuple[int, int, int]) -&gt; np.array:\n    \"\"\"\n    Bespoke initialization for the pretrained weights.\n\n    These initial weights are intended to bias the resulting SOM\n    to a nicely symmetrical map with well-placed keys.\n    \"\"\"\n    if shape != (\n        *KeyProfileSOM._default_output_dimensions,\n        KeyProfileSOM._input_length,\n    ):\n        raise ValueError(f\"invalid shape {shape} for handcrafted SOM\")\n\n    kkprof = prof.krumhansl_kessler\n    list_of_majors = kkprof[\"major\"].normalize().as_canonical_matrix()\n    list_of_minors = kkprof[\"minor\"].normalize().as_canonical_matrix()\n\n    max_row, max_col, _ = shape\n\n    init_weights = np.zeros(shape)\n\n    # per \"cell\" arrangement, where each cell contains a major key label and its\n    # corresponding minor key label horizontally adjacent to it\n\n    # arithmetic for a 4x3 grid of cells in a 24x36 SOM\n    row_multiplier = 6\n    max_row_cells = max_row // row_multiplier\n    row_offset = 3\n    # twice to accomodate a cell containing 12\n    col_multiplier = 6 * 2\n    max_col_cells = max_col // col_multiplier\n    col_major_offset = 3\n    col_minor_offset = col_major_offset + 6\n\n    key_idx = 0\n    # the end result should be a rectangular grid in the labels\n    for row_cell_idx in range(max_row_cells):\n        for col_cell_idx in range(max_col_cells):\n            # imprint major key\n            major_col_idx = col_cell_idx * col_multiplier + col_major_offset\n            major_row_idx = row_cell_idx * row_multiplier + row_offset\n            init_weights[major_row_idx, major_col_idx] = list_of_majors[key_idx]\n\n            # imprint minor key\n            minor_col_idx = col_cell_idx * col_multiplier + col_minor_offset\n            minor_row_idx = row_cell_idx * row_multiplier + row_offset\n            init_weights[minor_row_idx, minor_col_idx] = list_of_minors[key_idx]\n\n            # increment key_idx\n            key_idx += 1\n\n    assert key_idx == 12\n\n    return init_weights\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.keysom_inverse_decay","title":"keysom_inverse_decay","text":"<pre><code>keysom_inverse_decay(idx: int) -&gt; float\n</code></pre> <p>Computes inverse decay global learning rate for a given iteration.</p> <p>Inverse to the current learning iteration...</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def keysom_inverse_decay(idx: int) -&gt; float:\n    \"\"\"\n    Computes inverse decay global learning rate for a given iteration.\n\n    Inverse to the current learning iteration...\n    \"\"\"\n    assert idx &gt;= 0\n    if idx == 0:\n        return 1\n    else:\n        return 1 / (2 * idx)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.keysom_stepped_inverse_decay","title":"keysom_stepped_inverse_decay","text":"<pre><code>keysom_stepped_inverse_decay(idx: int) -&gt; float\n</code></pre> <p>Compute stepped decay global learning rate for a given iteration.</p> <p>Inverse to a stepped multiplier of the current learning iteration...</p> <p>In this case it's stepped to allow all inputs to deterministically pass during training (for 12 major and 12 minor key profile entries specifically)</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def keysom_stepped_inverse_decay(idx: int) -&gt; float:\n    \"\"\"\n    Compute stepped decay global learning rate for a given iteration.\n\n    Inverse to a stepped multiplier of the current learning iteration...\n\n    In this case it's stepped to allow all inputs to deterministically\n    pass during training (for 12 major and 12 minor key profile entries\n    specifically)\n    \"\"\"\n    step = idx // (12 * 2)\n    if step == 0:\n        return 1\n    else:\n        return 1 / (2 * step)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.keysom_stepped_log_inverse_decay","title":"keysom_stepped_log_inverse_decay","text":"<pre><code>keysom_stepped_log_inverse_decay(idx: int) -&gt; float\n</code></pre> <p>Compute stepped log inverse decay global learning rate for a given iteration.</p> <p>Log inverse to a stepped multiplier of the current learning iteration...</p> <p>In this case it's stepped to allow all inputs to deterministically pass during training (for 12 major and 12 minor key profile entries specifically)</p> <p>So why does inverse log work well? I like to think of it as the summation of traversing all nodes of a subtree of an imaginary sparse information tree. Where each layer of the information tree provides inverse decaying returns to the whole tree. This justification is very stretched though. Namely, each additional data point fed provides an opportunity to add another \"symbol\" to the intrinsic learned \"alphabet\" of the internal representation of the SOM.</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def keysom_stepped_log_inverse_decay(idx: int) -&gt; float:\n    \"\"\"\n    Compute stepped log inverse decay global learning rate for a given iteration.\n\n    Log inverse to a stepped multiplier of the current learning iteration...\n\n    In this case it's stepped to allow all inputs to deterministically\n    pass during training (for 12 major and 12 minor key profile entries\n    specifically)\n\n    So why does inverse log work well? I like to think of it as the summation\n    of traversing all nodes of a subtree of an imaginary sparse information tree.\n    Where each layer of the information tree provides inverse decaying\n    returns to the whole tree.\n    This justification is very stretched though.\n    Namely, each additional data point fed provides an opportunity to add\n    another \"symbol\" to the intrinsic learned \"alphabet\" of the internal\n    representation of the SOM.\n    \"\"\"\n    step = idx // (12 * 2)\n    if step == 0:\n        return 1\n    else:\n        return 1 / math.log2(step + 2)\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.keysom_centroid_euclidean","title":"keysom_centroid_euclidean","text":"<pre><code>keysom_centroid_euclidean(\n    coord: tuple[int],\n    best_match: tuple[int],\n    shape: tuple[int],\n    idx: int,\n) -&gt; float\n</code></pre> <p>Neighborhood propagation update function.</p> <p>Exponential decay based off of Eucliean distance on a 2-D plane assuming the SOM output layer is a 2-D flat plane</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def keysom_centroid_euclidean(\n    coord: Tuple[int], best_match: Tuple[int], shape: Tuple[int], idx: int\n) -&gt; float:\n    \"\"\"\n    Neighborhood propagation update function.\n\n    Exponential decay based off of Eucliean distance on a 2-D plane\n    assuming the SOM output layer is a 2-D flat plane\n    \"\"\"\n    distance = euclidean_distance(coord, best_match, False)\n\n    # 0.95 is purely empirical. Honestly another value might be better\n    if distance == 0:\n        return 1\n    else:\n        return (0.95) ** distance\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.keysom_toroid_euclidean","title":"keysom_toroid_euclidean","text":"<pre><code>keysom_toroid_euclidean(\n    coord: tuple[int],\n    best_match: tuple[int],\n    shape: tuple[int],\n    idx: int,\n) -&gt; float\n</code></pre> <p>Neighborhood propagation update function.</p> <p>Exponential decay based off of Eucliean distance on a toroid assuming the SOM output layer is a projection of a toroid onto a 2-D flat plane</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def keysom_toroid_euclidean(\n    coord: Tuple[int], best_match: Tuple[int], shape: Tuple[int], idx: int\n) -&gt; float:\n    \"\"\"\n    Neighborhood propagation update function.\n\n    Exponential decay based off of Eucliean distance on a toroid\n    assuming the SOM output layer is a projection of a toroid onto a\n    2-D flat plane\n    \"\"\"\n    num_rows, num_cols, input_length = shape\n    # these are easy to follow since i, j are convention\n    # and so is i0, j0\n    i, j = coord\n    i0, j0 = best_match\n    diff_row = abs(i - i0)\n    diff_col = abs(j - j0)\n    toroid_diff_row = min(diff_row, num_rows - diff_row)\n    toroid_diff_col = min(diff_col, num_cols - diff_col)\n    distance = math.sqrt(toroid_diff_row**2 + toroid_diff_col**2)\n    if distance == 0:\n        return 1\n    else:\n        return (0.9) ** distance\n</code></pre>"},{"location":"reference/pitch/key/#amads.pitch.key.keysomdata.keysom_toroid_clamped","title":"keysom_toroid_clamped","text":"<pre><code>keysom_toroid_clamped(\n    coord: tuple[int],\n    best_match: tuple[int],\n    shape: tuple[int],\n    idx: int,\n) -&gt; float\n</code></pre> <p>Neighborhood propagation update function.</p> <p>Same behavior as keysom_toroid_euclidean (see for more details), except distances past a certain radius is clamped to 0.0001.</p> Source code in <code>amads/pitch/key/keysomdata.py</code> <pre><code>def keysom_toroid_clamped(\n    coord: Tuple[int], best_match: Tuple[int], shape: Tuple[int], idx: int\n) -&gt; float:\n    \"\"\"\n    Neighborhood propagation update function.\n\n    Same behavior as keysom_toroid_euclidean (see for more details),\n    except distances past a certain radius is clamped to 0.0001.\n    \"\"\"\n    num_rows, num_cols, input_length = shape\n    # these are easy to follow since i, j are convention\n    # and so is i0, j0\n    i, j = coord\n    i0, j0 = best_match\n    diff_row = abs(i - i0)\n    diff_col = abs(j - j0)\n    toroid_diff_row = min(diff_row, num_rows - diff_row)\n    toroid_diff_col = min(diff_col, num_cols - diff_col)\n    distance = math.sqrt(toroid_diff_row**2 + toroid_diff_col**2)\n\n    # same logic applies to clamp radius as the global learning decay rate.\n    # Namely, each additional data point fed provides an opportunity to add\n    # another \"symbol\" to the intrinsic learned \"alphabet\" of the internal\n    # representation of the SOM.\n    # diminishing returns...\n    radius = 36.0 * (1 / math.log2(idx // 24 + 2))\n\n    if distance &gt; radius:\n        return 0.0001\n    elif distance == 0:\n        return 1.0\n    else:\n        return (0.9) ** distance\n</code></pre>"},{"location":"reference/pitch/pitches/","title":"Pitch Distributions","text":""},{"location":"reference/pitch/pitches/#amads.pitch.pcdist1.pitch_class_distribution_1","title":"pitch_class_distribution_1","text":"<pre><code>pitch_class_distribution_1(\n    score: Score,\n    name: str = \"Pitch Class Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution\n</code></pre> <p>Calculate the pitch-class distribution of a note collection.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>A 12-element distribution representing the probabilities of each pitch class (C, C#, D, D#, E, F, F#, G, G#, A, A#, B). If the score is empty, the function returns a list with all elements set to zero.</p> </li> </ul> Source code in <code>amads/pitch/pcdist1.py</code> <pre><code>def pitch_class_distribution_1(\n    score: Score,\n    name: str = \"Pitch Class Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution:\n    \"\"\"\n    Calculate the pitch-class distribution of a note collection.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze\n    name : str\n        Name for the distribution; plot title if plotted.\n    weighted : bool, optional\n        If True, weight the pitch-class distribution by note durations\n        in seconds that are modified according to Parncutt's durational\n        accent model (1994), by default True.\n    miditoolbox_compatible : bool\n        Matlab MIDI Toolbox avoids zero division by dividing counts\n        by the total count plus (1e-12 times the number of bins).\n        True enables this behavior. Default is False, which simply skips\n        division when the total count is zero (this also returns a\n        zero matrix when the count is zero).\n\n    Returns\n    -------\n    Distribution\n        A 12-element distribution representing the probabilities of each\n        pitch class (C, C#, D, D#, E, F, F#, G, G#, A, A#, B). If the score\n        is empty, the function returns a list with all elements set to zero.\n    \"\"\"\n    score = cast(Score, score.merge_tied_notes())\n    if weighted:\n        score.convert_to_seconds()  # need seconds for duraccent calculation\n    initial_value = 1e-12 if miditoolbox_compatible else 0.0\n    bin_centers = [float(i) for i in range(12)]  # 25 bins from -12 to +12\n    xcategories = CHROMATIC_NAMES\n    h = Histogram1D(bin_centers, None, \"linear\", False, initial_value)\n\n    for note in score.find_all(Note):\n        note = cast(Note, note)\n        h.add_point(\n            round(note.pitch_class) % 12, duraccent(note) if weighted else 1.0\n        )\n\n    if miditoolbox_compatible:  # miditoolbox \"normalization\"\n        total = sum(h.bins) + len(h.bins) * 1e-12\n        h.bins = [b / total for b in h.bins]\n    else:  # normalize normally\n        h.normalize()\n\n    # xcategories is List[str], but Distribution takes int | float | str\n    return Distribution(\n        name,\n        h.bins,\n        \"pitch_class\",\n        [12],\n        xcategories,  # type: ignore\n        \"Pitch Class\",\n        None,\n        \"Proportion\",\n    )\n</code></pre>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist1.pitch_class_distribution_1(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist1.pitch_class_distribution_1(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Pitch Class Distribution'</code> )           \u2013            <p>Name for the distribution; plot title if plotted.</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist1.pitch_class_distribution_1(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, weight the pitch-class distribution by note durations in seconds that are modified according to Parncutt's durational accent model (1994), by default True.</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist1.pitch_class_distribution_1(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Matlab MIDI Toolbox avoids zero division by dividing counts by the total count plus (1e-12 times the number of bins). True enables this behavior. Default is False, which simply skips division when the total count is zero (this also returns a zero matrix when the count is zero).</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist2.pitch_class_distribution_2","title":"pitch_class_distribution_2","text":"<pre><code>pitch_class_distribution_2(\n    score: Score,\n    name: str = \"Pitch Class Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution\n</code></pre> <p>Returns the 2nd order pitch-class distribution of a musical score.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>A 12x12 distribution representing the transition probabilities of each pitch class (C, C#, D, D#, E, F, F#, G, G#, A, A#, B). If the score is empty, the function returns a distribution with all elements set to zero.</p> </li> </ul> Source code in <code>amads/pitch/pcdist2.py</code> <pre><code>def pitch_class_distribution_2(\n    score: Score,\n    name: str = \"Pitch Class Distribution\",\n    weighted: bool = True,\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution:\n    \"\"\"Returns the 2nd order pitch-class distribution of a musical score.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze\n    name : str\n        Name for the distribution; plot title if plotted.\n    weighted : bool, optional\n        If True, weight the pitch-class distribution by note durations\n        in seconds that are modified according to Parncutt's durational\n        accent model (1994), by default True.\n    miditoolbox_compatible : bool\n        Matlab MIDI Toolbox avoids zero division by dividing counts\n        by the total count plus (1e-12 times the number of bins).\n        True enables this behavior. Default is False, which simply skips\n        division when the total count is zero (this also returns a\n        zero matrix when the count is zero).\n\n    Returns\n    -------\n    Distribution\n        A 12x12 distribution representing the transition probabilities of\n        each pitch class (C, C#, D, D#, E, F, F#, G, G#, A, A#, B). If the\n        score is empty, the function returns a distribution with all\n        elements set to zero.\n    \"\"\"\n    score = cast(Score, score.merge_tied_notes())\n    if weighted:\n        score.convert_to_seconds()  # need seconds for duraccent calculation\n    bin_centers = [float(i) for i in range(12)]  # 25 bins from -12 to +12\n    x_categories = CHROMATIC_NAMES\n    h = Histogram2D(bin_centers, None, \"linear\", False)\n\n    # do not count transitions from one part to the next\n    for p in score.find_all(Part):\n        part: Part = cast(Part, p)\n        prev_bin = None\n        prev_pc = None\n        prev_dur = None\n        for n in part.find_all(Note):\n            note: Note = cast(Note, n)\n            pc = note.pitch_class\n            if weighted and prev_pc is not None:\n                dur = duraccent(note)\n                w = prev_dur + dur  # type: ignore\n                prev_dur = dur\n            else:\n                w = 1.0\n            prev_bin = h.add_point_2d(prev_pc, pc, w, prev_bin)\n            prev_pc = pc\n\n    if miditoolbox_compatible:  # miditoolbox \"normalization\"\n        total = sum(h.bins) + len(h.bins) * 1e-12\n        h.bins = [b / total for b in h.bins]\n    else:  # normalize normally\n        h.normalize()\n\n    return Distribution(\n        name,\n        h.bins,\n        \"pitch_class_transition\",\n        [12, 12],\n        x_categories,  # type: ignore\n        \"Current Pitch Class\",\n        x_categories,  # type: ignore\n        \"Previous Pitch Class\",\n    )\n</code></pre>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist2.pitch_class_distribution_2(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist2.pitch_class_distribution_2(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Pitch Class Distribution'</code> )           \u2013            <p>Name for the distribution; plot title if plotted.</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist2.pitch_class_distribution_2(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, weight the pitch-class distribution by note durations in seconds that are modified according to Parncutt's durational accent model (1994), by default True.</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pcdist2.pitch_class_distribution_2(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Matlab MIDI Toolbox avoids zero division by dividing counts by the total count plus (1e-12 times the number of bins). True enables this behavior. Default is False, which simply skips division when the total count is zero (this also returns a zero matrix when the count is zero).</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pitch_mean.pitch_mean","title":"pitch_mean","text":"<pre><code>pitch_mean(score, weighted=False)\n</code></pre> <p>Compute the mean pitch or mean pitch weighted by duration (in quarters)</p> <p>Parameters:</p> Source code in <code>amads/pitch/pitch_mean.py</code> <pre><code>def pitch_mean(score, weighted=False):\n    \"\"\"Compute the mean pitch or mean pitch weighted by duration (in quarters)\n\n    Parameters\n    ----------\n    score : Score\n        The pitch mean is computed for all pitches in the score. Groups of\n        two or more tied notes are counted as one pitch occurrence.\n    weighted : bool\n        If true, pitches are weighted by their durations.\n    \"\"\"\n    sum = 0\n    count = 0\n    if weighted:  # no need to merge tied notes. Rather than merging tied\n        # notes, we use pitch * tied_duration = = pitch * (dur_1 + dur_2)\n        # = pitch * dur_1 + pitch * dur_2, so we can just treat the\n        # components of tied notes separately.\n        for note in score.find_all(Note):\n            sum += note.key_num * note.duration\n            count += note.duration\n    else:\n        # Our problem is that we want to count only the first of any tied-note\n        # group. We could use merge_tied_notes() to do this, but it is work to\n        # make a new scoore and copy all notes. Instead, we keep a set of\n        # tied-to notes and ignore any note encountered that is in the set.\n        tied_to = set()\n        for note in score.find_all(Note):\n            if note.tie is not None:\n                tied_to.add(note.tie)\n            if note not in tied_to:\n                sum += note.key_num\n                count += 1\n    return (sum / count) if sum &gt; 0 else 0\n</code></pre>"},{"location":"reference/pitch/pitches/#amads.pitch.pitch_mean.pitch_mean(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The pitch mean is computed for all pitches in the score. Groups of two or more tied notes are counted as one pitch occurrence.</p>"},{"location":"reference/pitch/pitches/#amads.pitch.pitch_mean.pitch_mean(weighted)","title":"<code>weighted</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, pitches are weighted by their durations.</p>"},{"location":"reference/pitch/serial/","title":"Serial","text":"<p>options:     members: false</p>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions","title":"pc_set_functions","text":"<p>Functions for retrieving one pitch class set property directly from another.</p> <p>Most of the retrieval function names are in the form <code>&lt;call-on-type&gt;_to_&lt;return-type&gt;</code> e.g. <code>prime_to_combinatoriality</code> Some are simple mappings from one entry to another. Anything starting with pitches involves more calculation.</p> <p>Broadly as implemented by Mark Gotham for Serial_Analyser after Robert Morris, but the functions are general and not really named algorithms in sense used elsewhere on this code base.</p> <p>Functions:</p> <ul> <li> <code>set_classes_from_cardinality</code>             \u2013              <p>Find pitch class set data matching given cardinality.</p> </li> <li> <code>prime_to_combinatoriality</code>             \u2013              <p>Find the combinatoriality status for a given prime form.</p> </li> <li> <code>interval_vector_to_combinatoriality</code>             \u2013              <p>Find the combinatoriality status for a given interval vector.</p> </li> <li> <code>pitches_to_combinatoriality</code>             \u2013              <p>Find the combinatoriality status for a given list of pitches.</p> </li> <li> <code>distinct_PCs</code>             \u2013              <p>Find the distinct pitch classes for a given list of pitches.</p> </li> <li> <code>pitches_to_interval_vector</code>             \u2013              <p>Find the interval vector for a given list of pitches.</p> </li> <li> <code>pitches_to_forte_class</code>             \u2013              <p>Find the Forte class for a given list of pitches.</p> </li> <li> <code>pitches_to_prime</code>             \u2013              <p>Find the prime form for a given list of pitches.</p> </li> <li> <code>transposition_equivalent</code>             \u2013              <p>Supporting function for determining whether two sets are transposition equivalent</p> </li> </ul>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions-functions","title":"Functions","text":""},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.set_classes_from_cardinality","title":"set_classes_from_cardinality","text":"<pre><code>set_classes_from_cardinality(cardinality: int)\n</code></pre> <p>Find pitch class set data matching given cardinality.</p> <p>In: a cardinality (2-10).</p> <p>Out: the pitch class set data for that cardinality.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def set_classes_from_cardinality(cardinality: int):\n    \"\"\"\n    Find pitch class set data matching given cardinality.\n\n    In: a cardinality (2-10).\n\n    Out: the pitch class set data for that cardinality.\n    \"\"\"\n    if not (1 &lt; cardinality &lt; 11):\n        raise ValueError(\"Invalid cardinality: must be 2-10 (inclusive).\")\n    else:\n        return pc_sets.set_classes[cardinality]\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.prime_to_combinatoriality","title":"prime_to_combinatoriality","text":"<pre><code>prime_to_combinatoriality(prime: tuple[int, ...])\n</code></pre> <p>Find the combinatoriality status for a given prime form.</p> <p>In: a prime form expressed as a Tuple of integers.</p> <p>Out: the combinatoriality status as a string.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def prime_to_combinatoriality(prime: Tuple[int, ...]):\n    \"\"\"\n    Find the combinatoriality status for a given prime form.\n\n    In: a prime form expressed as a Tuple of integers.\n\n    Out: the combinatoriality status as a string.\n    \"\"\"\n    data = set_classes_from_cardinality(len(prime))\n    assert data is not None\n    for x in data:\n        if x[1] == prime:\n            return x[3]\n    raise ValueError(f\"{prime} is not a valid prime form\")\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.interval_vector_to_combinatoriality","title":"interval_vector_to_combinatoriality","text":"<pre><code>interval_vector_to_combinatoriality(vector: tuple[int, ...])\n</code></pre> <p>Find the combinatoriality status for a given interval vector.</p> <p>In: an interval vector for any set with 2-10 distinct pitches, expressed as a Tuple of 6 integers.</p> <p>Out: the combinatoriality status of any valid interval vector as a string (one of T, I, RI, A, or an empty string for non-combinatorial cases).</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def interval_vector_to_combinatoriality(vector: Tuple[int, ...]):\n    \"\"\"\n    Find the combinatoriality status for a given interval vector.\n\n    In: an interval vector for any set with 2-10 distinct pitches,\n    expressed as a Tuple of 6 integers.\n\n    Out: the combinatoriality status of any valid interval vector as a\n    string (one of T, I, RI, A, or an empty string for non-combinatorial cases).\n    \"\"\"\n    if len(vector) != 6:\n        raise ValueError(f\"{vector} is not a valid interval vector\")\n    total = sum(vector)\n    total_to_cardinality = {1: 2, 3: 3, 6: 4, 15: 6}\n    data = set_classes_from_cardinality(total_to_cardinality[total])\n    assert data is not None\n    for x in data:\n        if x[2] == vector:\n            return x[-1]\n    raise ValueError(f\"{vector} is not a valid interval vector\")\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_combinatoriality","title":"pitches_to_combinatoriality","text":"<pre><code>pitches_to_combinatoriality(pitches: list[int] | tuple[int, ...])\n</code></pre> <p>Find the combinatoriality status for a given list of pitches.</p> <p>In: a list or tuple of pitches expressed as integers (0\u201311) for sets with 2-10 distinct pitches.</p> <p>Out: the combinatoriality status as a string.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_combinatoriality(pitches: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Find the combinatoriality status for a given list of pitches.\n\n    In: a list or tuple of pitches expressed as integers\n    (0\u201311) for sets with 2-10 distinct pitches.\n\n    Out: the combinatoriality status as a string.\n    \"\"\"\n    icv = pitches_to_interval_vector(pitches)\n    return interval_vector_to_combinatoriality(icv)\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.distinct_PCs","title":"distinct_PCs","text":"<pre><code>distinct_PCs(pitches: list | tuple) -&gt; list\n</code></pre> <p>Find the distinct pitch classes for a given list of pitches.</p> <p>In: a list or tuple of pitches (any integers).</p> <p>Out: a list of distinct PCs in the range 0-11.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def distinct_PCs(pitches: Union[List, Tuple]) -&gt; list:\n    \"\"\"\n    Find the distinct pitch classes for a given list of pitches.\n\n    In: a list or tuple of pitches (any integers).\n\n    Out: a list of distinct PCs in the range 0-11.\n    \"\"\"\n    pitches = list(set(pitches))  # remove any duplicates\n    return [p % 12 for p in pitches]\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_interval_vector","title":"pitches_to_interval_vector","text":"<pre><code>pitches_to_interval_vector(pitches: list[int] | tuple[int, ...])\n</code></pre> <p>Find the interval vector for a given list of pitches.</p> <p>In: a list or tuple of pitches.</p> <p>Out: the interval vector.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_interval_vector(pitches: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Find the interval vector for a given list of pitches.\n\n    In: a list or tuple of pitches.\n\n    Out: the interval vector.\n    \"\"\"\n    pitches = distinct_PCs(pitches)\n\n    vector = [0, 0, 0, 0, 0, 0]\n    from itertools import combinations\n\n    for p in combinations(pitches, 2):\n        ic = p[1] - p[0]\n        if ic &lt; 0:\n            ic *= -1\n        if ic &gt; 6:\n            ic = 12 - ic\n        vector[ic - 1] += 1\n    return tuple(vector)\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_forte_class","title":"pitches_to_forte_class","text":"<pre><code>pitches_to_forte_class(pitches: list[int] | tuple[int])\n</code></pre> <p>Find the Forte class for a given list of pitches.</p> <p>In: a list or tuple of pitches expressed as integers (0\u201311) for sets with 2-10 distinct pitches.</p> <p>Out: the Forte class.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_forte_class(pitches: Union[List[int], Tuple[int]]):\n    \"\"\"\n    Find the Forte class for a given list of pitches.\n\n    In: a list or tuple of pitches expressed as integers\n    (0\u201311) for sets with 2-10 distinct pitches.\n\n    Out: the Forte class.\n    \"\"\"\n    data = set_classes_from_cardinality(len(pitches))\n    prime = pitches_to_prime(pitches)\n    assert data is not None\n    for x in data:\n        if x[1] == prime:\n            return x[0]\n    raise ValueError(f\"{pitches} is not a valid entry.\")\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_prime","title":"pitches_to_prime","text":"<pre><code>pitches_to_prime(pitches: list[int] | tuple[int])\n</code></pre> <p>Find the prime form for a given list of pitches.</p> <p>In: a list or tuple of pitches expressed as integers (0\u201311) for sets with 2-10 distinct pitches.</p> <p>Out: the prime form.</p> <p>The function first converts the pitches to their interval vector (easy, fast). That vector unambiguously gives the prime form for cases except those with Z-related pairs. This affects one pair of tetrachords (so 2 prime forms) and 15 pairs of hexachords (30 primes).</p> <p>In those cases, the prime form is worked out by comparing the pitch list against the pair of options in both inversions until a match is found.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_prime(pitches: Union[List[int], Tuple[int]]):\n    \"\"\"\n    Find the prime form for a given list of pitches.\n\n    In: a list or tuple of pitches expressed as integers\n    (0\u201311) for sets with 2-10 distinct pitches.\n\n    Out: the prime form.\n\n    The function first converts the pitches to their interval vector (easy, fast).\n    That vector unambiguously gives the prime form for cases except those with Z-related pairs.\n    This affects one pair of tetrachords (so 2 prime forms) and 15 pairs of hexachords (30 primes).\n\n    In those cases, the prime form is worked out by comparing the pitch list against the pair of\n    options in both inversions until a match is found.\n    \"\"\"\n\n    pitches = distinct_PCs(pitches)\n\n    vector = pitches_to_interval_vector(pitches)\n    primes = []\n    data = set_classes_from_cardinality(len(set(pitches)))\n\n    assert data is not None\n    for x in data:\n        if x[2] == vector:\n            primes.append(x[1])\n\n    if len(primes) == 1:\n        return primes[0]\n    elif len(primes) &gt; 1:\n        for prime in primes:  # each possible prime form\n            inverted = pitch_list_transformations.invert(prime)\n            for t in [prime, inverted]:\n                if transposition_equivalent(t, pitches):\n                    return prime\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.transposition_equivalent","title":"transposition_equivalent","text":"<pre><code>transposition_equivalent(set1, set2)\n</code></pre> <p>Supporting function for determining whether two sets are transposition equivalent</p> <p>In: two pitch class sets as lists or tuples of integers (0-11).</p> <p>Out: True if they are transposition equivalent, False otherwise.</p> <p>Used as part of determining prime forms with <code>pitches_to_prime</code>.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def transposition_equivalent(set1, set2):\n    \"\"\"\n    Supporting function for determining whether two sets are transposition equivalent\n\n    In: two pitch class sets as lists or tuples of integers (0-11).\n\n    Out: True if they are transposition equivalent, False otherwise.\n\n    Used as part of determining prime forms with `pitches_to_prime`.\n    \"\"\"\n    sorted_set2 = sorted(list(set2))\n    for i in range(12):\n        test_case = sorted(\n            list(pitch_list_transformations.transpose_by(set1, i))\n        )\n        if test_case == sorted_set2:\n            return True\n    return False\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.set_classes_from_cardinality","title":"set_classes_from_cardinality","text":"<pre><code>set_classes_from_cardinality(cardinality: int)\n</code></pre> <p>Find pitch class set data matching given cardinality.</p> <p>In: a cardinality (2-10).</p> <p>Out: the pitch class set data for that cardinality.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def set_classes_from_cardinality(cardinality: int):\n    \"\"\"\n    Find pitch class set data matching given cardinality.\n\n    In: a cardinality (2-10).\n\n    Out: the pitch class set data for that cardinality.\n    \"\"\"\n    if not (1 &lt; cardinality &lt; 11):\n        raise ValueError(\"Invalid cardinality: must be 2-10 (inclusive).\")\n    else:\n        return pc_sets.set_classes[cardinality]\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.prime_to_combinatoriality","title":"prime_to_combinatoriality","text":"<pre><code>prime_to_combinatoriality(prime: tuple[int, ...])\n</code></pre> <p>Find the combinatoriality status for a given prime form.</p> <p>In: a prime form expressed as a Tuple of integers.</p> <p>Out: the combinatoriality status as a string.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def prime_to_combinatoriality(prime: Tuple[int, ...]):\n    \"\"\"\n    Find the combinatoriality status for a given prime form.\n\n    In: a prime form expressed as a Tuple of integers.\n\n    Out: the combinatoriality status as a string.\n    \"\"\"\n    data = set_classes_from_cardinality(len(prime))\n    assert data is not None\n    for x in data:\n        if x[1] == prime:\n            return x[3]\n    raise ValueError(f\"{prime} is not a valid prime form\")\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.interval_vector_to_combinatoriality","title":"interval_vector_to_combinatoriality","text":"<pre><code>interval_vector_to_combinatoriality(vector: tuple[int, ...])\n</code></pre> <p>Find the combinatoriality status for a given interval vector.</p> <p>In: an interval vector for any set with 2-10 distinct pitches, expressed as a Tuple of 6 integers.</p> <p>Out: the combinatoriality status of any valid interval vector as a string (one of T, I, RI, A, or an empty string for non-combinatorial cases).</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def interval_vector_to_combinatoriality(vector: Tuple[int, ...]):\n    \"\"\"\n    Find the combinatoriality status for a given interval vector.\n\n    In: an interval vector for any set with 2-10 distinct pitches,\n    expressed as a Tuple of 6 integers.\n\n    Out: the combinatoriality status of any valid interval vector as a\n    string (one of T, I, RI, A, or an empty string for non-combinatorial cases).\n    \"\"\"\n    if len(vector) != 6:\n        raise ValueError(f\"{vector} is not a valid interval vector\")\n    total = sum(vector)\n    total_to_cardinality = {1: 2, 3: 3, 6: 4, 15: 6}\n    data = set_classes_from_cardinality(total_to_cardinality[total])\n    assert data is not None\n    for x in data:\n        if x[2] == vector:\n            return x[-1]\n    raise ValueError(f\"{vector} is not a valid interval vector\")\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_combinatoriality","title":"pitches_to_combinatoriality","text":"<pre><code>pitches_to_combinatoriality(pitches: list[int] | tuple[int, ...])\n</code></pre> <p>Find the combinatoriality status for a given list of pitches.</p> <p>In: a list or tuple of pitches expressed as integers (0\u201311) for sets with 2-10 distinct pitches.</p> <p>Out: the combinatoriality status as a string.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_combinatoriality(pitches: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Find the combinatoriality status for a given list of pitches.\n\n    In: a list or tuple of pitches expressed as integers\n    (0\u201311) for sets with 2-10 distinct pitches.\n\n    Out: the combinatoriality status as a string.\n    \"\"\"\n    icv = pitches_to_interval_vector(pitches)\n    return interval_vector_to_combinatoriality(icv)\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.distinct_PCs","title":"distinct_PCs","text":"<pre><code>distinct_PCs(pitches: list | tuple) -&gt; list\n</code></pre> <p>Find the distinct pitch classes for a given list of pitches.</p> <p>In: a list or tuple of pitches (any integers).</p> <p>Out: a list of distinct PCs in the range 0-11.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def distinct_PCs(pitches: Union[List, Tuple]) -&gt; list:\n    \"\"\"\n    Find the distinct pitch classes for a given list of pitches.\n\n    In: a list or tuple of pitches (any integers).\n\n    Out: a list of distinct PCs in the range 0-11.\n    \"\"\"\n    pitches = list(set(pitches))  # remove any duplicates\n    return [p % 12 for p in pitches]\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_interval_vector","title":"pitches_to_interval_vector","text":"<pre><code>pitches_to_interval_vector(pitches: list[int] | tuple[int, ...])\n</code></pre> <p>Find the interval vector for a given list of pitches.</p> <p>In: a list or tuple of pitches.</p> <p>Out: the interval vector.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_interval_vector(pitches: Union[List[int], Tuple[int, ...]]):\n    \"\"\"\n    Find the interval vector for a given list of pitches.\n\n    In: a list or tuple of pitches.\n\n    Out: the interval vector.\n    \"\"\"\n    pitches = distinct_PCs(pitches)\n\n    vector = [0, 0, 0, 0, 0, 0]\n    from itertools import combinations\n\n    for p in combinations(pitches, 2):\n        ic = p[1] - p[0]\n        if ic &lt; 0:\n            ic *= -1\n        if ic &gt; 6:\n            ic = 12 - ic\n        vector[ic - 1] += 1\n    return tuple(vector)\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_forte_class","title":"pitches_to_forte_class","text":"<pre><code>pitches_to_forte_class(pitches: list[int] | tuple[int])\n</code></pre> <p>Find the Forte class for a given list of pitches.</p> <p>In: a list or tuple of pitches expressed as integers (0\u201311) for sets with 2-10 distinct pitches.</p> <p>Out: the Forte class.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_forte_class(pitches: Union[List[int], Tuple[int]]):\n    \"\"\"\n    Find the Forte class for a given list of pitches.\n\n    In: a list or tuple of pitches expressed as integers\n    (0\u201311) for sets with 2-10 distinct pitches.\n\n    Out: the Forte class.\n    \"\"\"\n    data = set_classes_from_cardinality(len(pitches))\n    prime = pitches_to_prime(pitches)\n    assert data is not None\n    for x in data:\n        if x[1] == prime:\n            return x[0]\n    raise ValueError(f\"{pitches} is not a valid entry.\")\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.pitches_to_prime","title":"pitches_to_prime","text":"<pre><code>pitches_to_prime(pitches: list[int] | tuple[int])\n</code></pre> <p>Find the prime form for a given list of pitches.</p> <p>In: a list or tuple of pitches expressed as integers (0\u201311) for sets with 2-10 distinct pitches.</p> <p>Out: the prime form.</p> <p>The function first converts the pitches to their interval vector (easy, fast). That vector unambiguously gives the prime form for cases except those with Z-related pairs. This affects one pair of tetrachords (so 2 prime forms) and 15 pairs of hexachords (30 primes).</p> <p>In those cases, the prime form is worked out by comparing the pitch list against the pair of options in both inversions until a match is found.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def pitches_to_prime(pitches: Union[List[int], Tuple[int]]):\n    \"\"\"\n    Find the prime form for a given list of pitches.\n\n    In: a list or tuple of pitches expressed as integers\n    (0\u201311) for sets with 2-10 distinct pitches.\n\n    Out: the prime form.\n\n    The function first converts the pitches to their interval vector (easy, fast).\n    That vector unambiguously gives the prime form for cases except those with Z-related pairs.\n    This affects one pair of tetrachords (so 2 prime forms) and 15 pairs of hexachords (30 primes).\n\n    In those cases, the prime form is worked out by comparing the pitch list against the pair of\n    options in both inversions until a match is found.\n    \"\"\"\n\n    pitches = distinct_PCs(pitches)\n\n    vector = pitches_to_interval_vector(pitches)\n    primes = []\n    data = set_classes_from_cardinality(len(set(pitches)))\n\n    assert data is not None\n    for x in data:\n        if x[2] == vector:\n            primes.append(x[1])\n\n    if len(primes) == 1:\n        return primes[0]\n    elif len(primes) &gt; 1:\n        for prime in primes:  # each possible prime form\n            inverted = pitch_list_transformations.invert(prime)\n            for t in [prime, inverted]:\n                if transposition_equivalent(t, pitches):\n                    return prime\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_set_functions.transposition_equivalent","title":"transposition_equivalent","text":"<pre><code>transposition_equivalent(set1, set2)\n</code></pre> <p>Supporting function for determining whether two sets are transposition equivalent</p> <p>In: two pitch class sets as lists or tuples of integers (0-11).</p> <p>Out: True if they are transposition equivalent, False otherwise.</p> <p>Used as part of determining prime forms with <code>pitches_to_prime</code>.</p> Source code in <code>amads/pitch/pc_set_functions.py</code> <pre><code>def transposition_equivalent(set1, set2):\n    \"\"\"\n    Supporting function for determining whether two sets are transposition equivalent\n\n    In: two pitch class sets as lists or tuples of integers (0-11).\n\n    Out: True if they are transposition equivalent, False otherwise.\n\n    Used as part of determining prime forms with `pitches_to_prime`.\n    \"\"\"\n    sorted_set2 = sorted(list(set2))\n    for i in range(12):\n        test_case = sorted(\n            list(pitch_list_transformations.transpose_by(set1, i))\n        )\n        if test_case == sorted_set2:\n            return True\n    return False\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.pc_sets","title":"pc_sets","text":"<p>Look-up tables for the properties of pitch class sets. Note: this toolkit also provides algorithmic functions for retrieving one property directly from another.</p> <p>Each pitch class set entry features the following properties:</p> <ul> <li>Forte index;</li> <li>prime form (according to Forte's system);</li> <li>interval vector;</li> <li>number of distinct transformations (non-invariant transpositions and / or inversions).</li> </ul> <p>For the hexachords (only), an additional entry provides the combinatoriality status from among 5 options:</p> <ul> <li><code>'A'</code> for all-combinatorial (6 hexachords total),</li> <li><code>'T'</code> for transposition only (only 1),</li> <li><code>'I'</code> for inversion only (13),</li> <li><code>'RI'</code> for retrograde-inversion only (13), and</li> <li><code>''</code> (an empty string) for non-combinatorial (16).</li> </ul> <p>For more information on set classes and a more detailed list of properties, see Robert Morris's table and brief explanation (with further sources) here: http://ecmc.rochester.edu/rdm/pdflib/set-class.table.pdf</p> <p>Source: Gotham and Yust, Serial Analyser, DLfM 2021 https://github.com/MarkGotham/Serial_Analyser</p> <p>Author: Mark Gotham, 2021</p>"},{"location":"reference/pitch/serial/#module-level-variable","title":"Module-level Variable","text":"<p><code>pc_sets</code> - Tuple with (Forte index, prime form, interval vector, number of transformations, [combinatoriality status for hexachords only])</p>"},{"location":"reference/pitch/serial/#amads.pitch.serial","title":"serial","text":"<p>The <code>pitch_list_transformations</code> module provides basic functions for transforming pitch lists (e.g., transposition, inversion, retrograde, rotation).</p> <p>This small module provides some more niche routines that are specific to tone rows in serial music.</p> <p>Functions:</p> <ul> <li> <code>rotate_hexachords</code>             \u2013              <p>Implements a set of hexachord rotations of the kind described in krenek 1960, p.212.</p> </li> <li> <code>pair_swap_krenek</code>             \u2013              <p>Iteratively swaps pairs of adjacent notes in a row</p> </li> <li> <code>lumsdaine_cycle</code>             \u2013              <p>A multipart</p> </li> <li> <code>lumsdaine_4</code>             \u2013              <p>One phase of <code>lumsdaine_cycle()</code></p> </li> <li> <code>lumsdaine_hexachord_pairs</code>             \u2013              <p>Constituent step in the Lumsdaine method</p> </li> </ul>"},{"location":"reference/pitch/serial/#amads.pitch.serial-functions","title":"Functions","text":""},{"location":"reference/pitch/serial/#amads.pitch.serial.rotate_hexachords","title":"rotate_hexachords","text":"<pre><code>rotate_hexachords(\n    row: list | tuple, transpose_iterations: bool = False\n) -&gt; list\n</code></pre> <p>Implements a set of hexachord rotations of the kind described in krenek 1960, p.212. Splits the row into two hexachords and iteratively rotates each. This function returns a list of lists with each iteration until the cycle is complete and come full circle.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of lists with the full cycle.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; row_krenek = [5, 7, 9, 10, 1, 3, 11, 0, 2, 4, 6, 8]\n&gt;&gt;&gt; for x in rotate_hexachords(row_krenek):\n...     print(x)\n[5, 7, 9, 10, 1, 3, 11, 0, 2, 4, 6, 8]\n[7, 9, 10, 1, 3, 5, 0, 2, 4, 6, 8, 11]\n[9, 10, 1, 3, 5, 7, 2, 4, 6, 8, 11, 0]\n[10, 1, 3, 5, 7, 9, 4, 6, 8, 11, 0, 2]\n[1, 3, 5, 7, 9, 10, 6, 8, 11, 0, 2, 4]\n[3, 5, 7, 9, 10, 1, 8, 11, 0, 2, 4, 6]\n[5, 7, 9, 10, 1, 3, 11, 0, 2, 4, 6, 8]\n</code></pre> Source code in <code>amads/pitch/serial.py</code> <pre><code>def rotate_hexachords(\n    row: Union[List, Tuple], transpose_iterations: bool = False\n) -&gt; list:\n    \"\"\"\n    Implements a set of hexachord rotations of the kind described in krenek 1960, p.212.\n    Splits the row into two hexachords and iteratively rotates each.\n    This function returns a list of lists with each iteration until\n    the cycle is complete and come full circle.\n\n\n    Parameters\n    ----------\n    row\n        A tone row, or any sequence of 12 integers.\n    transpose_iterations\n        If True, transpose each iteration to start on the original pitch of the hexachord.\n        This alternative is also described by krenek.\n        Note this often converts a 12-tone row into one with repeated pitches.\n\n    Returns\n    -------\n    list\n        A list of lists with the full cycle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; row_krenek = [5, 7, 9, 10, 1, 3, 11, 0, 2, 4, 6, 8]\n    &gt;&gt;&gt; for x in rotate_hexachords(row_krenek):\n    ...     print(x)\n    [5, 7, 9, 10, 1, 3, 11, 0, 2, 4, 6, 8]\n    [7, 9, 10, 1, 3, 5, 0, 2, 4, 6, 8, 11]\n    [9, 10, 1, 3, 5, 7, 2, 4, 6, 8, 11, 0]\n    [10, 1, 3, 5, 7, 9, 4, 6, 8, 11, 0, 2]\n    [1, 3, 5, 7, 9, 10, 6, 8, 11, 0, 2, 4]\n    [3, 5, 7, 9, 10, 1, 8, 11, 0, 2, 4, 6]\n    [5, 7, 9, 10, 1, 3, 11, 0, 2, 4, 6, 8]\n    \"\"\"\n\n    assert len(row) == 12\n\n    rows = [row]  # initialise with starting\n\n    hexachord1note1 = row[0]\n    hexachord2note1 = row[6]\n\n    for i in range(1, 6):\n        first_hexachord = row[i:6] + row[0:i]\n        second_hexachord = row[6 + i :] + row[6 : 6 + i]\n\n        if transpose_iterations:\n            first_hexachord = transpose_to(\n                first_hexachord, start=hexachord1note1\n            )\n            second_hexachord = transpose_to(\n                second_hexachord, start=hexachord2note1\n            )\n\n        new_row = first_hexachord + second_hexachord\n        rows.append(new_row)\n\n    rows.append(row)  # completes the cycle\n\n    return rows\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.serial.rotate_hexachords(row)","title":"<code>row</code>","text":"(<code>list | tuple</code>)           \u2013            <p>A tone row, or any sequence of 12 integers.</p>"},{"location":"reference/pitch/serial/#amads.pitch.serial.rotate_hexachords(transpose_iterations)","title":"<code>transpose_iterations</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, transpose each iteration to start on the original pitch of the hexachord. This alternative is also described by krenek. Note this often converts a 12-tone row into one with repeated pitches.</p>"},{"location":"reference/pitch/serial/#amads.pitch.serial.pair_swap_krenek","title":"pair_swap_krenek","text":"<pre><code>pair_swap_krenek(row: list | tuple) -&gt; list\n</code></pre> <p>Iteratively swaps pairs of adjacent notes in a row with a two-step process as described in Krenek 1960, p.213.</p> <p>Returns a list of 13 rows of which the last is the retrograde of the first. As such, calling this twice brings you back to the original row.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of lists with the full cycle.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pair_swap_row = [9, 2, 3, 6, 5, 1, 7, 4, 8, 0, 10, 11]\n&gt;&gt;&gt; for x in pair_swap_krenek(pair_swap_row):\n...     print(x)\n[9, 2, 3, 6, 5, 1, 7, 4, 8, 0, 10, 11]\n[9, 3, 2, 5, 6, 7, 1, 8, 4, 10, 0, 11]\n[3, 9, 5, 2, 7, 6, 8, 1, 10, 4, 11, 0]\n[3, 5, 9, 7, 2, 8, 6, 10, 1, 11, 4, 0]\n[5, 3, 7, 9, 8, 2, 10, 6, 11, 1, 0, 4]\n[5, 7, 3, 8, 9, 10, 2, 11, 6, 0, 1, 4]\n[7, 5, 8, 3, 10, 9, 11, 2, 0, 6, 4, 1]\n[7, 8, 5, 10, 3, 11, 9, 0, 2, 4, 6, 1]\n[8, 7, 10, 5, 11, 3, 0, 9, 4, 2, 1, 6]\n[8, 10, 7, 11, 5, 0, 3, 4, 9, 1, 2, 6]\n[10, 8, 11, 7, 0, 5, 4, 3, 1, 9, 6, 2]\n[10, 11, 8, 0, 7, 4, 5, 1, 3, 6, 9, 2]\n[11, 10, 0, 8, 4, 7, 1, 5, 6, 3, 2, 9]\n</code></pre> Source code in <code>amads/pitch/serial.py</code> <pre><code>def pair_swap_krenek(row: Union[List, Tuple]) -&gt; list:\n    \"\"\"\n    Iteratively swaps pairs of adjacent notes in a row\n    with a two-step process as described in Krenek 1960, p.213.\n\n    Returns a list of 13 rows of which the last is the retrograde of the first.\n    As such, calling this twice brings you back to the original row.\n\n    Parameters\n    ----------\n    row\n        A tone row, or any sequence of 12 integers.\n\n    Returns\n    -------\n    list\n        A list of lists with the full cycle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; pair_swap_row = [9, 2, 3, 6, 5, 1, 7, 4, 8, 0, 10, 11]\n    &gt;&gt;&gt; for x in pair_swap_krenek(pair_swap_row):\n    ...     print(x)\n    [9, 2, 3, 6, 5, 1, 7, 4, 8, 0, 10, 11]\n    [9, 3, 2, 5, 6, 7, 1, 8, 4, 10, 0, 11]\n    [3, 9, 5, 2, 7, 6, 8, 1, 10, 4, 11, 0]\n    [3, 5, 9, 7, 2, 8, 6, 10, 1, 11, 4, 0]\n    [5, 3, 7, 9, 8, 2, 10, 6, 11, 1, 0, 4]\n    [5, 7, 3, 8, 9, 10, 2, 11, 6, 0, 1, 4]\n    [7, 5, 8, 3, 10, 9, 11, 2, 0, 6, 4, 1]\n    [7, 8, 5, 10, 3, 11, 9, 0, 2, 4, 6, 1]\n    [8, 7, 10, 5, 11, 3, 0, 9, 4, 2, 1, 6]\n    [8, 10, 7, 11, 5, 0, 3, 4, 9, 1, 2, 6]\n    [10, 8, 11, 7, 0, 5, 4, 3, 1, 9, 6, 2]\n    [10, 11, 8, 0, 7, 4, 5, 1, 3, 6, 9, 2]\n    [11, 10, 0, 8, 4, 7, 1, 5, 6, 3, 2, 9]\n\n    \"\"\"\n\n    rows = [row]\n\n    for pair in range(6):\n\n        # First swap operation: starting at position 1 (2nd pitch)\n        row = [x for x in row]\n        for x in range(1, 11, 2):\n            row[x], row[x + 1] = row[x + 1], row[x]\n        rows.append(row)\n\n        # Second swap operation: starting at position 0 (1st pitch)\n        row = [x for x in row]\n        for x in range(0, 12, 2):\n            row[x], row[x + 1] = row[x + 1], row[x]\n        rows.append(row)\n\n    return rows\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.serial.pair_swap_krenek(row)","title":"<code>row</code>","text":"(<code>list | tuple</code>)           \u2013            <p>A tone row, or any sequence of 12 integers.</p>"},{"location":"reference/pitch/serial/#amads.pitch.serial.lumsdaine_cycle","title":"lumsdaine_cycle","text":"<pre><code>lumsdaine_cycle(row: list | None = None) -&gt; list[list]\n</code></pre> <p>A multipart rotation and re-combination method as reported in Hopper's \"The Music of David Lumsdaine\", p.21.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of lists with the full cycle.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for x in lumsdaine_cycle():\n...     print(x)\n[11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]\n[11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n[11, 10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4]\n[11, 0, 10, 7, 2, 5, 8, 1, 3, 6, 9, 4]\n[2, 6, 10, 1, 11, 5, 9, 7, 3, 0, 8, 4]\n[2, 9, 6, 7, 10, 3, 1, 0, 11, 8, 5, 4]\n[2, 3, 5, 7, 11, 9, 1, 4, 10, 8, 6, 0]\n[2, 1, 3, 4, 5, 10, 7, 8, 11, 6, 9, 0]\n[5, 6, 3, 8, 2, 10, 9, 4, 11, 1, 7, 0]\n[5, 9, 6, 4, 3, 11, 8, 1, 2, 7, 10, 0]\n[5, 11, 10, 4, 2, 9, 8, 0, 3, 7, 6, 1]\n[5, 8, 11, 0, 10, 3, 4, 7, 2, 6, 9, 1]\n[10, 6, 11, 7, 5, 3, 9, 0, 2, 8, 4, 1]\n[10, 9, 6, 0, 11, 2, 7, 8, 5, 4, 3, 1]\n[10, 2, 3, 0, 5, 9, 7, 1, 11, 4, 6, 8]\n[10, 7, 2, 1, 3, 11, 0, 4, 5, 6, 9, 8]\n[3, 6, 2, 4, 10, 11, 9, 1, 5, 7, 0, 8]\n[3, 9, 6, 1, 2, 5, 4, 7, 10, 0, 11, 8]\n[3, 5, 11, 1, 10, 9, 4, 8, 2, 0, 6, 7]\n[3, 4, 5, 8, 11, 2, 1, 0, 10, 6, 9, 7]\n</code></pre> Source code in <code>amads/pitch/serial.py</code> <pre><code>def lumsdaine_cycle(\n    row: Union[list, None] = None,\n) -&gt; list[list]:\n    \"\"\"\n    A multipart\n    rotation and re-combination\n    method as reported in\n    Hopper's \"The Music of David Lumsdaine\", p.21.\n\n    Parameters\n    ----------\n    row\n        A tone row, or any sequence of 12 integers.\n\n    Returns\n    -------\n    list\n        A list of lists with the full cycle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; for x in lumsdaine_cycle():\n    ...     print(x)\n    [11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]\n    [11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n    [11, 10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4]\n    [11, 0, 10, 7, 2, 5, 8, 1, 3, 6, 9, 4]\n    [2, 6, 10, 1, 11, 5, 9, 7, 3, 0, 8, 4]\n    [2, 9, 6, 7, 10, 3, 1, 0, 11, 8, 5, 4]\n    [2, 3, 5, 7, 11, 9, 1, 4, 10, 8, 6, 0]\n    [2, 1, 3, 4, 5, 10, 7, 8, 11, 6, 9, 0]\n    [5, 6, 3, 8, 2, 10, 9, 4, 11, 1, 7, 0]\n    [5, 9, 6, 4, 3, 11, 8, 1, 2, 7, 10, 0]\n    [5, 11, 10, 4, 2, 9, 8, 0, 3, 7, 6, 1]\n    [5, 8, 11, 0, 10, 3, 4, 7, 2, 6, 9, 1]\n    [10, 6, 11, 7, 5, 3, 9, 0, 2, 8, 4, 1]\n    [10, 9, 6, 0, 11, 2, 7, 8, 5, 4, 3, 1]\n    [10, 2, 3, 0, 5, 9, 7, 1, 11, 4, 6, 8]\n    [10, 7, 2, 1, 3, 11, 0, 4, 5, 6, 9, 8]\n    [3, 6, 2, 4, 10, 11, 9, 1, 5, 7, 0, 8]\n    [3, 9, 6, 1, 2, 5, 4, 7, 10, 0, 11, 8]\n    [3, 5, 11, 1, 10, 9, 4, 8, 2, 0, 6, 7]\n    [3, 4, 5, 8, 11, 2, 1, 0, 10, 6, 9, 7]\n\n    \"\"\"\n    if row is None:\n        row = [11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]\n    out = []\n    for i in range(5):  # run 4, update to new starting row, and run again\n        out += lumsdaine_4(row)\n        row = every_nth(out[-1], start_index=4)\n    return out\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.serial.lumsdaine_cycle(row)","title":"<code>row</code>","text":"(<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>A tone row, or any sequence of 12 integers.</p>"},{"location":"reference/pitch/serial/#amads.pitch.serial.lumsdaine_4","title":"lumsdaine_4","text":"<pre><code>lumsdaine_4(row: list | None = None) -&gt; list[list]\n</code></pre> <p>One phase of <code>lumsdaine_cycle()</code> producing a set of 4 rows.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of lists with the full cycle.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; for x in lumsdaine_4([11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]):\n...     print(x)\n[11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]\n[11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n[11, 10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4]\n[11, 0, 10, 7, 2, 5, 8, 1, 3, 6, 9, 4]\n</code></pre> <pre><code>&gt;&gt;&gt; for x in lumsdaine_4([5, 9, 7, 3, 0, 8, 4, 2, 6, 10, 1, 11]):\n...     print(x)\n[5, 9, 7, 3, 0, 8, 4, 2, 6, 10, 1, 11]\n[5, 4, 9, 2, 7, 6, 3, 10, 0, 1, 8, 11]\n[5, 6, 8, 2, 0, 4, 3, 11, 7, 1, 9, 10]\n[5, 3, 6, 11, 8, 7, 2, 1, 0, 9, 4, 10]\n</code></pre> Source code in <code>amads/pitch/serial.py</code> <pre><code>def lumsdaine_4(\n    row: Union[List, None] = None,\n) -&gt; list[list]:\n    \"\"\"\n    One phase of `lumsdaine_cycle()`\n    producing a set of 4 rows.\n\n    Parameters\n    ----------\n    row\n        A tone row, or any sequence of 12 integers.\n\n    Returns\n    -------\n    list\n        A list of lists with the full cycle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; for x in lumsdaine_4([11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]):\n    ...     print(x)\n    [11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]\n    [11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n    [11, 10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4]\n    [11, 0, 10, 7, 2, 5, 8, 1, 3, 6, 9, 4]\n\n    &gt;&gt;&gt; for x in lumsdaine_4([5, 9, 7, 3, 0, 8, 4, 2, 6, 10, 1, 11]):\n    ...     print(x)\n    [5, 9, 7, 3, 0, 8, 4, 2, 6, 10, 1, 11]\n    [5, 4, 9, 2, 7, 6, 3, 10, 0, 1, 8, 11]\n    [5, 6, 8, 2, 0, 4, 3, 11, 7, 1, 9, 10]\n    [5, 3, 6, 11, 8, 7, 2, 1, 0, 9, 4, 10]\n\n    \"\"\"\n    if row is None:\n        row = [11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7]\n    row2 = lumsdaine_hexachord_pairs(row)\n    row3 = every_nth(row2)\n    row4 = lumsdaine_hexachord_pairs(row3)\n    return [row, row2, row3, row4]\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.serial.lumsdaine_4(row)","title":"<code>row</code>","text":"(<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>A tone row, or any sequence of 12 integers.</p>"},{"location":"reference/pitch/serial/#amads.pitch.serial.lumsdaine_hexachord_pairs","title":"lumsdaine_hexachord_pairs","text":"<pre><code>lumsdaine_hexachord_pairs(row: list)\n</code></pre> <p>Constituent step in the Lumsdaine method that re-arrange row elements indices into the order 0, 6, 1, 7 ...</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A list of lists with the full cycle.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; lumsdaine_hexachord_pairs([11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7])\n[11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n</code></pre> Source code in <code>amads/pitch/serial.py</code> <pre><code>def lumsdaine_hexachord_pairs(row: list):\n    \"\"\"\n    Constituent step in the Lumsdaine method\n    that re-arrange row elements indices into the order 0, 6, 1, 7 ...\n\n    Parameters\n    ----------\n    row\n        A tone row, or any sequence of 12 integers.\n\n    Returns\n    -------\n    list\n        A list of lists with the full cycle.\n\n    Examples\n    --------\n    &gt;&gt;&gt; lumsdaine_hexachord_pairs([11, 6, 5, 0, 3, 2, 9, 8, 10, 4, 1, 7])\n    [11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n    \"\"\"\n    out_row = []\n    for i in range(6):\n        out_row += [row[i], row[i + 6]]\n    return out_row\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.serial.lumsdaine_hexachord_pairs(row)","title":"<code>row</code>","text":"(<code>list</code>)           \u2013            <p>A tone row, or any sequence of 12 integers.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations","title":"transformations","text":"<p>Basic functionality for transforming pitch lists expressed as integers (MIDI numbers or pitch classes) through transposition, inversion, retrograde, rotation, and more.</p> <p>Most apply equally to any pitch class sequence and can therefore be use in melody and harmony settings.</p> <p>Functions:</p> <ul> <li> <code>transpose_by</code>             \u2013              <p>Transposes a list of pitches by an interval of size</p> </li> <li> <code>transpose_to</code>             \u2013              <p>Transpose a list of pitch classes to start on 0 (by default), or</p> </li> <li> <code>retrograde</code>             \u2013              <p>Retrograde (reverse) a list of pitches.</p> </li> <li> <code>invert</code>             \u2013              <p>Invert a list of pitch classes around a specified pitch: the starting pitch or 0.</p> </li> <li> <code>pitches_to_intervals</code>             \u2013              <p>Get the interval succession of a list of pitches.</p> </li> <li> <code>rotate</code>             \u2013              <p>Rotates a list of pitch classes through N steps (i.e. starts on the Nth element).</p> </li> <li> <code>every_nth</code>             \u2013              <p>Cycle through a list of pitches</p> </li> </ul>"},{"location":"reference/pitch/serial/#amads.pitch.transformations-functions","title":"Functions","text":""},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_by","title":"transpose_by","text":"<pre><code>transpose_by(\n    pitches: Iterable, semitones: int, mod_12: bool = True\n) -&gt; list\n</code></pre> <p>Transposes a list of pitches by an interval of size set by the value of <code>semitones</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_by([0, 1, 2, 3,], 16, mod_12=True)\n[4, 5, 6, 7]\n</code></pre> <pre><code>&gt;&gt;&gt; transpose_by([0, 1, 2, 3,], 16, mod_12=False)\n[16, 17, 18, 19]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def transpose_by(\n    pitches: Iterable, semitones: int, mod_12: bool = True\n) -&gt; list:\n    \"\"\"\n    Transposes a list of pitches by an interval of size\n    set by the value of `semitones`.\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n    semitones\n        How far to transpose, expressed in semitones (1 per MIDI note).\n    mod_12\n        If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; transpose_by([0, 1, 2, 3,], 16, mod_12=True)\n    [4, 5, 6, 7]\n\n    &gt;&gt;&gt; transpose_by([0, 1, 2, 3,], 16, mod_12=False)\n    [16, 17, 18, 19]\n\n    \"\"\"\n    result = []\n    for pitch in pitches:\n        transposed = pitch + semitones\n        if mod_12:\n            transposed %= 12\n        result.append(transposed)\n    return result\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_by(pitches)","title":"<code>pitches</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_by(semitones)","title":"<code>semitones</code>","text":"(<code>int</code>)           \u2013            <p>How far to transpose, expressed in semitones (1 per MIDI note).</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_by(mod_12)","title":"<code>mod_12</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_to","title":"transpose_to","text":"<pre><code>transpose_to(\n    pitches: Iterable, start: int = 0, mod_12: bool = True\n) -&gt; list\n</code></pre> <p>Transpose a list of pitch classes to start on 0 (by default), or any another number set by the value of <code>start</code>.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; transpose_to([0, 1, 2, 3,], 16, mod_12=True)\n[4, 5, 6, 7]\n</code></pre> <pre><code>&gt;&gt;&gt; transpose_to([0, 1, 2, 3,], 16, mod_12=False)\n[16, 17, 18, 19]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def transpose_to(\n    pitches: Iterable, start: int = 0, mod_12: bool = True\n) -&gt; list:\n    \"\"\"\n    Transpose a list of pitch classes to start on 0 (by default), or\n    any another number set by the value of `start`.\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n    start\n        The first number of the new list.\n    mod_12\n        If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; transpose_to([0, 1, 2, 3,], 16, mod_12=True)\n    [4, 5, 6, 7]\n\n    &gt;&gt;&gt; transpose_to([0, 1, 2, 3,], 16, mod_12=False)\n    [16, 17, 18, 19]\n\n    \"\"\"\n    difference = start - pitches[0]\n    result = []\n    for pitch in pitches:\n        transposed = pitch + difference\n        if mod_12:\n            transposed %= 12\n        result.append(transposed)\n    return result\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_to(pitches)","title":"<code>pitches</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_to(start)","title":"<code>start</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The first number of the new list.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.transpose_to(mod_12)","title":"<code>mod_12</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.retrograde","title":"retrograde","text":"<pre><code>retrograde(pitches: Iterable) -&gt; list\n</code></pre> <p>Retrograde (reverse) a list of pitches.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; retrograde([2, 6, 9])\n[9, 6, 2]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def retrograde(pitches: Iterable) -&gt; list:\n    \"\"\"\n    Retrograde (reverse) a list of pitches.\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; retrograde([2, 6, 9])\n    [9, 6, 2]\n\n    \"\"\"\n    result = pitches[::-1]  # to create a copy\n    return result\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.retrograde(pitches)","title":"<code>pitches</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.invert","title":"invert","text":"<pre><code>invert(\n    pitches: Iterable, use_first_not_0: bool = True, mod_12: bool = True\n) -&gt; list\n</code></pre> <p>Invert a list of pitch classes around a specified pitch: the starting pitch or 0.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; invert([5, 6, 7])\n[5, 4, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; invert([5, 6, 7], use_first_not_0=False)\n[7, 6, 5]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def invert(\n    pitches: Iterable, use_first_not_0: bool = True, mod_12: bool = True\n) -&gt; list:\n    \"\"\"\n    Invert a list of pitch classes around a specified pitch: the starting pitch or 0.\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n    use_first_not_0\n        If true, use the first number of the list as the centre of the inversion.\n    mod_12\n        If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input.\n\n    Examples\n    --------\n    &gt;&gt;&gt; invert([5, 6, 7])\n    [5, 4, 3]\n\n    &gt;&gt;&gt; invert([5, 6, 7], use_first_not_0=False)\n    [7, 6, 5]\n\n    \"\"\"\n    origin = pitches[0] if use_first_not_0 else 0\n    result = []\n    for pitch in pitches:\n        inverted = 2 * origin - pitch\n        if mod_12:\n            inverted %= 12\n        result.append(inverted)\n\n    return result\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.invert(pitches)","title":"<code>pitches</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.invert(use_first_not_0)","title":"<code>use_first_not_0</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If true, use the first number of the list as the centre of the inversion.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.invert(mod_12)","title":"<code>mod_12</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.pitches_to_intervals","title":"pitches_to_intervals","text":"<pre><code>pitches_to_intervals(\n    pitches: Iterable, wrap: bool = False, mod_12: bool = True\n) -&gt; list\n</code></pre> <p>Get the interval succession of a list of pitches.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input (if wrap), otherwise, one less.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pitches_to_intervals([0, 2, 5])\n[2, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; pitches_to_intervals([0, 2, 5], wrap=True)\n[2, 3, 7]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def pitches_to_intervals(\n    pitches: Iterable, wrap: bool = False, mod_12: bool = True\n) -&gt; list:\n    \"\"\"\n    Get the interval succession of a list of pitches.\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n    wrap\n        If true, include the interval from the last element to the first in addition.\n    mod_12\n        If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input (if wrap), otherwise, one less.\n\n    Examples\n    --------\n    &gt;&gt;&gt; pitches_to_intervals([0, 2, 5])\n    [2, 3]\n\n    &gt;&gt;&gt; pitches_to_intervals([0, 2, 5], wrap=True)\n    [2, 3, 7]\n\n    \"\"\"\n    intervals = []\n    if wrap:\n        pitches += [pitches[0]]\n    for i in range(1, len(pitches)):\n        i = pitches[i] - pitches[i - 1]\n        if mod_12:\n            i %= 12\n        intervals.append(i)\n\n    return intervals\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.pitches_to_intervals(pitches)","title":"<code>pitches</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.pitches_to_intervals(wrap)","title":"<code>wrap</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If true, include the interval from the last element to the first in addition.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.pitches_to_intervals(mod_12)","title":"<code>mod_12</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, return values modulo 12 (necessary for pitch class sets, not for MIDI numbers)</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.rotate","title":"rotate","text":"<pre><code>rotate(pitches: Iterable, steps: int = 1) -&gt; list\n</code></pre> <p>Rotates a list of pitch classes through N steps (i.e. starts on the Nth element).</p> <p>Should be called on an integer less than the length of the pitch list. If called on a larger integer, the value modulo the length of the pitch list. (e.g. 15 becomes 3 for a pitch list of length 12).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; rotate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 4)\n[4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def rotate(pitches: Iterable, steps: int = 1) -&gt; list:\n    \"\"\"\n    Rotates a list of pitch classes through N steps (i.e. starts on the Nth element).\n\n    Should be called on an integer less than the length of the pitch list.\n    If called on a larger integer, the value modulo the length of the pitch list.\n    (e.g. 15 becomes 3 for a pitch list of length 12).\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n    steps\n        If true, include the interval from the last element to the first in addition.\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input.\n\n    Examples\n    --------\n    &gt;&gt;&gt; rotate([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 4)\n    [4, 5, 6, 7, 8, 9, 10, 11, 0, 1, 2, 3]\n\n\n    \"\"\"\n    list_len = len(pitches)\n    if steps &gt; list_len:\n        steps = steps % list_len\n    result = pitches[steps:] + pitches[:steps]\n    return result\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.rotate(pitches)","title":"<code>pitches</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.rotate(steps)","title":"<code>steps</code>","text":"(<code>int</code>, default:                   <code>1</code> )           \u2013            <p>If true, include the interval from the last element to the first in addition.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.every_nth","title":"every_nth","text":"<pre><code>every_nth(\n    pitches: list, start_index: int = 0, step_size: int = 5\n) -&gt; list\n</code></pre> <p>Cycle through a list of pitches with a step size of n mod the length of the list</p> <p>By default, start at index 0 and iterate 12 times (0-12), though both the start index and the range() are settable arguments, hence this equivlance:</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A new list of the same length as the input.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_pitches = [11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n&gt;&gt;&gt; every_nth(test_pitches, step_size=5)\n[11, 10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4]\n</code></pre> <pre><code>&gt;&gt;&gt; every_nth(test_pitches, step_size=5, start_index=5)\n[10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4, 11]\n</code></pre> Source code in <code>amads/pitch/transformations.py</code> <pre><code>def every_nth(pitches: list, start_index: int = 0, step_size: int = 5) -&gt; list:\n    \"\"\"\n    Cycle through a list of pitches\n    with a step size of n mod the length of the list\n\n    By default,\n    start at index 0 and iterate 12 times (0-12),\n    though both the start index and the range() are settable arguments,\n    hence this equivlance:\n\n    Parameters\n    ----------\n    pitches\n        Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.\n    start_index\n        The index position in the list to start at.\n    step_size\n        The gap between successive elements.\n\n    Returns\n    -------\n    list\n        A new list of the same length as the input.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; test_pitches = [11, 9, 6, 8, 5, 10, 0, 4, 3, 1, 2, 7]\n    &gt;&gt;&gt; every_nth(test_pitches, step_size=5)\n    [11, 10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4]\n\n    &gt;&gt;&gt; every_nth(test_pitches, step_size=5, start_index=5)\n    [10, 2, 8, 3, 9, 0, 7, 5, 1, 6, 4, 11]\n\n    \"\"\"\n    list_len = len(pitches)\n    out_pitches = []\n    for i in range(list_len):\n        out_pitches.append(pitches[(start_index + i * step_size) % list_len])\n    return out_pitches\n</code></pre>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.every_nth(pitches)","title":"<code>pitches</code>","text":"(<code>list</code>)           \u2013            <p>Any list or tuple of integers representing pitches as MIDI numbers or pitch classes.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.every_nth(start_index)","title":"<code>start_index</code>","text":"(<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The index position in the list to start at.</p>"},{"location":"reference/pitch/serial/#amads.pitch.transformations.every_nth(step_size)","title":"<code>step_size</code>","text":"(<code>int</code>, default:                   <code>5</code> )           \u2013            <p>The gap between successive elements.</p>"},{"location":"reference/polyphony/skyline/","title":"Skyline","text":""},{"location":"reference/polyphony/skyline/#amads.polyphony.skyline.skyline","title":"skyline","text":"<pre><code>skyline(score: Score, threshold: float = 0.1) -&gt; Score\n</code></pre> <p>Finds the skyline of a musical score.</p> <p>Filters a score, removing any note that is below another note. There are tricky edge cases:</p> <ul> <li>A higher note can occur while a lower note is still sounding. The lower   note is shortened to end at the onset of the upper note.</li> <li>A higher note can follow a lower note very quickly: Rather than setting   the lower note's duration to a very small value, the lower note is   completely removed and ignored. The lower bound on duration is set by   the <code>threshold</code> parameter.</li> <li>A rolled chord with 10 notes starts at the bottom, and every 0.05   quarter notes, a new note enters. So the previous rule applies to   each note, making the top note is a full 0.45 quarters after the   first one. Even in this case, the previous rule is applied repeatedly,   leaving a gap (rest) of at least 0.45 quarters.</li> <li>An upper note of a melody sustains in a legato fashion past the next,   but lower, note of the melody. Although, musically, the upper note   should be shortened and we should keep the lower note, the \u201cskyline\u201d   concept says the top note has priority, so the lower note is ignored   if the overlap is greater than <code>threshold</code>.</li> <li>It is common to have melodies in lower voices or in MIDI arrangements   to have very high accompaniment notes in a non-melodic track. This   algorithm just fails to find the melody in those cases.</li> </ul> <p>Parameters:</p> <ul> <li> </li> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>Score</code>           \u2013            <p>A new score containing the \u201cskyline\u201d notes</p> </li> </ul> Algorithm <p>The basic idea is to scan notes and copy them to skyline, a Part object belonging to a new Score. We can use shallow copy because notes are already deep-copied from score after merge_tied_notes.</p> <p>In the outer looop, we test each note to see if it is below the skyline as it exists so far. Since we process in order, we know each note cannot start before any note in the skyline. If the note is higher than the most recent skyline note (so far), there are two cases:</p> <ol> <li>The new note is approximately concurrent with the most recent skyline    note: Replace the most recent skyline note with this one.</li> <li>The new note is after the most recent skyline note: Append the new    note to the skyline. If the previous note overlaps the new note,    adjust the previous note's duration to end at the onset of the new    note.</li> </ol> <p>A consequence of this algorithm is that a very long low note will be shortened to the onset time of a new note, so a piano roll like this:</p> <pre><code>                           ----------\n         ------------------------------------------\n</code></pre> <p>will result in this:</p> <pre><code>                           ----------\n         ------------------          (nothing here)\n</code></pre> <p>rather than this:</p> <pre><code>         ------------------          --------------\n</code></pre> <p>Another consequence is that since skyline notes are never lengthened, there can be gaps in the skyline. It can look like this, where gaps (rests) can occur between notes:</p> <pre><code>                       ------      -----\n         --------            ------         -------\n</code></pre> Source code in <code>amads/polyphony/skyline.py</code> <pre><code>def skyline(score: Score, threshold: float = 0.1) -&gt; Score:\n    \"\"\"\n    Finds the skyline of a musical score.\n\n    Filters a score, removing any note that is below another note.\n    There are tricky edge cases:\n\n    - A higher note can occur while a lower note is still sounding. The lower\n      note is shortened to end at the onset of the upper note.\n    - A higher note can follow a lower note very quickly: Rather than setting\n      the lower note's duration to a very small value, the lower note is\n      completely removed and ignored. The lower bound on duration is set by\n      the `threshold` parameter.\n    - A rolled chord with 10 notes starts at the bottom, and every 0.05\n      quarter notes, a new note enters. So the previous rule applies to\n      each note, making the top note is a full 0.45 quarters after the\n      first one. Even in this case, the previous rule is applied repeatedly,\n      leaving a gap (rest) of at least 0.45 quarters.\n    - An upper note of a melody sustains in a legato fashion past the next,\n      but lower, note of the melody. Although, musically, the upper note\n      should be shortened and we should keep the lower note, the \u201cskyline\u201d\n      concept says the top note has priority, so the lower note is ignored\n      if the overlap is greater than `threshold`.\n    - It is common to have melodies in lower voices or in MIDI arrangements\n      to have very high accompaniment notes in a non-melodic track. This\n      algorithm just fails to find the melody in those cases.\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to filter\n    threshold : float\n        The threshold for quickly followed notes (default 0.1) and allowed\n        overlap. Processing onsets in time order, if an onset is within\n        `threshold` of the previous onset, the two notes are considered\n        to be conconcurrent, and only the top note is considered in\n        constructing the skyline. In the case of processing a note that\n        is lower in pitch than the current skyline, we ignore the note\n        if the skyline extends more than `threshold` beyond the note's\n        onset. Otherwise, we shorten the skyline duration to end at the\n        note onset and append the note to the skyline.\n\n    Returns\n    -------\n    Score\n        A new score containing the \u201cskyline\u201d notes\n\n    Algorithm\n    ---------\n    The basic idea is to scan notes and copy them to skyline, a Part object\n    belonging to a new Score. We can use shallow copy because notes are\n    already deep-copied from score after merge_tied_notes.\n\n    In the outer looop, we test each note to see if it is below the skyline\n    as it exists so far. Since we process in order, we know each note cannot\n    start before any note in the skyline. If the note is higher than the\n    most recent skyline note (so far), there are two cases:\n\n    1. The new note is approximately concurrent with the most recent skyline\n       note: Replace the most recent skyline note with this one.\n    2. The new note is after the most recent skyline note: Append the new\n       note to the skyline. If the previous note overlaps the new note,\n       adjust the previous note's duration to end at the onset of the new\n       note.\n\n    A consequence of this algorithm is that a very long low note will\n    be shortened to the onset time of a new note, so a piano roll like\n    this:\n    ```\n                               ----------\n             ------------------------------------------\n    ```\n    will result in this:\n    ```\n                               ----------\n             ------------------          (nothing here)\n    ```\n    rather than this:\n    ```                        ----------\n             ------------------          --------------\n    ```\n\n    Another consequence is that since skyline notes are never lengthened,\n    there can be gaps in the skyline. It can look like this, where gaps\n    (rests) can occur between notes:\n    ```\n                           ------      -----\n             --------            ------         -------\n    ```\n    \"\"\"\n    # this code is based on get_sorted_notes():\n    score = score.flatten(collapse=True)  # deep copies the score\n    skyline: Part = cast(\n        Part, score.content[0]\n    )  # types: ignore (retrieves the Part)\n    notes: List[Note] = cast(\n        List[Note], skyline.content\n    )  # (content is all Notes)\n    skyline.content = []  # we will construct skyline from notes here\n\n    prev_note: Optional[Note] = None\n    for note in notes:\n        if prev_note is None:\n            skyline.content.append(note)\n            prev_note = note\n\n        # ignore notes that are below last note in skyline\n        elif note.key_num &lt; prev_note.key_num and (\n            note.onset &lt; prev_note.offset - threshold  # overlap\n            or note.onset &lt; prev_note.onset + threshold\n        ):  # concurrent\n            continue\n\n        elif note.duration &lt; threshold:\n            continue\n\n        # see if note is concurrent and higher\n        if (\n            note.onset &lt; prev_note.onset + threshold\n            and note.key_num &gt;= prev_note.key_num\n        ):\n            skyline.content.pop()  # replace prev_note\n            skyline.content.append(note)\n            prev_note = note\n\n        elif (\n            note.onset &gt;= prev_note.offset - threshold\n            or note.key_num &gt;= prev_note.key_num\n        ):\n            skyline.content.append(note)\n            prev_note = note\n            if prev_note.offset &gt; note.onset:\n                prev_note.offset = note.onset\n\n        else:\n            assert False, \"Unexpected condition, implementation error detected\"\n    return score\n</code></pre>"},{"location":"reference/polyphony/skyline/#amads.polyphony.skyline.skyline(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to filter</p>"},{"location":"reference/polyphony/skyline/#amads.polyphony.skyline.skyline(threshold)","title":"<code>threshold</code>","text":"(<code>float</code>, default:                   <code>0.1</code> )           \u2013            <p>The threshold for quickly followed notes (default 0.1) and allowed overlap. Processing onsets in time order, if an onset is within <code>threshold</code> of the previous onset, the two notes are considered to be conconcurrent, and only the top note is considered in constructing the skyline. In the case of processing a note that is lower in pitch than the current skyline, we ignore the note if the skyline extends more than <code>threshold</code> beyond the note's onset. Otherwise, we shorten the skyline duration to end at the note onset and append the note to the skyline.</p>"},{"location":"reference/time/durations/","title":"Duration Distributions","text":""},{"location":"reference/time/durations/#amads.time.durdist1.duration_distribution_1","title":"duration_distribution_1","text":"<pre><code>duration_distribution_1(\n    score: Score,\n    name: str = \"Duration Distribution\",\n    bin_centers: list[float] | None = None,\n    ignore_extrema: bool | str = \"unspecified\",\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution\n</code></pre> <p>Returns the distribution of note durations in a Score.</p> <p>Each duration is assigned to a bin according to its value.</p> <p>The default centers of the bins are on a logarithmic scale as follows:</p> component bin center (in units of quarters) 0 1/4 (sixteenth) 1 sqrt(2)/4 2 1/2 (eighth) 3 sqrt(2)/2 4 1 (quarter) 5 sqrt(2) 6 2 (half) 7 2*sqrt(2) 8 4 (whole) <p>These centers can be overridden by providing a list of bin centers.</p> <p>If <code>midi_toolbox_compatible</code> is True, the behavior is the same as in the Midi Toolbox <code>durdist1</code> function, with each bin count increased by 1e-12 to avoid division by zero, and values below $sqrt(2)/8$ quarters (just above a sixteenth triplet) and greater than $sqrt(2) \\cdot 4$ quarters (about 5.65685) are ignored. Also, an error is raised if either <code>bin_centers</code> or <code>ignore_extrema</code> are specified.</p> <p>If <code>midi_toolbox_compatible</code> is False (default), the normal behavior is as follows. If <code>bin_centers</code> is not provided, the default centers listed above are used. Values below the lowest or above the highest bins are assigned to those bins appropriately.</p> <p>One remaining case is where you want to ignore values outside the range of the bins. This can be done by setting <code>ignore_extrema</code> to True. If <code>bin_centers</code> is not provided, the default bins are used, and the extreme boundaries are set to $sqrt(2)/8$ quarters and $sqrt(2) \\cdot 4$ quarters respectively. If <code>bin_centers</code> is provided, they must include an additional lower bin and upper bin center value so that upper and lower boundaries can be computed as $sqrt(bin\\_centers[0] \\cdot bin\\_centers[1])$ and $sqrt(bin\\_centers[-2] \\cdot bin\\_centers[-1])$ respectively. Since values beyond the boundaries are ignored, the result will have $len(bin\\_centers) - 2$ bins.</p> <p>Authors: Yiming Huang, Roger B. Dannenberg</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>containing and describing the distribution of note durations.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError: If the score is not monophonic (e.g. contains chords) or</code>             \u2013            <p>if the miditoolbox is True and either <code>bin_centers</code> or <code>ignore_extrema</code> optional parameters are set.</p> </li> </ul> Source code in <code>amads/time/durdist1.py</code> <pre><code>def duration_distribution_1(\n    score: Score,\n    name: str = \"Duration Distribution\",\n    bin_centers: Union[list[float], None] = None,\n    ignore_extrema: Union[bool, str] = \"unspecified\",\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution:\n    r\"\"\"\n    Returns the distribution of note durations in a Score.\n\n    Each duration is assigned to a bin according to its value.\n\n    The default centers of the bins are on a logarithmic scale as follows:\n\n    | component | bin center (in units of quarters) |\n    |-----------|-----------------------------------|\n    | 0         | 1/4 (sixteenth)                   |\n    | 1         | sqrt(2)/4                         |\n    | 2         | 1/2 (eighth)                      |\n    | 3         | sqrt(2)/2                         |\n    | 4         | 1 (quarter)                       |\n    | 5         | sqrt(2)                           |\n    | 6         | 2 (half)                          |\n    | 7         | 2*sqrt(2)                         |\n    | 8         | 4 (whole)                        |\n\n    These centers can be overridden by providing a list of bin centers.\n\n    If `midi_toolbox_compatible` is True, the behavior is the same as in\n    the Midi Toolbox `durdist1` function, with each bin count increased by\n    1e-12 to avoid division by zero, and values below $sqrt(2)/8$ quarters\n    (just above a sixteenth triplet) and greater than $sqrt(2) \\cdot 4$ quarters\n    (about 5.65685) are ignored. Also, an error is raised if either\n    `bin_centers` or `ignore_extrema` are specified.\n\n    If `midi_toolbox_compatible` is False (default), the normal behavior\n    is as follows. If `bin_centers` is not provided, the default centers\n    listed above are used. Values below the lowest or above the highest\n    bins are assigned to those bins appropriately.\n\n    One remaining case is where you want to ignore values outside the\n    range of the bins. This can be done by setting `ignore_extrema` to\n    True. If `bin_centers` is not provided, the default bins are used,\n    and the extreme boundaries are set to $sqrt(2)/8$ quarters and\n    $sqrt(2) \\cdot 4$ quarters respectively. If `bin_centers` is provided,\n    they must include an additional lower bin and upper bin center value\n    so that upper and lower boundaries can be computed as\n    $sqrt(bin\\\\_centers[0] \\cdot bin\\\\_centers[1])$ and\n    $sqrt(bin\\\\_centers[-2] \\cdot bin\\\\_centers[-1])$ respectively. Since values\n    beyond the boundaries are ignored, the result will have\n    $len(bin\\\\_centers) - 2$ bins.\n\n    &lt;small&gt;**Authors**: Yiming Huang, Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze.\n    name : str\n        A name for the distribution and plot title.\n    bin_centers : Union[list[float], None])\n        bin centers (optional) (see description for details).\n    ignore_extrema : bool\n        If True, values outside the range of the bins are ignored\n        (see description for details).\n    miditoolbox_compatible : bool\n        Matlab MIDI Toolbox avoids zero division by dividing counts\n        by the total count plus 1e-12 times the number of counts.\n        True enables this behavior as well as ignoring extreme values\n        and setting the bins as described above. Default is False.\n        If True, `bin_centers` and `ignore_extrema` must not be set.\n\n    Returns\n    -------\n    Distribution\n        containing and describing the distribution of note durations.\n\n    Raises\n    ------\n    ValueError: If the score is not monophonic (e.g. contains chords) or\n        if the miditoolbox is True and either `bin_centers` or\n        `ignore_extrema` optional parameters are set.\n    \"\"\"\n    if miditoolbox_compatible:\n        if bin_centers is not None or ignore_extrema != \"unspecified\":\n            raise ValueError(\n                \"When miditoolbox_compatible is True, \"\n                \"bin_centers and ignore_extrema must not be set.\"\n            )\n    if not score.ismonophonic():\n        raise ValueError(\"Score must be monophonic\")\n\n    if ignore_extrema == \"unspecified\":\n        ignore_extrema = miditoolbox_compatible\n    initial_value = 1e-12 if miditoolbox_compatible else 0.0\n    x_categories = None\n\n    if not bin_centers:\n        bin_boundaries = [2 ** ((i - 0.5) / 2.0) for i in range(-4, 6)]\n        bin_centers = [2 ** (i / 2.0) for i in range(-4, 5)]\n        ignore_extrema = True\n        x_categories = [\n            \"sixteenth\",\n            \"0.35\",\n            \"eighth\",\n            \"0.71\",\n            \"quarter\",\n            \"1.41\",\n            \"half\",\n            \"2.83\",\n            \"whole\",\n        ]\n    elif ignore_extrema:\n        if len(bin_centers) &lt; 3:\n            raise ValueError(\n                \"When ignore_extrema is True and \"\n                \"bin_centers is provided, at least \"\n                \"three bin centers must be provided.\"\n            )\n        bin_boundaries = centers_to_boundaries(bin_centers, \"log\")\n        bin_centers = bin_centers[1:-1]\n    else:\n        bin_boundaries = None\n\n    if not x_categories:\n        x_categories = [\n            f\"{bin_centers[i]:.2f}\" for i in range(len(bin_centers))\n        ]\n\n    h = Histogram1D(\n        bin_centers,\n        bin_boundaries,\n        \"log\",\n        cast(bool, ignore_extrema),\n        initial_value,\n    )  # type: ignore\n    tied_notes = set()\n    for note in score.find_all(Note):\n        # Ignore notes that are tied from previous notes by keeping track\n        # of them in a set:\n        if note in tied_notes:\n            # skip tied notes\n            continue\n        if note.tie:\n            # add tied notes to set so we can skip them later\n            tied_notes.add(note)\n        h.add_point(note.duration)\n    # normalize\n    h.normalize()\n\n    return Distribution(\n        name,\n        h.bins,\n        \"duration\",\n        [len(h.bins)],\n        x_categories,  # type: ignore\n        \"Duration\",\n        None,\n        \"Proportion\",\n    )\n</code></pre>"},{"location":"reference/time/durations/#amads.time.durdist1.duration_distribution_1(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/time/durations/#amads.time.durdist1.duration_distribution_1(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Duration Distribution'</code> )           \u2013            <p>A name for the distribution and plot title.</p>"},{"location":"reference/time/durations/#amads.time.durdist1.duration_distribution_1(bin_centers)","title":"<code>bin_centers</code>","text":"(<code>Union[list[float], None])</code>, default:                   <code>None</code> )           \u2013            <p>bin centers (optional) (see description for details).</p>"},{"location":"reference/time/durations/#amads.time.durdist1.duration_distribution_1(ignore_extrema)","title":"<code>ignore_extrema</code>","text":"(<code>bool</code>, default:                   <code>'unspecified'</code> )           \u2013            <p>If True, values outside the range of the bins are ignored (see description for details).</p>"},{"location":"reference/time/durations/#amads.time.durdist1.duration_distribution_1(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Matlab MIDI Toolbox avoids zero division by dividing counts by the total count plus 1e-12 times the number of counts. True enables this behavior as well as ignoring extreme values and setting the bins as described above. Default is False. If True, <code>bin_centers</code> and <code>ignore_extrema</code> must not be set.</p>"},{"location":"reference/time/durations/#amads.time.durdist2.duration_distribution_2","title":"duration_distribution_2","text":"<pre><code>duration_distribution_2(\n    score: Score,\n    name: str = \"Duration Pairs Distribution\",\n    bin_centers: list[float] | None = None,\n    ignore_extrema: bool | str = \"unspecified\",\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution\n</code></pre> <p>Returns the 2nd-order duration distribution of a musical score.</p> <p>Each duration is assigned to one of 9 bins. The default centers of the bins are on a logarithmic scale as follows:</p> component bin center (in units of quarters) 0 1/4 (sixteenth) 1 sqrt(2)/4 2 1/2 (eighth) 3 sqrt(2)/2 4 1 (quarter) 5 sqrt(2) 6 2 (half) 7 2*sqrt(2) 8 4 (whole) <p>These centers can be overridden by providing a list of bin centers.</p> <p>If <code>midi_toolbox_compatible</code> is True, the behavior is the same as in the Midi Toolbox <code>durdist1</code> function, with each bin count increased by 1e-12 to avoid division by zero, and values below $sqrt(2)/8$ quarters (just above a sixteenth triplet) and greater than $sqrt(2) \\cdot 4$ quarters (about 5.65685) are ignored. Also, an error is raised if either <code>bin_centers</code> or <code>ignore_extrema</code> are specified.</p> <p>If <code>midi_toolbox_compatible</code> is False (default), the normal behavior is as follows. If <code>bin_centers</code> is not provided, the default centers listed above are used. Values below the lowest or above the highest bins are assigned to those bins appropriately.</p> <p>One remaining case is where you want to ignore values outside the range of the bins. This can be done by setting <code>ignore_extrema</code> to True. If <code>bin_centers</code> is not provided, the default bins are used, and the extreme boundaries are set to $sqrt(2)/8$ quarters and $sqrt(2) \\cdot 4$ quarters respectively. If <code>bin_centers</code> is provided, they must include an additional lower bin and upper bin center value so that upper and lower boundaries can be computed as $sqrt(bin\\_centers[0] * bin\\_centers[1])$ and $sqrt(bin\\_centers[-2] * bin\\_centers[-1])$ respectively. Since values beyond the boundaries are ignored, the result will have $len(bin\\_centers) - 2$ bins.</p> <p>Authors: Yiming Huang, Roger B. Dannenberg</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Distribution</code>           \u2013            <p>containing and describing the distribution of note durations.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError: If the score is not monophonic (e.g. contains chords) or</code>             \u2013            <p>if the miditoolbox is True and either <code>bin_centers</code> or <code>ignore_extrema</code> optional parameters are set or <code>ignore_extrema</code> is true and less than 3 bin centers are provided.</p> </li> </ul> Source code in <code>amads/time/durdist2.py</code> <pre><code>def duration_distribution_2(\n    score: Score,\n    name: str = \"Duration Pairs Distribution\",\n    bin_centers: Optional[list[float]] = None,\n    ignore_extrema: Union[bool, str] = \"unspecified\",\n    miditoolbox_compatible: bool = False,\n) -&gt; Distribution:\n    r\"\"\"\n    Returns the 2nd-order duration distribution of a musical score.\n\n     Each duration is assigned to one of 9 bins.\n    The default centers of the bins are on a logarithmic scale as follows:\n\n    | component | bin center (in units of quarters) |\n    |-----------|-----------------------------------|\n    | 0         | 1/4 (sixteenth)                   |\n    | 1         | sqrt(2)/4                         |\n    | 2         | 1/2 (eighth)                      |\n    | 3         | sqrt(2)/2                         |\n    | 4         | 1 (quarter)                       |\n    | 5         | sqrt(2)                           |\n    | 6         | 2 (half)                          |\n    | 7         | 2*sqrt(2)                         |\n    | 8         | 4 (whole)                        |\n\n    These centers can be overridden by providing a list of bin centers.\n\n    If `midi_toolbox_compatible` is True, the behavior is the same as in\n    the Midi Toolbox `durdist1` function, with each bin count increased by\n    1e-12 to avoid division by zero, and values below $sqrt(2)/8$ quarters\n    (just above a sixteenth triplet) and greater than $sqrt(2) \\cdot 4$ quarters\n    (about 5.65685) are ignored. Also, an error is raised if either\n    `bin_centers` or `ignore_extrema` are specified.\n\n    If `midi_toolbox_compatible` is False (default), the normal behavior\n    is as follows. If `bin_centers` is not provided, the default centers\n    listed above are used. Values below the lowest or above the highest\n    bins are assigned to those bins appropriately.\n\n    One remaining case is where you want to ignore values outside the\n    range of the bins. This can be done by setting `ignore_extrema` to\n    True. If `bin_centers` is not provided, the default bins are used,\n    and the extreme boundaries are set to $sqrt(2)/8$ quarters and\n    $sqrt(2) \\cdot 4$ quarters respectively. If `bin_centers` is provided,\n    they must include an additional lower bin and upper bin center value\n    so that upper and lower boundaries can be computed as\n    $sqrt(bin\\\\_centers[0] * bin\\\\_centers[1])$ and\n    $sqrt(bin\\\\_centers[-2] * bin\\\\_centers[-1])$ respectively. Since values\n    beyond the boundaries are ignored, the result will have\n    $len(bin\\\\_centers) - 2$ bins.\n\n    &lt;small&gt;**Authors**: Yiming Huang, Roger B. Dannenberg&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze.\n    name : str\n        A name for the distribution and plot title.\n    bin_centers : Union[list[float], None])\n        bin centers (optional) (see description for details).\n    ignore_extrema : bool\n        If True, values outside the range of the bins are ignored\n        (see description for details).\n    miditoolbox_compatible : bool\n        Matlab MIDI Toolbox avoids zero division by dividing counts\n        by the total count plus 1e-12 times the number of counts.\n        True enables this behavior as well as ignoring extreme values\n        and setting the bins as described above. Default is False.\n        If True, `bin_centers` and `ignore_extrema` must not be set.\n\n    Returns\n    -------\n    Distribution\n        containing and describing the distribution of note durations.\n\n    Raises\n    ------\n    ValueError: If the score is not monophonic (e.g. contains chords) or\n        if the miditoolbox is True and either `bin_centers` or\n        `ignore_extrema` optional parameters are set or\n        `ignore_extrema` is true and less than 3 bin centers are provided.\n    \"\"\"\n    if miditoolbox_compatible:\n        if bin_centers is not None or ignore_extrema != \"unspecified\":\n            raise ValueError(\n                \"When miditoolbox_compatible is True, \"\n                \"bin_centers and ignore_extrema must not be set.\"\n            )\n    if not score.ismonophonic():\n        raise ValueError(\"Score must be monophonic\")\n\n    if ignore_extrema == \"unspecified\":\n        ignore_extrema = miditoolbox_compatible\n    else:\n        if not isinstance(ignore_extrema, bool):\n            raise ValueError(\n                \"ignore_extrema must be a boolean value or 'unspecified'\"\n            )\n    initial_value = 1e-12 if miditoolbox_compatible else 0.0\n    x_categories = None\n\n    if not bin_centers:\n        bin_boundaries = [2 ** ((i - 0.5) / 2.0) for i in range(-4, 6)]\n        bin_centers = [2 ** (i / 2.0) for i in range(-4, 5)]\n        ignore_extrema = True\n        x_categories = [\n            \"sixteenth\",\n            \"0.35\",\n            \"eighth\",\n            \"0.71\",\n            \"quarter\",\n            \"1.41\",\n            \"half\",\n            \"2.83\",\n            \"whole\",\n        ]\n    elif ignore_extrema:\n        if len(bin_centers) &lt; 3:\n            raise ValueError(\n                \"When ignore_extrema is True and \"\n                \"bin_centers is provided, at least \"\n                \"three bin centers must be provided.\"\n            )\n        bin_boundaries = centers_to_boundaries(bin_centers, \"log\")\n        bin_centers = bin_centers[1:-1]\n    else:\n        bin_boundaries = None\n\n    if not x_categories:\n        x_categories = [\n            f\"{bin_centers[i]:.2f}\" for i in range(len(bin_centers))\n        ]\n\n    h = Histogram2D(\n        bin_centers, bin_boundaries, \"log\", ignore_extrema, initial_value\n    )  # type: ignore\n\n    # TODO: what does matlab do with polyphony? This processes\n    # each part separately (no interval from last note in one part\n    # to the first note in the next part). This is probably\n    # unnecessary since we already require monophonic input.\n\n    # Ignore notes that are tied from previous notes by keeping track\n    # of them in a set:\n    tied_notes = set()\n    for p in score.find_all(Part):\n        part: Part = cast(Part, p)\n        prev_dur = None\n        prev_bin = None\n        for n in part.find_all(Note):\n            note: Note = cast(Note, n)\n            if note in tied_notes:\n                # skip tied notes\n                continue\n            if note.tie:\n                # add tied notes to set so we can skip them later\n                tied_notes.add(note)\n            dur = note.duration\n            prev_bin = h.add_point_2d(prev_dur, dur, 1.0, prev_bin)\n            prev_dur = dur\n            if prev_bin is None:\n                prev_dur = None\n    # normalize\n    h.normalize()\n\n    return Distribution(\n        name,\n        h.bins,\n        \"duration_pairs\",\n        [len(h.bins), len(h.bins)],\n        x_categories,  # type: ignore\n        \"Duration (to)\",\n        x_categories,  # type: ignore\n        \"Duration (from)\",\n    )\n</code></pre>"},{"location":"reference/time/durations/#amads.time.durdist2.duration_distribution_2(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/time/durations/#amads.time.durdist2.duration_distribution_2(name)","title":"<code>name</code>","text":"(<code>str</code>, default:                   <code>'Duration Pairs Distribution'</code> )           \u2013            <p>A name for the distribution and plot title.</p>"},{"location":"reference/time/durations/#amads.time.durdist2.duration_distribution_2(bin_centers)","title":"<code>bin_centers</code>","text":"(<code>Union[list[float], None])</code>, default:                   <code>None</code> )           \u2013            <p>bin centers (optional) (see description for details).</p>"},{"location":"reference/time/durations/#amads.time.durdist2.duration_distribution_2(ignore_extrema)","title":"<code>ignore_extrema</code>","text":"(<code>bool</code>, default:                   <code>'unspecified'</code> )           \u2013            <p>If True, values outside the range of the bins are ignored (see description for details).</p>"},{"location":"reference/time/durations/#amads.time.durdist2.duration_distribution_2(miditoolbox_compatible)","title":"<code>miditoolbox_compatible</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Matlab MIDI Toolbox avoids zero division by dividing counts by the total count plus 1e-12 times the number of counts. True enables this behavior as well as ignoring extreme values and setting the bins as described above. Default is False. If True, <code>bin_centers</code> and <code>ignore_extrema</code> must not be set.</p>"},{"location":"reference/time/meter/","title":"Meter","text":""},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience","title":"MetricalSalience","text":"<pre><code>MetricalSalience(\n    symbolic_pulses: ndarray | None = None,\n    quarter_bpm: float | None = None,\n    mu: float = 0.6,\n    sig: float = 0.3,\n)\n</code></pre> <p>Methods for storing array representations of metrical structure and derived salience values.</p> <p>Parameters:</p> <p>Attributes:</p> <ul> <li> <code>symbolic_pulses</code>           \u2013            <p>As above.</p> </li> <li> <code>absolute_pulses</code>           \u2013            <p>An adaptation of the symbolic pulse lengths array that maps each value from symbolic to seconds.</p> </li> <li> <code>salience_values</code>           \u2013            <p>An adaptation of the absolute pulse lengths to the equivalent salience values (see notes on <code>log_gaussian</code>).</p> </li> <li> <code>cumulative_salience_values</code>           \u2013            <p>A 1D array summation of the absolute salience values by column (one value per metrical position).</p> </li> <li> <code>indicator</code>           \u2013            <p>An indicator array for the (non-)presence of values at each position of the symbolic pulse lengths array. This can serve, for example, as the symbolic equivalent of the (absolute) <code>salience_values</code> array.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from amads.time.meter.representations import PulseLengths\n&gt;&gt;&gt; pl = [4, 2, 1, 0.5]\n&gt;&gt;&gt; pls = PulseLengths(pulse_lengths=pl, cycle_length=4)\n&gt;&gt;&gt; arr = pls.to_array()\n&gt;&gt;&gt; arr\narray([[4. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],\n       [2. , 0. , 0. , 0. , 2. , 0. , 0. , 0. ],\n       [1. , 0. , 1. , 0. , 1. , 0. , 1. , 0. ],\n       [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]])\n</code></pre> <pre><code>&gt;&gt;&gt; ms = MetricalSalience(symbolic_pulses=arr, quarter_bpm=120)\n&gt;&gt;&gt; ms.absolute_pulses\narray([[2.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  , 0.  ],\n       [1.  , 0.  , 0.  , 0.  , 1.  , 0.  , 0.  , 0.  ],\n       [0.5 , 0.  , 0.5 , 0.  , 0.5 , 0.  , 0.5 , 0.  ],\n       [0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25, 0.25]])\n</code></pre> <pre><code>&gt;&gt;&gt; ms.cumulative_salience_values\narray([2.39342011, 0.44793176, 1.4136999 , 0.44793176, 2.17446773,\n       0.44793176, 1.4136999 , 0.44793176])\n</code></pre> <p>Methods:</p> <ul> <li> <code>calculate_absolute_pulse_lengths</code>             \u2013              <p>Calculate absolute pulse lengths from</p> </li> <li> <code>calculate_salience_values</code>             \u2013              <p>Calculate salience values for items in the <code>symbolic_pulses</code></p> </li> <li> <code>calculate_cumulative_salience_values</code>             \u2013              <p>Calculate cumulative salience values by summing over columns.</p> </li> <li> <code>make_indicator</code>             \u2013              <p>Make a 2D indicator vector for the presence/absense of a pulse value at each position.</p> </li> <li> <code>plot</code>             \u2013              <p>Plot the salience values with their respective contribution.</p> </li> </ul> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def __init__(\n    self,\n    symbolic_pulses: Optional[np.ndarray] = None,\n    quarter_bpm: Optional[float] = None,\n    mu: float = 0.6,\n    sig: float = 0.3,\n):\n    self.symbolic_pulses = symbolic_pulses\n    self.quarter_bpm = quarter_bpm\n    self.mu = mu\n    self.sig = sig\n    self.absolute_pulses = self.calculate_absolute_pulse_lengths()\n    self.salience_values = self.calculate_salience_values()\n    self.cumulative_salience_values = (\n        self.calculate_cumulative_salience_values()\n    )\n    self.indicator = self.make_indicator()\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience(symbolic_pulses)","title":"<code>symbolic_pulses</code>","text":"(<code>ndarray | None</code>, default:                   <code>None</code> )           \u2013            <p>A NumPy array representing the symbolic pulse lengths by level.</p>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience(quarter_bpm)","title":"<code>quarter_bpm</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>The beats-per-minute corresponding to the symbolic value of a pulse length 1.0 in symbolic time. The user sets this value if/when calculating absolute length and salience values.</p>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience(mu)","title":"<code>mu</code>","text":"(<code>float</code>, default:                   <code>0.6</code> )           \u2013            <p>The mean of the Gaussian.</p>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience(sig)","title":"<code>sig</code>","text":"(<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The standard deviation of the Gaussian.</p>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.calculate_absolute_pulse_lengths","title":"calculate_absolute_pulse_lengths","text":"<pre><code>calculate_absolute_pulse_lengths()\n</code></pre> <p>Calculate absolute pulse lengths from the symbolic lengths (<code>symbolic_pulses</code>) and the BPM provided here for the 'quarter note' as reference value.</p> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def calculate_absolute_pulse_lengths(self):\n    \"\"\"\n    Calculate absolute pulse lengths from\n    the symbolic lengths (`symbolic_pulses`) and\n    the BPM provided here for the 'quarter note' as reference value.\n    \"\"\"\n    return self.symbolic_pulses * (60 / self.quarter_bpm)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.calculate_salience_values","title":"calculate_salience_values","text":"<pre><code>calculate_salience_values()\n</code></pre> <p>Calculate salience values for items in the <code>symbolic_pulses</code> using <code>log_gaussian</code> (see notes on that function).</p> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def calculate_salience_values(self):\n    \"\"\"\n    Calculate salience values for items in the `symbolic_pulses`\n    using `log_gaussian` (see notes on that function).\n    \"\"\"\n    return log_gaussian(self.absolute_pulses, self.mu, self.sig)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.calculate_cumulative_salience_values","title":"calculate_cumulative_salience_values","text":"<pre><code>calculate_cumulative_salience_values()\n</code></pre> <p>Calculate cumulative salience values by summing over columns.</p> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def calculate_cumulative_salience_values(self):\n    \"\"\"\n    Calculate cumulative salience values by summing over columns.\n    \"\"\"\n    return np.sum(self.salience_values, axis=0)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.make_indicator","title":"make_indicator","text":"<pre><code>make_indicator()\n</code></pre> <p>Make a 2D indicator vector for the presence/absense of a pulse value at each position.</p> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def make_indicator(self):\n    \"\"\"\n    Make a 2D indicator vector for the presence/absense of a pulse value at each position.\n    \"\"\"\n    return (self.symbolic_pulses &gt; 0).astype(int)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.plot","title":"plot","text":"<pre><code>plot(\n    symbolic_not_absolute: bool = False,\n    reverse_to_plot: bool = True,\n    show: bool = True,\n)\n</code></pre> <p>Plot the salience values with their respective contribution.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Figure</code>           \u2013            <p>A matplotlib.figure.Figure of the plotted salience values.</p> </li> </ul> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def plot(\n    self,\n    symbolic_not_absolute: bool = False,\n    reverse_to_plot: bool = True,\n    show: bool = True,\n):\n    \"\"\"\n    Plot the salience values with their respective contribution.\n\n    Parameters\n    ----------\n    symbolic_not_absolute: If True, plot only the indicator values (one per level).\n        If False (default), plot the tempo- and meter-sensitive, weighted salience values.\n    reverse_to_plot: If True (default), plot the fastest values at the bottom.\n\n    Returns\n    -------\n    Figure\n        A matplotlib.figure.Figure of the plotted salience values.\n    \"\"\"\n    if symbolic_not_absolute:\n        data = self.indicator\n    else:\n        data = self.salience_values\n\n    pulse_values_for_labels = self.symbolic_pulses[:, 0]\n\n    if reverse_to_plot:\n        data = data[::-1]  # TODO maybe revisit for elegance, checks\n        pulse_values_for_labels = pulse_values_for_labels[::-1]\n\n    num_layers = data.shape[0]\n    num_cols = data.shape[1]\n    fig, ax = plt.subplots()\n    bottom = np.zeros(num_cols)\n\n    for i in range(num_layers):\n        ax.bar(\n            np.arange(num_cols),\n            data[i],\n            bottom=bottom,\n            label=f\"Pulse={pulse_values_for_labels[i]}; IOI={pulse_values_for_labels[i] * 60 / self.quarter_bpm}\",\n        )\n        bottom += data[i]\n\n    ax.set_xlabel(\"Cycle-relative position\")\n    ax.set_ylabel(\"Weighting\")\n    ax.legend()\n    ax.grid(True)\n    if show:\n        plt.show()\n    return fig\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.plot(symbolic_not_absolute)","title":"<code>symbolic_not_absolute</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If False (default), plot the tempo- and meter-sensitive, weighted salience values.</p>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.MetricalSalience.plot(reverse_to_plot)","title":"<code>reverse_to_plot</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.log_gaussian","title":"log_gaussian","text":"<pre><code>log_gaussian(arr: ndarray, mu: float = 0.6, sig: float = 0.3)\n</code></pre> <p>Compute a log-linear Gaussian which is the basis of individual pulse salience values. To avoid log(0) issues, <code>np.clip</code> values to be always greater than 0. See also MetricalSalience.calculate_salience_values.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; log_gaussian(np.array([0.06, 0.6, 6.0])) # demo log-lin symmetry\narray([0.00386592, 1.        , 0.00386592])\n</code></pre> <pre><code>&gt;&gt;&gt; log_gaussian(np.array([0.5, 1., 2.])) # 2x between levels\narray([0.96576814, 0.76076784, 0.21895238])\n</code></pre> Source code in <code>amads/time/meter/attractor_tempos.py</code> <pre><code>def log_gaussian(arr: np.ndarray, mu: float = 0.6, sig: float = 0.3):\n    \"\"\"\n    Compute a log-linear Gaussian which is the basis of individual pulse salience values.\n    To avoid log(0) issues, `np.clip` values to be always greater than 0.\n    See also [MetricalSalience.calculate_salience_values]\n    [amads.time.meter.attractor_tempos.MetricalSalience.calculate_salience_values].\n\n\n    Parameters\n    ----------\n    mu: float\n        The mean of the Gaussian.\n    sig: float\n        The standard deviation of the Gaussian.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; log_gaussian(np.array([0.06, 0.6, 6.0])) # demo log-lin symmetry\n    array([0.00386592, 1.        , 0.00386592])\n\n    &gt;&gt;&gt; log_gaussian(np.array([0.5, 1., 2.])) # 2x between levels\n    array([0.96576814, 0.76076784, 0.21895238])\n\n    \"\"\"\n    if sig &lt;= 0:\n        raise ValueError(\"Standard deviation (`sig`) must be positive.\")\n    if mu &lt;= 0:\n        raise ValueError(\"Mean (`mu`) must be positive.\")\n    x = np.clip(arr, 1e-9, None)\n    return np.exp(-(np.log10(x / mu) ** 2 / (2 * sig**2)))\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.log_gaussian(mu)","title":"<code>mu</code>","text":"(<code>float</code>, default:                   <code>0.6</code> )           \u2013            <p>The mean of the Gaussian.</p>"},{"location":"reference/time/meter/#amads.time.meter.attractor_tempos.log_gaussian(sig)","title":"<code>sig</code>","text":"(<code>float</code>, default:                   <code>0.3</code> )           \u2013            <p>The standard deviation of the Gaussian.</p>"},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter","title":"MetricalSplitter","text":"<pre><code>MetricalSplitter(\n    note_start: float,\n    note_length: float,\n    start_hierarchy: list[list],\n    split_same_level: bool = True,\n)\n</code></pre> <p>Split up notes and/or rests to reflect a specified metrical hierarchy.</p> <p>This class takes in a representation of a note in terms of the start position and duration, along with a metrical context and returns a list of start-duration pairs for the constituent parts of the broken-up note.</p> <p>The metrical context should be expressed in the form of a <code>start_hierarchy</code> (effectively a list of lists for the hierarchy). This can be provided directly or made via various classes in the meter module (see notes there).</p> <p>The basic premise here is that a single note can only traverse metrical boundaries for levels lower than the one it starts on. If it traverses the metrical boundary of a higher level, then it is split at that position into two note-heads. This split registers as a case of syncopation for those algorithms and as a case for two note-heads to be connected by a tie in notation.</p> <p>There are many variants on this basic setup. This class aims to support almost any such variant, while providing easy defaults for simple, standard practice.</p> <p>The flexibility comes from the definition of a metrical structure (for which see the <code>MetricalHierarchy</code> class).</p> <p>Each split of the note duration serves to move up one metrical level. For instance, for the 4/4 example above, a note of duration 2.0 starting at start 0.25 connects to 0.5 in level 3 (duration = 0.25), then 0.5 connects to 1.0 in level 2 (duration = 0.5), then 1.0 connects to 2.0 in level 1 (duration = 1.0), and this leaves a duration of 0.25 to start on 2.0. The data is returned as a list of (position, duration) tuples. The values for the example would be: [(0.25, 0.25), (0.5, 0.5), (1.0, 1.0), (1.0, 0.25)] as demonstrated below.</p> <p>If the note runs past the end of the metrical span, the remaining value is stored with the <code>start_duration_pairs</code> recording the within-measure pairs and <code>remaining_length</code> attribute for the rest.</p> <p>If the <code>note_start</code> is not in the hierarchy, then the first step is to map to the next nearest value in the lowest level.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from amads.time.meter.representations import TimeSignature, PulseLengths\n&gt;&gt;&gt; m = TimeSignature(as_string=\"4/4\")\n&gt;&gt;&gt; start_hierarchy = m.to_start_hierarchy()\n&gt;&gt;&gt; start_hierarchy\n[[0.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]]\n</code></pre> <pre><code>&gt;&gt;&gt; split = MetricalSplitter(0.25, 2.0, start_hierarchy=start_hierarchy, split_same_level=False)\n&gt;&gt;&gt; split.start_duration_pairs\n[(0.25, 0.75), (1.0, 1.25)]\n</code></pre> <pre><code>&gt;&gt;&gt; split = MetricalSplitter(0.25, 2.0, start_hierarchy=start_hierarchy, split_same_level=True)\n&gt;&gt;&gt; split.start_duration_pairs\n[(0.25, 0.75), (1.0, 1.0), (2.0, 0.25)]\n</code></pre> <pre><code>&gt;&gt;&gt; m.fill_2s_3s()\n&gt;&gt;&gt; start_hierarchy = m.to_start_hierarchy()\n&gt;&gt;&gt; start_hierarchy\n[[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]]\n</code></pre> <pre><code>&gt;&gt;&gt; meter_from_pulses = PulseLengths([4, 2, 1, 0.5, 0.25], cycle_length=4)\n&gt;&gt;&gt; start_hierarchy = meter_from_pulses.to_start_hierarchy()\n&gt;&gt;&gt; start_hierarchy[-1]\n[0.0, 0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 1.75, 2.0, 2.25, 2.5, 2.75, 3.0, 3.25, 3.5, 3.75, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; split = MetricalSplitter(0.25, 4.0, start_hierarchy=start_hierarchy)\n&gt;&gt;&gt; split.start_duration_pairs\n[(0.25, 0.25), (0.5, 0.5), (1.0, 1.0), (2.0, 2.0)]\n</code></pre> <pre><code>&gt;&gt;&gt; split.remaining_length\n0.25\n</code></pre> <pre><code>&gt;&gt;&gt; split = MetricalSplitter(0.05, 2.0, start_hierarchy=start_hierarchy)\n&gt;&gt;&gt; split.start_duration_pairs\n[(0.05, 0.2), (0.25, 0.25), (0.5, 0.5), (1.0, 1.0), (2.0, 0.05)]\n</code></pre> <p>Methods:</p> <ul> <li> <code>level_pass</code>             \u2013              <p>Given a <code>start_hierarchy</code>,</p> </li> <li> <code>advance_step</code>             \u2013              <p>For a start position, and a metrical level expressed as a list of starts,</p> </li> </ul> Source code in <code>amads/time/meter/break_it_up.py</code> <pre><code>def __init__(\n    self,\n    note_start: float,\n    note_length: float,\n    start_hierarchy: list[list],\n    split_same_level: bool = True,\n):\n\n    self.note_length = note_length\n    self.note_start = note_start\n    self.start_hierarchy = start_hierarchy\n    self.split_same_level = split_same_level\n\n    # Initialise\n    self.start_duration_pairs = []\n    self.updated_start = note_start\n    self.remaining_length = note_length\n    self.level_pass()\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter(note_start)","title":"<code>note_start</code>","text":"(<code>float</code>)           \u2013            <p>The starting position of the note (or rest).</p>"},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter(note_length)","title":"<code>note_length</code>","text":"(<code>float</code>)           \u2013            <p>The length (duration) of the note (or rest).</p>"},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter(split_same_level)","title":"<code>split_same_level</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>When creating hierarchies, decide whether to split elements at the same level, e.g., 1/8 and 2/8 in 6/8. In cases of metrical structures with a 3-grouping (two \"weak\" events between a \"strong\" in compound signatures like 6/8), some conventions choose to split notes within-level as well as between them. For instance, with a quarter note starting on the second eighth note (start 0.5) of 6/8, some will want to split that into two 1/8th notes, divided on the third eighth note position, while others will want to leave this intact. The <code>split_same_level</code> option accommodates this: it affects the within-level split when set to True and not otherwise (default).</p>"},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter.level_pass","title":"level_pass","text":"<pre><code>level_pass()\n</code></pre> <p>Given a <code>start_hierarchy</code>, this method iterates across the levels of that hierarchy to find the current start position, and (through <code>advance_step</code>) the start position to map to.</p> <p>This method runs once for each such mapping, typically advancing up one (or more) layer of the metrical hierarchy with each call. \u201cTypically\u201d because <code>split_same_level</code> is supported where relevant.</p> <p>Each iteration creates a new start-duration pair stored in the start_duration_pairs list that records the constituent parts of the split note.</p> Source code in <code>amads/time/meter/break_it_up.py</code> <pre><code>def level_pass(self):\n    \"\"\"\n    Given a `start_hierarchy`,\n    this method iterates across the levels of that hierarchy to find the\n    current start position, and (through `advance_step`) the start\n    position to map to.\n\n    This method runs once for each such mapping, typically advancing\n    up one (or more) layer of the metrical hierarchy with each call.\n    \u201cTypically\u201d because `split_same_level` is supported where relevant.\n\n    Each iteration creates a new start-duration pair\n    stored in the start_duration_pairs list\n    that records the constituent parts of the split note.\n    \"\"\"\n\n    for level_index in range(len(self.start_hierarchy)):\n\n        if (\n            self.remaining_length &lt;= 0\n        ):  # sic, here due to the various routes through\n            return\n\n        if (\n            self.updated_start == self.start_hierarchy[0][-1]\n        ):  # finished metrical span\n            return\n\n        this_level = self.start_hierarchy[level_index]\n\n        if self.updated_start in this_level:\n            if level_index == 0:  # i.e., updated_start == 0\n                self.start_duration_pairs.append(\n                    (self.updated_start, round(self.remaining_length, 4))\n                )\n                return\n            else:  # level up. NB: duplicates in nested hierarchy help here\n                if self.split_same_level:  # relevant option for e.g., 6/8\n                    self.advance_step(this_level)\n                else:  # usually\n                    self.advance_step(self.start_hierarchy[level_index - 1])\n\n    if self.remaining_length &gt; 0:  # start not in the hierarchy at all\n        self.advance_step(\n            self.start_hierarchy[-1]\n        )  # get to the lowest level\n        # Now start the process with the metrical structure:\n        self.level_pass()\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.break_it_up.MetricalSplitter.advance_step","title":"advance_step","text":"<pre><code>advance_step(positions_list: list)\n</code></pre> <p>For a start position, and a metrical level expressed as a list of starts, find the next higher value from those levels. Used for determining iterative divisions.</p> Source code in <code>amads/time/meter/break_it_up.py</code> <pre><code>def advance_step(self, positions_list: list):\n    \"\"\"\n    For a start position, and a metrical level expressed as a list of starts,\n    find the next higher value from those levels.\n    Used for determining iterative divisions.\n    \"\"\"\n    for p in positions_list:\n        if p &gt; self.updated_start:\n            duration_to_next_position = p - self.updated_start\n            if self.remaining_length &lt;= duration_to_next_position:\n                self.start_duration_pairs.append(\n                    (self.updated_start, round(self.remaining_length, 4))\n                )\n                # done but still reduce `remaining_length` to end the whole process in level_pass\n                self.remaining_length -= duration_to_next_position\n                return\n            else:  # self.remaining_length &gt; duration_to_next_position:\n                self.start_duration_pairs.append(\n                    (\n                        self.updated_start,\n                        round(duration_to_next_position, 4),\n                    )\n                )\n                # Updated start and position; run again\n                self.updated_start = p\n                self.remaining_length -= duration_to_next_position\n                self.level_pass()  # NB: to re-start from top as may have jumped a level\n                return\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.grid","title":"grid","text":"<p>The module seeks to find the smallest metrical pulse level (broadly, \u201ctatum\u201d) in response to a source and user tolerance settings.</p> <p>In the simplest case, a source records its metrical positions exactly, including fractional values as needed. We provide functionality for standard, general algorithms in these cases (greatest common denominator and fraction estimation) which are battle-tested and computationally efficient.</p> <p>In metrically simple and regular cases like chorales, this value might be the eighth note, for instance. In other cases, it gets more complex. For example, Beethoven's Opus 10 Nr.2 Movement 1 includes a triplet 16th turn figure in measure 1 (tatum = 1/6 division of the quarter note) and also dotted rhythms that pair a dotted 16th with a 32nd note from measure 5 (tatum = 1/8 division of the quarter). So to catch these cases in the first 5 measures, we need the lowest common multiple of 6 and 8, i.e., 24 per quarter (or 48 bins per 2/4 measure).</p> <p>In cases of extreme complexity, there may be a \u201cneed\u201d for a considerably shorter tatum pulse (and, equivalently, a greater number of bins). This is relevant for some modern music, as well as cases where grace notes are assigned a specific metrical position/duration (though in many encoded standards, grace notes are not assigned separate metrical positions).</p> <p>Moreover, there are musical sources that do not encode fractional time values, but rather approximation with floats. These include any:</p> <ul> <li>frame-wise representations of time (including MIDI and any attempted     transcription from audio),</li> <li>processing via code libraries that likewise convert fractions to floats,</li> <li>secondary representations like most CSVs.</li> </ul> <p>As division by 3 leads to rounding, approximation, and floating point errors, and as much music involves those divisions, this is widely relevant.</p> <p>The standard algorithms often fail in these contexts, largely because symbolic music tends to prioritise certain metrical divisions over others. For example, 15/16 is a commonly used metrical position (largely because 16 is a power of 2), but 14/15 is not. That being the case, while 14/15 might be a better mathematical fit for approximating a value, it is typically incorrect as the musical solution. We can use the term \u201cincorrect\u201d advisedly here because the floats are secondary representations of a known fractional ground truth. Doctests demonstrate some of these cases.</p> <p>Author: Mark Gotham</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.starts_to_int_relative_counter","title":"starts_to_int_relative_counter","text":"<pre><code>starts_to_int_relative_counter(\n    starts: Iterable[float], decimal_places: int = 5\n)\n</code></pre> <p>Find and count all fractional parts of an iterable.</p> <p>Simple wrapper function to create a Counter (dict) that maps the fractional parts of starts ($start - int(start)$, e.g., 1.5 becomes 0.5) to the number of occurrences of that fraction (e.g., starts 1.5 and 2.5 produce the mapping 0.5: 2 in the result).</p> <p>Fractional parts are rounded to <code>decimal_places</code> decimal points (default 5), which gives a tolerance down to 0.00001 and accommodates common musical fractions such as thirds (0.33333) and sixths (0.16667).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; test_list = [0.0, 0.0, 0.5, 1.0, 1.5, 1.75, 2.0, 2.3333333333, 2.666667, 3.00000000000000001]\n&gt;&gt;&gt; starts_to_int_relative_counter(test_list)\nCounter({0.0: 5, 0.5: 2, 0.75: 1, 0.33333: 1, 0.66667: 1})\n</code></pre> Source code in <code>amads/time/meter/grid.py</code> <pre><code>def starts_to_int_relative_counter(\n    starts: Iterable[float], decimal_places: int = 5\n):\n    \"\"\"\n    Find and count all fractional parts of an iterable.\n\n    Simple wrapper function to create a Counter (dict) that\n    maps the fractional parts of starts ($start - int(start)$, e.g.,\n    1.5 becomes 0.5) to the number of occurrences of that fraction\n    (e.g., starts 1.5 and 2.5 produce the mapping 0.5: 2 in the result).\n\n    Fractional parts are rounded to `decimal_places` decimal points (default 5),\n    which gives a tolerance down to 0.00001 and accommodates common musical\n    fractions such as thirds (0.33333) and sixths (0.16667).\n\n    Examples\n    --------\n    &gt;&gt;&gt; test_list = [0.0, 0.0, 0.5, 1.0, 1.5, 1.75, 2.0, 2.3333333333, 2.666667, 3.00000000000000001]\n    &gt;&gt;&gt; starts_to_int_relative_counter(test_list)\n    Counter({0.0: 5, 0.5: 2, 0.75: 1, 0.33333: 1, 0.66667: 1})\n    \"\"\"\n    for item in starts:\n        if not isinstance(item, Number):\n            raise TypeError(\n                f\"All items in `starts` must be numeric (int or float). Found: {type(item)}\"\n            )\n\n    return Counter([round(x - int(x), decimal_places) for x in starts])\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.grid.approximate_pulse_match_with_priority_list","title":"approximate_pulse_match_with_priority_list","text":"<pre><code>approximate_pulse_match_with_priority_list(\n    x: float,\n    distance_threshold: float = 0.001,\n    pulse_priority_list: list | None = None,\n) -&gt; Fraction | None\n</code></pre> <p>Takes a float and an ordered list of possible pulses, returning the first pulse in the list to approximate the input float.</p> <p>This is a new function by MG as reported in [1].</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Union(None, Fraction)</code>           \u2013            <p>None for no match, or a Fraction(numerator, denominator).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>pulse_priority_list</code> contains 0 or None.</p> </li> </ul> References <p>[1] Gotham, Mark R. H. (2025). Keeping Score: Computational Methods for the Analysis of Encoded (\"Symbolic\") Musical Scores (v0.3+) Zenodo. https://doi.org/10.5281/zenodo.14938027</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; approximate_pulse_match_with_priority_list(5/6)\nFraction(1, 6)\n</code></pre> <pre><code>&gt;&gt;&gt; test_case = round(float(11/12), 5)\n&gt;&gt;&gt; test_case\n0.91667\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_pulse_match_with_priority_list(test_case)\nFraction(1, 12)\n</code></pre> <p>Note that <code>Fraction(1, 12)</code> is included in the default list, while <code>Fraction(11, 12)</code> is not as that would be an extremely unusual tatum value.</p> <p>If the <code>distance_threshold</code> is very coarse, expect errors:</p> <pre><code>&gt;&gt;&gt; approximate_pulse_match_with_priority_list(29 + 1/12, distance_threshold=0.1)\nFraction(1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; approximate_pulse_match_with_priority_list(29 + 1/12, distance_threshold=0.01)\nFraction(1, 12)\n</code></pre> Source code in <code>amads/time/meter/grid.py</code> <pre><code>def approximate_pulse_match_with_priority_list(\n    x: float,\n    distance_threshold: float = 0.001,\n    pulse_priority_list: Optional[list] = None,\n) -&gt; Optional[Fraction]:\n    \"\"\"\n    Takes a float and an ordered list of possible pulses,\n    returning the first pulse in the list to approximate the input float.\n\n    This is a new function by MG as reported in [1].\n\n    Parameters\n    ----------\n    x : float\n        Input value to be approximated as a fraction.\n    distance_threshold : float\n        The distance threshold.\n    pulse_priority_list : list[Fraction]\n        Ordered list of pulse values to try.\n        If unspecified, this defaults to 4, 3, 2, 1.5, 1, and the\n        default output of `generate_n_smooth_numbers`.\n\n    Returns\n    -------\n    Union(None, Fraction)\n        None for no match, or a Fraction(numerator, denominator).\n\n    Raises\n    ------\n    ValueError\n        If `pulse_priority_list` contains 0 or None.\n\n    References\n    ----------\n    [1] Gotham, Mark R. H. (2025). Keeping Score: Computational Methods for the\n    Analysis of Encoded (\"Symbolic\") Musical Scores (v0.3+) Zenodo.\n    https://doi.org/10.5281/zenodo.14938027\n\n    Examples\n    --------\n    &gt;&gt;&gt; approximate_pulse_match_with_priority_list(5/6)\n    Fraction(1, 6)\n\n    &gt;&gt;&gt; test_case = round(float(11/12), 5)\n    &gt;&gt;&gt; test_case\n    0.91667\n\n    &gt;&gt;&gt; approximate_pulse_match_with_priority_list(test_case)\n    Fraction(1, 12)\n\n    Note that `Fraction(1, 12)` is included in the default list,\n    while `Fraction(11, 12)` is not as that would be an extremely unusual tatum value.\n\n    If the `distance_threshold` is very coarse, expect errors:\n    &gt;&gt;&gt; approximate_pulse_match_with_priority_list(29 + 1/12, distance_threshold=0.1)\n    Fraction(1, 1)\n\n    &gt;&gt;&gt; approximate_pulse_match_with_priority_list(29 + 1/12, distance_threshold=0.01)\n    Fraction(1, 12)\n\n    \"\"\"\n    if pulse_priority_list is None:\n        pulse_priority_list = [\n            Fraction(4, 1),  # 4\n            Fraction(3, 1),  # 3\n            Fraction(2, 1),  # 2\n            Fraction(3, 2),  # 1.5\n        ]\n        pulse_priority_list += generate_n_smooth_numbers(\n            invert=True\n        )  # 1, 1/2, 1/3, ...\n\n    if 0 in pulse_priority_list:\n        raise ValueError(\"`pulse_priority_list` must not contain 0.\")\n    if None in pulse_priority_list:\n        raise ValueError(\"`pulse_priority_list` must not contain None.\")\n\n    for p in pulse_priority_list:\n        if not isinstance(p, (Fraction, int)):\n            raise ValueError(\n                f\"All entries in `pulse_priority_list` must be Fraction or int. Found: {type(p)}\"\n            )\n        test_case = x / p\n        diff = abs(round(test_case) - test_case)\n        if diff &lt; distance_threshold:\n            return p\n\n    return None\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.grid.approximate_pulse_match_with_priority_list(x)","title":"<code>x</code>","text":"(<code>float</code>)           \u2013            <p>Input value to be approximated as a fraction.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.approximate_pulse_match_with_priority_list(distance_threshold)","title":"<code>distance_threshold</code>","text":"(<code>float</code>, default:                   <code>0.001</code> )           \u2013            <p>The distance threshold.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.approximate_pulse_match_with_priority_list(pulse_priority_list)","title":"<code>pulse_priority_list</code>","text":"(<code>list[Fraction]</code>, default:                   <code>None</code> )           \u2013            <p>Ordered list of pulse values to try. If unspecified, this defaults to 4, 3, 2, 1.5, 1, and the default output of <code>generate_n_smooth_numbers</code>.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.generate_n_smooth_numbers","title":"generate_n_smooth_numbers","text":"<pre><code>generate_n_smooth_numbers(\n    bases: list[int] = [2, 3], max_value: int = 100, invert: bool = True\n) -&gt; list\n</code></pre> <p>Generates a sorted list of \"N-smooth\" numbers up to a specified maximum value.</p> <p>An N-smooth number is a positive integer whose prime factors are all less than or equal to the largest number in the <code>bases</code> list.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>A sorted list of N-smooth numbers (or their reciprocals if <code>invert=True</code>).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>bases</code> contains non-integers or values &lt;= 1, or if <code>max_value</code> is not a positive integer.</p> </li> </ul> <p>Examples:</p> <p>Our metrical default:</p> <pre><code>&gt;&gt;&gt; generate_n_smooth_numbers(invert=False)  # all defaults `max_value=100`, `bases [2, 3]`\n[1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, 32, 36, 48, 54, 64, 72, 81, 96]\n</code></pre> <p>Other cases:</p> <pre><code>&gt;&gt;&gt; generate_n_smooth_numbers(max_value=10, bases=[2], invert=False)\n[1, 2, 4, 8]\n&gt;&gt;&gt; generate_n_smooth_numbers(max_value=20, bases=[2, 3], invert=False)\n[1, 2, 3, 4, 6, 8, 9, 12, 16, 18]\n&gt;&gt;&gt; generate_n_smooth_numbers(max_value=50, bases=[2, 3, 5], invert=False)\n[1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50]\n</code></pre> <p>By default, invert is True:</p> <pre><code>&gt;&gt;&gt; generate_n_smooth_numbers()[-1]\nFraction(1, 96)\n</code></pre> Source code in <code>amads/time/meter/grid.py</code> <pre><code>def generate_n_smooth_numbers(\n    bases: list[int] = [2, 3], max_value: int = 100, invert: bool = True\n) -&gt; list:\n    \"\"\"\n    Generates a sorted list of \"N-smooth\" numbers up to a specified maximum value.\n\n    An N-smooth number is a positive integer whose prime factors are all\n    less than or equal to the largest number in the `bases` list.\n\n    Parameters\n    ----------\n    max_value : int, optional\n        The maximum value to generate numbers up to. Defaults to 100.\n    bases : list, optional\n        A list of base values (integers &gt; 1) representing the maximum allowed\n        prime factor. Defaults to [2, 3].\n    invert : bool\n        If True, return Fraction(1, x) for each smooth number x instead of x itself.\n        Defaults to True.\n\n    Returns\n    -------\n    list\n        A sorted list of N-smooth numbers (or their reciprocals if `invert=True`).\n\n    Raises\n    ------\n    ValueError\n        If `bases` contains non-integers or values &lt;= 1, or if `max_value` is\n        not a positive integer.\n\n    Examples\n    --------\n    Our metrical default:\n    &gt;&gt;&gt; generate_n_smooth_numbers(invert=False)  # all defaults `max_value=100`, `bases [2, 3]`\n    [1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 27, 32, 36, 48, 54, 64, 72, 81, 96]\n\n    Other cases:\n    &gt;&gt;&gt; generate_n_smooth_numbers(max_value=10, bases=[2], invert=False)\n    [1, 2, 4, 8]\n    &gt;&gt;&gt; generate_n_smooth_numbers(max_value=20, bases=[2, 3], invert=False)\n    [1, 2, 3, 4, 6, 8, 9, 12, 16, 18]\n    &gt;&gt;&gt; generate_n_smooth_numbers(max_value=50, bases=[2, 3, 5], invert=False)\n    [1, 2, 3, 4, 5, 6, 8, 9, 10, 12, 15, 16, 18, 20, 24, 25, 27, 30, 32, 36, 40, 45, 48, 50]\n\n    By default, invert is True:\n    &gt;&gt;&gt; generate_n_smooth_numbers()[-1]\n    Fraction(1, 96)\n\n    \"\"\"\n    if not all(isinstance(b, int) and b &gt; 1 for b in bases):\n        raise ValueError(\"Bases must be a list of integers greater than 1.\")\n\n    if not isinstance(max_value, int) or max_value &lt;= 0:\n        raise ValueError(\"max_value must be a positive integer.\")\n\n    seen = {1}\n    queue = deque([1])\n\n    while queue:\n        current = queue.popleft()\n        for base in bases:\n            next_num = current * base\n            if next_num &lt;= max_value and next_num not in seen:\n                seen.add(next_num)\n                queue.append(next_num)\n\n    smooth_numbers = sorted(seen)\n\n    if invert:\n        return [Fraction(1, x) for x in smooth_numbers]\n    else:\n        return smooth_numbers\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.grid.generate_n_smooth_numbers(max_value)","title":"<code>max_value</code>","text":"(<code>int</code>, default:                   <code>100</code> )           \u2013            <p>The maximum value to generate numbers up to. Defaults to 100.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.generate_n_smooth_numbers(bases)","title":"<code>bases</code>","text":"(<code>list</code>, default:                   <code>[2, 3]</code> )           \u2013            <p>A list of base values (integers &gt; 1) representing the maximum allowed prime factor. Defaults to [2, 3].</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.generate_n_smooth_numbers(invert)","title":"<code>invert</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, return Fraction(1, x) for each smooth number x instead of x itself. Defaults to True.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.get_tatum_from_priorities","title":"get_tatum_from_priorities","text":"<pre><code>get_tatum_from_priorities(\n    starts: Iterable,\n    pulse_priority_list: list | None = None,\n    distance_threshold: float = 1 / 24,\n    proportion_threshold: float | None = 0.999,\n) -&gt; Fraction\n</code></pre> <p>Estimate metrical positions from floats.</p> <p>This function serves cases where temporal position values are defined relative to some origin, such as the time elapsed since:</p> <ul> <li>the start of a piece (or section) in quarter notes (or some other     consistent symbolic value)</li> <li>the start of a measure (or other container), assuming those measures     are of a constant duration.</li> </ul> <p>Use cases include the attempted retrieval of true metrical positions (fractions) from rounded versions thereof (floats). See also notes at the top of this module for why standard algorithms fail at this task in a musical setting.</p> <p>This function serves those common cases where there is a need to balance between capturing event positions as accurately as possible while not making excessive complexity to account for a few anomalous notes. Most importantly, it enables the explicit prioritisation of common pulse divisions. Defaults prioritse 16x divsion over 15x, for example.</p> <p>Parameters:</p> <ul> <li> </li> <li> </li> <li> </li> <li> </li> </ul> <p>Examples:</p> <p>A simple case, expressed in different ways.</p> <pre><code>&gt;&gt;&gt; tatum_1_6 = [0, 1/3, Fraction(1, 2), 1]\n&gt;&gt;&gt; get_tatum_from_priorities(tatum_1_6)\nFraction(1, 6)\n</code></pre> <pre><code>&gt;&gt;&gt; tatum_1_6 = [0, 0.333, 0.5, 1]\n&gt;&gt;&gt; get_tatum_from_priorities(tatum_1_6)\nFraction(1, 6)\n</code></pre> <p>An example of values from the BPSD dataset (Zeitler et al.).</p> <pre><code>&gt;&gt;&gt; from amads.time.meter import profiles\n&gt;&gt;&gt; bpsd_Op027No1 = profiles.BPSD().op027No1_01 # /16 divisions of the measure and /12 too (from m.48). Tatum 1/48\n&gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/24) # proportion_threshold=0.999\nFraction(1, 48)\n</code></pre> <p>Change the <code>distance_threshold</code></p> <pre><code>&gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/6) # proportion_threshold=0.999\nFraction(1, 12)\n</code></pre> <p>Change the <code>proportion_threshold</code>:</p> <pre><code>&gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/24, proportion_threshold=0.5)\nFraction(1, 24)\n</code></pre> <pre><code>&gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/24, proportion_threshold=0.9)\nFraction(1, 48)\n</code></pre> <p>This also works without any floats (and therefore, no priorities needed)</p> <pre><code>&gt;&gt;&gt; get_tatum_from_priorities([1, 3])\nFraction(1, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; get_tatum_from_priorities([0, 3])\nFraction(3, 1)\n</code></pre> <pre><code>&gt;&gt;&gt; get_tatum_from_priorities([0, Fraction(1, 3), Fraction(4, 6)])\nFraction(1, 3)\n</code></pre> Source code in <code>amads/time/meter/grid.py</code> <pre><code>def get_tatum_from_priorities(\n    starts: Iterable,\n    pulse_priority_list: Optional[list] = None,\n    distance_threshold: float = 1 / 24,\n    proportion_threshold: Optional[float] = 0.999,\n) -&gt; Fraction:\n    \"\"\"\n    Estimate metrical positions from floats.\n\n    This function serves cases where temporal position values are defined\n    relative to some origin, such as the time elapsed since:\n\n    - the start of a piece (or section) in quarter notes (or some other\n        consistent symbolic value)\n    - the start of a measure (or other container), assuming those measures\n        are of a constant duration.\n\n    Use cases include the attempted retrieval of true metrical\n    positions (fractions) from rounded versions thereof (floats).\n    See also notes at the top of this module\n    for why standard algorithms fail at this task in a musical setting.\n\n    This function serves those common cases where there is a need to balance\n    between capturing event positions as accurately as possible while not\n    making excessive complexity to account for a few anomalous notes.\n    Most importantly, it enables the explicit prioritisation of common pulse\n    divisions. Defaults prioritse 16x divsion over 15x, for example.\n\n\n    Parameters\n    ----------\n    starts\n        Any iterable giving the starting position of events.\n        Each constituent start must be expressed relative to a reference value such that\n        X.0 is the start of a unit,\n        X.5 is the mid-point, etc.\n        Floats are the main expected type here (as above); we seek to reverse engineer a plausible fraction from each.\n        If any start is already an exact Fraction or int, then it stays as it is, whatever the user setting:\n        this functionality serves to improve the accuracy of timing data; there's no question of ever reducing it,\n        even if user settings suggest that.\n    pulse_priority_list\n        The point of this function is to encode musically common pulse values.\n        This argument defaults to numbers under 100 with prime\n        factors of only 2 and 3 (\u201c3-smooth\u201d), in increasing order.\n        The user can define any alternative list, optionally making use of\n        `generate_n_smooth_numbers` for the purpose.\n        See notes at `approximate_fraction_with_priorities`.\n        Make sure this list is exhaustive: the function will raise an error if no match is found.\n    distance_threshold\n        The rounding tolerance between a temporal position multiplied by\n        the bin value and the nearest integer.\n        This is essential when working with floats.\n        Defaults to 1/24, but can be set to any value.\n    proportion_threshold\n        Optionally, set a proportional number of events notes to account for.\n        This option requires that the `starts` be expressed as a Counter,\n        ordered from most to least common.  The default of .999 means that\n        once at least 99.9% of the source's notes are handled, we ignore the rest.\n        This is achieved by iterating through the Counter object of values relative\n        to the unit (e.g., 1.5 -&gt; 0.5).\n        This option should be chosen with care as, in this case,\n        only the unit value and equal divisions thereof are considered.\n\n    Examples\n    --------\n\n    A simple case, expressed in different ways.\n\n    &gt;&gt;&gt; tatum_1_6 = [0, 1/3, Fraction(1, 2), 1]\n    &gt;&gt;&gt; get_tatum_from_priorities(tatum_1_6)\n    Fraction(1, 6)\n\n    &gt;&gt;&gt; tatum_1_6 = [0, 0.333, 0.5, 1]\n    &gt;&gt;&gt; get_tatum_from_priorities(tatum_1_6)\n    Fraction(1, 6)\n\n    An example of values from the BPSD dataset (Zeitler et al.).\n\n    &gt;&gt;&gt; from amads.time.meter import profiles\n    &gt;&gt;&gt; bpsd_Op027No1 = profiles.BPSD().op027No1_01 # /16 divisions of the measure and /12 too (from m.48). Tatum 1/48\n    &gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/24) # proportion_threshold=0.999\n    Fraction(1, 48)\n\n    Change the `distance_threshold`\n    &gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/6) # proportion_threshold=0.999\n    Fraction(1, 12)\n\n    Change the `proportion_threshold`:\n    &gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/24, proportion_threshold=0.5)\n    Fraction(1, 24)\n\n    &gt;&gt;&gt; get_tatum_from_priorities(bpsd_Op027No1, distance_threshold=1/24, proportion_threshold=0.9)\n    Fraction(1, 48)\n\n    This also works without any floats (and therefore, no priorities needed)\n\n    &gt;&gt;&gt; get_tatum_from_priorities([1, 3])\n    Fraction(1, 1)\n\n    &gt;&gt;&gt; get_tatum_from_priorities([0, 3])\n    Fraction(3, 1)\n\n    &gt;&gt;&gt; get_tatum_from_priorities([0, Fraction(1, 3), Fraction(4, 6)])\n    Fraction(1, 3)\n\n    \"\"\"\n    floats = [num for num in starts if isinstance(num, float) and (num &gt; 0)]\n    ints_fractions = [num for num in starts if not isinstance(num, float)]\n    if not floats:\n        return fraction_gcd(ints_fractions)  # No further action\n\n    if not 0.0 &lt; distance_threshold &lt; 1.0:\n        raise ValueError(\n            \"The `distance_threshold` tolerance must be between 0 and 1.\"\n        )\n\n    if pulse_priority_list is None:\n        pulse_priority_list = generate_n_smooth_numbers(\n            invert=True\n        )  # 1, 1/2, 1/3, ...\n    else:\n        if not isinstance(pulse_priority_list, list):\n            raise ValueError(\"The `pulse_priority_list` must be a list.\")\n        for i in pulse_priority_list:\n            if not isinstance(i, Fraction):\n                raise ValueError(\n                    \"The `pulse_priority_list` must consist entirely of Fraction objects \"\n                    \"(which can include integers expressed as Fractions such as `Fraction(2, 1)`).\"\n                )\n            if i &lt;= 0:\n                raise ValueError(\n                    \"The `pulse_priority_list` items must be positive.\"\n                )\n\n    use_proportion = proportion_threshold is not None\n    if use_proportion:\n        if not 0.0 &lt; proportion_threshold &lt; 1.0:\n            raise ValueError(\n                \"When used (not `None`), the `proportion_threshold` must be between 0 and 1.\"\n            )\n        total = len(starts)\n        cumulative_count = len(ints_fractions) / total\n        starts = starts_to_int_relative_counter(floats)\n\n    pulses_needed = [x for x in ints_fractions if x &gt; 0]\n    # print(pulses_needed, cumulative_count)\n\n    for x in floats:\n        if (x &gt; 0) and (\n            approximate_pulse_match_with_priority_list(\n                x,\n                pulse_priority_list=pulses_needed,  # Try those we're committed to first\n                distance_threshold=distance_threshold,\n            )\n            is None\n        ):  # No fit among those we have, try other user-permitted alternatives.\n            new_pulse = approximate_pulse_match_with_priority_list(\n                x,\n                pulse_priority_list=pulse_priority_list,\n                distance_threshold=distance_threshold,\n            )\n            if new_pulse is not None:\n                pulses_needed.append(new_pulse)\n            else:  # No fit among user-permitted alternatives.\n                raise ValueError(\n                    f\"No match found for time point {x}, with the given arguments. \"\n                    \"Try relaxing the `distance_threshold` or expanding the `pulse_priority_list`.\"\n                )\n\n        if use_proportion:\n            cumulative_count += starts[x] / total\n            if cumulative_count &gt; proportion_threshold:\n                break\n\n    return fraction_gcd(pulses_needed)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.grid.get_tatum_from_priorities(starts)","title":"<code>starts</code>","text":"(<code>Iterable</code>)           \u2013            <p>Any iterable giving the starting position of events. Each constituent start must be expressed relative to a reference value such that X.0 is the start of a unit, X.5 is the mid-point, etc. Floats are the main expected type here (as above); we seek to reverse engineer a plausible fraction from each. If any start is already an exact Fraction or int, then it stays as it is, whatever the user setting: this functionality serves to improve the accuracy of timing data; there's no question of ever reducing it, even if user settings suggest that.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.get_tatum_from_priorities(pulse_priority_list)","title":"<code>pulse_priority_list</code>","text":"(<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>The point of this function is to encode musically common pulse values. This argument defaults to numbers under 100 with prime factors of only 2 and 3 (\u201c3-smooth\u201d), in increasing order. The user can define any alternative list, optionally making use of <code>generate_n_smooth_numbers</code> for the purpose. See notes at <code>approximate_fraction_with_priorities</code>. Make sure this list is exhaustive: the function will raise an error if no match is found.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.get_tatum_from_priorities(distance_threshold)","title":"<code>distance_threshold</code>","text":"(<code>float</code>, default:                   <code>1 / 24</code> )           \u2013            <p>The rounding tolerance between a temporal position multiplied by the bin value and the nearest integer. This is essential when working with floats. Defaults to 1/24, but can be set to any value.</p>"},{"location":"reference/time/meter/#amads.time.meter.grid.get_tatum_from_priorities(proportion_threshold)","title":"<code>proportion_threshold</code>","text":"(<code>float | None</code>, default:                   <code>0.999</code> )           \u2013            <p>Optionally, set a proportional number of events notes to account for. This option requires that the <code>starts</code> be expressed as a Counter, ordered from most to least common.  The default of .999 means that once at least 99.9% of the source's notes are handled, we ignore the rest. This is achieved by iterating through the Counter object of values relative to the unit (e.g., 1.5 -&gt; 0.5). This option should be chosen with care as, in this case, only the unit value and equal divisions thereof are considered.</p>"},{"location":"reference/time/meter/#amads.time.meter.profiles","title":"profiles","text":"<p>Profiles of metrical position usage provided or deduced from the literature.</p> <p>See the code for details. Data includes:</p> <ul> <li>WorldSample16<ul> <li>shiko</li> <li>son</li> <li>rumba</li> <li>soukous</li> <li>gahu</li> <li>bossa_nova</li> </ul> </li> <li>WorldSample12<ul> <li>soli</li> <li>tamb\u00fa</li> <li>bemb\u00e9</li> <li>bemb\u00e9_2</li> <li>yoruba</li> <li>tonada</li> <li>asaadua</li> <li>sorsonet</li> <li>bemba</li> <li>ashanti</li> </ul> </li> <li>BPSD (Beethoven piano sonata dataset)<ul> <li>op002No2_01</li> <li>op054_01</li> <li>op027No1_01</li> <li>op049No1_01</li> <li>op013_01</li> <li>op101_01</li> <li>op111_01</li> <li>op031No2_01</li> <li>op014No1_01</li> <li>op010No2_01</li> <li>op007_01</li> <li>op078_01</li> <li>op109_01</li> <li>op081a_01</li> <li>op028_01</li> <li>op002No3_01</li> <li>op010No1_01</li> <li>op090_01</li> <li>op031No1_01</li> <li>op014No2_01</li> <li>op010No3_01</li> <li>op031No3_01</li> <li>op110_01</li> <li>op026_01</li> <li>op049No2_01</li> <li>op002No1_01</li> <li>op027No2_01</li> <li>op057_01</li> <li>op053_01</li> <li>op022_01</li> <li>op106_01</li> <li>op079_01</li> <li>all</li> </ul> </li> </ul> <p>Author: Mark Gotham</p>"},{"location":"reference/time/meter/#amads.time.meter.representations","title":"representations","text":"<p>This module serves to map out metrical hierarchies in a number of different ways and to express the relationship between the notes in and the hierarchy of a metrical cycle.</p> <p>Uses include identifying notes that traverse metrical levels, for analysis (e.g., as a cycle of syncopation) and notation (e.g., re-notating to reflect the within-cycle notational conventions).</p> <p>Author: Mark Gotham</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy","title":"StartTimeHierarchy","text":"<pre><code>StartTimeHierarchy(\n    start_hierarchy: list[list], names: dict | None = None\n)\n</code></pre> <p>Encoding metrical structure as a hierarchy of start times.</p> <p>A representation of metrical levels in terms of starts expressed by quarter length from the start of the cycle.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>coincident_pulse_list</code>             \u2013              <p>Create a flat list setting out the</p> </li> <li> <code>to_pulse_lengths</code>             \u2013              <p>Check if levels have a regular pulse and if so, return the pulse length value.</p> </li> <li> <code>add_faster_levels</code>             \u2013              <p>Recursively add faster levels until the <code>minimum_beat_type</code> value</p> </li> </ul> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def __init__(\n    self,\n    start_hierarchy: list[list],\n    names: Optional[dict] = None,\n):\n    self.start_hierarchy = start_hierarchy\n    self.cycle_length = self.start_hierarchy[0][-1]\n    self.pulse_lengths = None\n\n    if names:\n        for key in names:\n            assert isinstance(key, float)\n            assert isinstance(names[key], str)\n    self.names = names\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy(start_hierarchy)","title":"<code>start_hierarchy</code>","text":"(<code>list[list]</code>)           \u2013            <p>Users can specify the <code>start_hierarchy</code> directly and completely from scratch. Use this for advanced, non-standard metrical structures including those without 2-/3- grouping, or even nested hierarchies, as well as for (optionally) encoding micro-timing directly into the metrical structure. The only \u201cwell-formed\u201d criteria we expect are use of 0.0 and full cycle length at the top level, and presence of all timepoints from one level in each subsequent level. For creating this information from pulse lengths, time signatures, and more see the <code>to_start_hierarchy</code> methods on those classes.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy(names)","title":"<code>names</code>","text":"(<code>dict | None</code>, default:                   <code>None</code> )           \u2013            <p>Optionally create a dict mapping temporal positions to names. Currently, this supports one textual value per temporal position (key), e.g., {0.0: \"ta\", 1.0: \"ka\", 2.0: \"di\", 3.0: \"mi\"}.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy.coincident_pulse_list","title":"coincident_pulse_list","text":"<pre><code>coincident_pulse_list(granular_pulse: float) -&gt; list\n</code></pre> <p>Create a flat list setting out the number of intersecting pulses at each successive position in a metrical cycle.</p> <p>For example, the output [4, 1, 2, 1, 3, 1, 2, 1] refers to a base pulse unit of 1, with addition pulse streams accenting every 2nd, 4th, and 8th position.</p> <p>Parameters:</p> <p>Examples:</p> <p>You can currently set the <code>granular_pulse</code> value to anything (this may change). For instance, in the pair of examples below, first we have a <code>granular_pulse</code> that's present in the input, and then a case using a faster level that's not present (this simply pads the data out):</p> <pre><code>&gt;&gt;&gt; hierarchy = StartTimeHierarchy([[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]])\n&gt;&gt;&gt; hierarchy.coincident_pulse_list(granular_pulse=1)\n[3, 1, 2, 1]\n</code></pre> <p>Now, changing the <code>granular_pulse</code> for a bit of over-sampling:</p> <pre><code>&gt;&gt;&gt; hierarchy.coincident_pulse_list(granular_pulse=0.5)\n[3, 0, 1, 0, 2, 0, 1, 0]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def coincident_pulse_list(\n    self,\n    granular_pulse: float,\n) -&gt; list:\n    \"\"\"\n    Create a flat list setting out the\n    number of intersecting pulses at each successive position in a metrical cycle.\n\n    For example,\n    the output [4, 1, 2, 1, 3, 1, 2, 1]\n    refers to a base pulse unit of 1,\n    with addition pulse streams accenting every 2nd, 4th, and 8th position.\n\n\n    Parameters\n    --------\n    granular_pulse\n        The pulse value of the fastest level to consider e.g., 1, or 0.25.\n\n    Examples\n    --------\n\n    You can currently set the `granular_pulse` value to anything (this may change).\n    For instance, in the pair of examples below,\n    first we have a `granular_pulse` that's present in the input,\n    and then a case using a faster level that's not present (this simply pads the data out):\n\n    &gt;&gt;&gt; hierarchy = StartTimeHierarchy([[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]])\n    &gt;&gt;&gt; hierarchy.coincident_pulse_list(granular_pulse=1)\n    [3, 1, 2, 1]\n\n    Now, changing the `granular_pulse` for a bit of over-sampling:\n\n    &gt;&gt;&gt; hierarchy.coincident_pulse_list(granular_pulse=0.5)\n    [3, 0, 1, 0, 2, 0, 1, 0]\n\n    \"\"\"\n    cycle_length = self.start_hierarchy[0][-1]\n\n    for level in self.start_hierarchy:\n        assert level[-1] == cycle_length\n\n    steps = int(cycle_length / granular_pulse)\n    granular_level = [granular_pulse * count for count in range(steps)]\n\n    def count_instances(nested_list, target):\n        return sum([sublist.count(target) for sublist in nested_list])\n\n    coincidences = []\n    for target in granular_level:\n        coincidences.append(count_instances(self.start_hierarchy, target))\n\n    return coincidences\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy.coincident_pulse_list(granular_pulse)","title":"<code>granular_pulse</code>","text":"(<code>float</code>)           \u2013            <p>The pulse value of the fastest level to consider e.g., 1, or 0.25.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy.to_pulse_lengths","title":"to_pulse_lengths","text":"<pre><code>to_pulse_lengths()\n</code></pre> <p>Check if levels have a regular pulse and if so, return the pulse length value.</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>Returns a list of pulse values corresponding to the start hierarchy, of the same length. If a level is not regular, the list is populated with None.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hierarchy = StartTimeHierarchy([[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]])\n&gt;&gt;&gt; hierarchy.to_pulse_lengths()\n&gt;&gt;&gt; hierarchy.pulse_lengths\n[4.0, 2.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; uneven = StartTimeHierarchy([[0.0, 4.0], [0.0, 3.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]])\n&gt;&gt;&gt; uneven.to_pulse_lengths()\n&gt;&gt;&gt; uneven.pulse_lengths\n[4.0, None, 1.0]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def to_pulse_lengths(self):\n    \"\"\"\n    Check if levels have a regular pulse and if so, return the pulse length value.\n\n    Returns\n    -------\n    list\n        Returns a list of pulse values corresponding to the start hierarchy, of the same length.\n        If a level is not regular, the list is populated with None.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; hierarchy = StartTimeHierarchy([[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]])\n    &gt;&gt;&gt; hierarchy.to_pulse_lengths()\n    &gt;&gt;&gt; hierarchy.pulse_lengths\n    [4.0, 2.0, 1.0]\n\n    &gt;&gt;&gt; uneven = StartTimeHierarchy([[0.0, 4.0], [0.0, 3.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]])\n    &gt;&gt;&gt; uneven.to_pulse_lengths()\n    &gt;&gt;&gt; uneven.pulse_lengths\n    [4.0, None, 1.0]\n\n    \"\"\"\n\n    def test_one(level: list):\n        diffs = set(\n            [level[i + 1] - level[i] for i in range(len(level) - 1)]\n        )\n        if len(diffs) &gt; 1:\n            return None\n        return float(list(diffs)[0])\n\n    self.pulse_lengths = [test_one(level) for level in self.start_hierarchy]\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy.add_faster_levels","title":"add_faster_levels","text":"<pre><code>add_faster_levels(minimum_beat_type: int = 64)\n</code></pre> <p>Recursively add faster levels until the <code>minimum_beat_type</code> value The <code>minimum_beat_type</code> is subject to the same constraints as the <code>beat_types</code> (\"denominators\") i.e., powers of 2 (1, 2, 4, 8, 16, 32, 64, ...). The default = 64 for 64th note.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>if the currently fastest level of a <code>starts_hierarchy</code> is not periodic, or if either of the fastest level or <code>minimum_beat_type</code> are not powers of 2. Set the <code>starts_hierarchy</code> manually in these non-standard cases.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; hierarchy = StartTimeHierarchy([[0.0, 4.0], [0.0, 2.0, 4.0]])\n&gt;&gt;&gt; hierarchy.start_hierarchy\n[[0.0, 4.0], [0.0, 2.0, 4.0]]\n</code></pre> <pre><code>&gt;&gt;&gt; hierarchy.to_pulse_lengths()\n&gt;&gt;&gt; hierarchy.pulse_lengths\n[4.0, 2.0]\n</code></pre> <pre><code>&gt;&gt;&gt; hierarchy.add_faster_levels(minimum_beat_type=4)\n&gt;&gt;&gt; hierarchy.start_hierarchy\n[[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]]\n</code></pre> <pre><code>&gt;&gt;&gt; hierarchy.pulse_lengths\n[4.0, 2.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; hierarchy.add_faster_levels(minimum_beat_type=8)\n&gt;&gt;&gt; hierarchy.start_hierarchy[-1]\n[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; len(hierarchy.start_hierarchy)\n4\n</code></pre> <pre><code>&gt;&gt;&gt; hierarchy.pulse_lengths\n[4.0, 2.0, 1.0, 0.5]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def add_faster_levels(self, minimum_beat_type: int = 64):\n    \"\"\"\n    Recursively add faster levels until the `minimum_beat_type` value\n    The `minimum_beat_type` is subject to the same constraints as the `beat_types` (\"denominators\")\n    i.e., powers of 2 (1, 2, 4, 8, 16, 32, 64, ...).\n    The default = 64 for 64th note.\n\n    Parameters\n    ----------\n    minimum_beat_type\n        Recursively create further levels down to this value.\n        Must be power of two.\n        Defaults to 64 for 64th notes.\n\n    Raises\n    ------\n    ValueError\n        if the currently fastest level of a `starts_hierarchy` is not periodic,\n        or if either of the fastest level or `minimum_beat_type` are not powers\n        of 2. Set the `starts_hierarchy` manually in these non-standard cases.\n\n    Examples\n    --------\n    &gt;&gt;&gt; hierarchy = StartTimeHierarchy([[0.0, 4.0], [0.0, 2.0, 4.0]])\n    &gt;&gt;&gt; hierarchy.start_hierarchy\n    [[0.0, 4.0], [0.0, 2.0, 4.0]]\n\n    &gt;&gt;&gt; hierarchy.to_pulse_lengths()\n    &gt;&gt;&gt; hierarchy.pulse_lengths\n    [4.0, 2.0]\n\n    &gt;&gt;&gt; hierarchy.add_faster_levels(minimum_beat_type=4)\n    &gt;&gt;&gt; hierarchy.start_hierarchy\n    [[0.0, 4.0], [0.0, 2.0, 4.0], [0.0, 1.0, 2.0, 3.0, 4.0]]\n\n    &gt;&gt;&gt; hierarchy.pulse_lengths\n    [4.0, 2.0, 1.0]\n\n    &gt;&gt;&gt; hierarchy.add_faster_levels(minimum_beat_type=8)\n    &gt;&gt;&gt; hierarchy.start_hierarchy[-1]\n    [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]\n\n    &gt;&gt;&gt; len(hierarchy.start_hierarchy)\n    4\n\n    &gt;&gt;&gt; hierarchy.pulse_lengths\n    [4.0, 2.0, 1.0, 0.5]\n\n    \"\"\"\n    self.to_pulse_lengths()\n    assert self.pulse_lengths is not None, \"\"\n    fastest = self.pulse_lengths[-1]\n    if fastest is None:\n        raise ValueError(\n            \"Fastest level is not regular. Use case unsupported.\"\n        )\n    if not is_non_negative_integer_power_of_two(\n        switch_pulse_length_beat_type(\n            fastest\n        )  # from pulse length to beat type\n    ):\n        raise ValueError(\n            f\"Fastest level ({fastest}) is not a power of 2. Use case unsupported.\"\n        )\n    if not is_non_negative_integer_power_of_two(minimum_beat_type):\n        raise ValueError(\n            f\"The `minimum_beat_type` ({minimum_beat_type}) is not a power of 2. Use case unsupported.\"\n        )\n\n    fastest_beat_type = switch_pulse_length_beat_type(fastest)  # TODO\n    fastest_beat_type_exponent = int(math.log2(fastest_beat_type))\n    minimum_beat_type_exponent = int(math.log2(minimum_beat_type))\n\n    new_beat_types = [\n        2**x\n        for x in range(\n            fastest_beat_type_exponent + 1, minimum_beat_type_exponent + 1\n        )\n    ]\n    new_pulses = [\n        switch_pulse_length_beat_type(beat_type)\n        for beat_type in new_beat_types\n    ]\n    self.pulse_lengths += new_pulses\n    self.pulse_lengths = [x for x in self.pulse_lengths if x is not None]\n    self.pulse_lengths = sorted(\n        list(set(self.pulse_lengths)), key=abs, reverse=True\n    )\n    fake_meter = PulseLengths(\n        pulse_lengths=new_pulses, cycle_length=self.cycle_length\n    )\n    self.start_hierarchy += fake_meter.to_start_hierarchy()\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.StartTimeHierarchy.add_faster_levels(minimum_beat_type)","title":"<code>minimum_beat_type</code>","text":"(<code>int</code>, default:                   <code>64</code> )           \u2013            <p>Recursively create further levels down to this value. Must be power of two. Defaults to 64 for 64th notes.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature","title":"TimeSignature","text":"<pre><code>TimeSignature(\n    beats: tuple[int] | None = None,\n    beat_type: int | None = None,\n    as_string: str | None = None,\n)\n</code></pre> <p>Represent the notational time signature object.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature--todo-consider-aligning-and-merging-with-basicstimesignature-this-pr-shows-some-of-how-that-would-work","title":"TODO consider aligning and merging with basics.TimeSignature, this PR shows some of how that would work.","text":"<p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>from_string</code>             \u2013              <p>Given a signature string, extract the constituent parts and create an object.</p> </li> <li> <code>check_valid</code>             \u2013              <p>Check the validity of the input.</p> </li> <li> <code>get_pulses</code>             \u2013              <p>Create an unordered set for the regular pulses present in this time signature.</p> </li> <li> <code>fill_2s_3s</code>             \u2013              <p>Optionally, add pulse values to follow the conventions of the time signatures.</p> </li> <li> <code>to_start_hierarchy</code>             \u2013              <p>Create a start hierarchy for almost any time signature</p> </li> </ul> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def __init__(\n    self,\n    beats: Optional[tuple[int]] = None,\n    beat_type: Optional[int] = None,\n    # delta: Optional[float] = 0,  # TODO if merging with basics\n    as_string: Optional[str] = None,\n):\n    self.beats = beats\n    self.one_beat_value = None\n    self.beat_type = beat_type\n    self.as_string = as_string\n    if (self.beats is None) and (self.beat_type is None):\n        self.from_string()\n    self.check_valid()\n\n    self.cycle_length = sum(self.beats) * 4 / self.beat_type\n    self.pulses = None\n    self.get_pulses()\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature(beats)","title":"<code>beats</code>","text":"(<code>tuple[int] | None</code>, default:                   <code>None</code> )           \u2013            <p>The \"numerator\" of the time signature: beats per cycle, a number (int or fraction) or a lists thereof.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature(beat_type)","title":"<code>beat_type</code>","text":"(<code>int | None</code>, default:                   <code>None</code> )           \u2013            <p>the so-called \"denominator\" of the time signature: a whole number power of 2 (1, 2, 4, 8, 16, 32, 64, ...). No so-called \"irrational\" meters yet (e.g., 2/3), sorry!</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature(as_string)","title":"<code>as_string</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>An alternative way of creating this object from a string representation. See notes at <code>TimeSignature.from_string</code>.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature.from_string","title":"from_string","text":"<pre><code>from_string()\n</code></pre> <p>Given a signature string, extract the constituent parts and create an object. The string must take the form <code>&lt;beat&gt;/&lt;beat_type&gt;</code> with exactly one \u201c/\u201d separating the two (spaces are ignored). The string does not change.</p> <p>The <code>&lt;beat&gt;</code> (\u201cnumerator\u201d) part may be a number (including 5 and 7 which are supported) or more than one number separated by the \u201c+\u201d symbol. For example, when encoding \u201c5/4\u201d, use the total value only to avoid segmentation above the denominator level (\u201c5/4\u201d) or the X+Y form to explicitly distinguish between \u201c2+3\u201d and \u201c3+2\u201d. I.e., \u201c5/\u201d time signatures have no 3+2 or 2+3 division by default. See examples on <code>TimeSignature.to_starts_hierarchy</code>.</p> <p>Finally, although we support and provide defaults for time signatures in the form \u201c2+3/8\u201d, there is no such support for more than one \u201c/\u201d (i.e., the user must build cases like \u201c4/4 + 3/8\u201d explicitly according to how they see it).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n&gt;&gt;&gt; ts_4_4.beats # Tuple of one element\n(4,)\n</code></pre> <pre><code>&gt;&gt;&gt; ts_4_4.beat_type\n4\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def from_string(self):\n    \"\"\"\n    Given a signature string, extract the constituent parts and create an object.\n    The string must take the form `&lt;beat&gt;/&lt;beat_type&gt;`\n    with exactly one \u201c/\u201d separating the two (spaces are ignored).\n    The string does not change.\n\n    The `&lt;beat&gt;` (\u201cnumerator\u201d) part may be a number (including 5 and 7 which\n    are supported) or more than one number separated by the \u201c+\u201d symbol.\n    For example, when encoding \u201c5/4\u201d, use the total value only to avoid\n    segmentation above the denominator level (\u201c5/4\u201d)\n    or the X+Y form to explicitly distinguish between \u201c2+3\u201d and \u201c3+2\u201d.\n    I.e., \u201c5/\u201d time signatures have no 3+2 or 2+3 division by default.\n    See examples on `TimeSignature.to_starts_hierarchy`.\n\n    Finally, although we support and provide defaults for time signatures\n    in the form \u201c2+3/8\u201d, there is no such support for more than one \u201c/\u201d\n    (i.e., the user must build cases like \u201c4/4 + 3/8\u201d explicitly\n    according to how they see it).\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n    &gt;&gt;&gt; ts_4_4.beats # Tuple of one element\n    (4,)\n\n    &gt;&gt;&gt; ts_4_4.beat_type\n    4\n\n    \"\"\"\n    beats, beat_type = self.as_string.split(\"/\")\n\n    self.beats = tuple([int(x) for x in beats.split(\"+\")])\n    self.beat_type = int(beat_type)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature.check_valid","title":"check_valid","text":"<pre><code>check_valid()\n</code></pre> <p>Check the validity of the input.</p> <ul> <li><code>.beats</code> must be an integer or a list/tuple thereof.</li> <li><code>.beat_type</code> must be a single integer power of two.</li> </ul> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def check_valid(self):\n    \"\"\"\n    Check the validity of the input.\n\n     - `.beats` must be an integer or a list/tuple thereof.\n     - `.beat_type` must be a single integer power of two.\n    \"\"\"\n    # beats  # TODO this check may be overdoing it\n    if self.beats:\n        assert isinstance(self.beats, tuple)\n        for b in self.beats:\n            assert isinstance(b, int)\n\n    # beat_type  # TODO this is the part we want to actively check\n    if not is_non_negative_integer_power_of_two(self.beat_type):\n        raise ValueError(\n            f\"Beat type set as {self.beat_type} is invalid: must be a non-negative integer power of 2.\"\n        )\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature.get_pulses","title":"get_pulses","text":"<pre><code>get_pulses()\n</code></pre> <p>Create an unordered set for the regular pulses present in this time signature.</p> <p>This will include the full cycle and beat type (\u201cdenominator\u201d) value, e.g., in \u201c3/4\u201d the pulse lengths are 3.0 (full cycle) and 1.0 (beat type). If there are other regular levels between the two, they will be added only if the user has first called <code>fill_2s_3s</code> (it does not run by default). For instance, the splitting of 4 into 2+2 is user choice (see <code>fill_2s_3s</code>) With this split, this \u201c4/4\u201d has pulse lengths of 4.0 (full cycle) and 1.0 (beat type) as well as 2.0 given that the two twos are of one kind. In \u201c2+3/4\u201d there is no such 2.0 (or 3.0) regularity, and so no pulse is created for that level.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n&gt;&gt;&gt; ts_4_4.pulses\n[4.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_4_4.fill_2s_3s()\n&gt;&gt;&gt; ts_4_4.pulses\n[4.0, 2.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_6_8 = TimeSignature(as_string=\"6/8\")\n&gt;&gt;&gt; ts_6_8.pulses\n[3.0, 0.5]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_6_8.fill_2s_3s()\n&gt;&gt;&gt; ts_6_8.pulses\n[3.0, 1.5, 0.5]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def get_pulses(self):\n    \"\"\"\n    Create an unordered set for the regular pulses present in this time signature.\n\n    This will include the full cycle and beat type (\u201cdenominator\u201d) value,\n    e.g., in \u201c3/4\u201d the pulse lengths are 3.0 (full cycle) and 1.0 (beat type).\n    If there are other regular levels between the two, they will be added\n    only if the user has first called `fill_2s_3s` (it does not run by default).\n    For instance, the splitting of 4 into 2+2 is user choice (see `fill_2s_3s`)\n    With this split, this \u201c4/4\u201d has pulse lengths of 4.0 (full cycle)\n    and 1.0 (beat type) as well as 2.0 given that the two twos are of one kind.\n    In \u201c2+3/4\u201d there is no such 2.0 (or 3.0) regularity, and so no pulse is\n    created for that level.\n\n    Examples\n    --------\n    &gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n    &gt;&gt;&gt; ts_4_4.pulses\n    [4.0, 1.0]\n\n    &gt;&gt;&gt; ts_4_4.fill_2s_3s()\n    &gt;&gt;&gt; ts_4_4.pulses\n    [4.0, 2.0, 1.0]\n\n    &gt;&gt;&gt; ts_6_8 = TimeSignature(as_string=\"6/8\")\n    &gt;&gt;&gt; ts_6_8.pulses\n    [3.0, 0.5]\n\n    &gt;&gt;&gt; ts_6_8.fill_2s_3s()\n    &gt;&gt;&gt; ts_6_8.pulses\n    [3.0, 1.5, 0.5]\n\n    \"\"\"\n    pulses = [float(self.cycle_length), 4 / self.beat_type]\n\n    first_beat_to_pulse = self.beats[0] * 4 / self.beat_type\n\n    if len(self.beats) == 1:  # one beat type\n        pulses.append(first_beat_to_pulse)\n        self.one_beat_value = self.beats[0]\n    elif len(self.beats) &gt; 1:  # 2+ beats\n        if (\n            len(set(self.beats)) == 1\n        ):  # duplicate of the same e.g., (2, 2), so still one consistent pulse.\n            self.one_beat_value = self.beats[0]\n            pulses.append(first_beat_to_pulse)\n\n    self.pulses = sorted(list(set(pulses)), key=abs, reverse=True)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature.fill_2s_3s","title":"fill_2s_3s","text":"<pre><code>fill_2s_3s()\n</code></pre> <p>Optionally, add pulse values to follow the conventions of the time signatures.</p> <p>Enforcing 2- and 3-grouping, this only applies to cases with a single beat in the \"numerator\". For instance, given a \u201c4/4\u201d signature, this method will add the half-cycle (pulse value 2.0), given a \u201c6/8\u201d, it will again add the half-cycle (pulse value 1.5), and given a \u201c12/8\u201d, it will add both the half- and quarter-cycle (pulse values 3.0 and 1.5),</p> <p>This functionality is factored out and does not run by default. Even if this runs, the original time signature string is unchanged, as is the <code>beats</code> attribute.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n&gt;&gt;&gt; ts_4_4.pulses\n[4.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_4_4.fill_2s_3s()\n&gt;&gt;&gt; ts_4_4.pulses\n[4.0, 2.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_6_8 = TimeSignature(as_string=\"6/8\")\n&gt;&gt;&gt; ts_6_8.pulses\n[3.0, 0.5]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_6_8.fill_2s_3s()\n&gt;&gt;&gt; ts_6_8.pulses\n[3.0, 1.5, 0.5]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def fill_2s_3s(self):\n    \"\"\"\n    Optionally, add pulse values to follow the conventions of the time signatures.\n\n    Enforcing 2- and 3-grouping, this only applies to cases with a\n    single beat in the \"numerator\". For instance,\n    given a \u201c4/4\u201d signature, this method will add the half-cycle (pulse value 2.0),\n    given a \u201c6/8\u201d, it will again add the half-cycle (pulse value 1.5),\n    and given a \u201c12/8\u201d, it will add both the half- and quarter-cycle\n    (pulse values 3.0 and 1.5),\n\n    This functionality is factored out and does not run by default.\n    Even if this runs, the original time signature string is unchanged,\n    as is the `beats` attribute.\n\n    Examples\n    --------\n    &gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n    &gt;&gt;&gt; ts_4_4.pulses\n    [4.0, 1.0]\n\n    &gt;&gt;&gt; ts_4_4.fill_2s_3s()\n    &gt;&gt;&gt; ts_4_4.pulses\n    [4.0, 2.0, 1.0]\n\n    &gt;&gt;&gt; ts_6_8 = TimeSignature(as_string=\"6/8\")\n    &gt;&gt;&gt; ts_6_8.pulses\n    [3.0, 0.5]\n\n    &gt;&gt;&gt; ts_6_8.fill_2s_3s()\n    &gt;&gt;&gt; ts_6_8.pulses\n    [3.0, 1.5, 0.5]\n\n    \"\"\"\n    metrical_mappings = {4: [2], 6: [3], 9: [3], 12: [6, 3]}\n\n    if self.one_beat_value is not None:\n        if self.one_beat_value in metrical_mappings:\n            self.pulses += [\n                x * 4 / self.beat_type\n                for x in metrical_mappings[self.one_beat_value]\n            ]\n    self.pulses = sorted(list(set(self.pulses)), key=abs, reverse=True)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.TimeSignature.to_start_hierarchy","title":"to_start_hierarchy","text":"<pre><code>to_start_hierarchy() -&gt; list\n</code></pre> <p>Create a start hierarchy for almost any time signature</p> <p>(with constraints as noted in the top level class description and in the <code>.from_string</code> method). See below for several examples of how this handles specific time signatures and related assumptions, and note the effect of running <code>fill_2s_3s()</code>.</p> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>Returns a list of lists with start positions by level.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n&gt;&gt;&gt; ts_4_4.pulses\n[4.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_1 = ts_4_4.to_start_hierarchy()\n&gt;&gt;&gt; test_1[0]\n[0.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_1[1]\n[0.0, 1.0, 2.0, 3.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_4_4.fill_2s_3s()\n&gt;&gt;&gt; ts_4_4.pulses\n[4.0, 2.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_2 = ts_4_4.to_start_hierarchy()\n&gt;&gt;&gt; test_2[0]\n[0.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_2[1]\n[0.0, 2.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_2[2]\n[0.0, 1.0, 2.0, 3.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_2_2 = TimeSignature(as_string=\"2/2\")\n&gt;&gt;&gt; ts_2_2.pulses\n[4.0, 2.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_3 = ts_2_2.to_start_hierarchy()\n&gt;&gt;&gt; test_3[0]\n[0.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_3[1]\n[0.0, 2.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_2_2.fill_2s_3s() # no effect, unchanged\n&gt;&gt;&gt; ts_2_2.pulses\n[4.0, 2.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_4 = ts_2_2.to_start_hierarchy()\n&gt;&gt;&gt; test_4[0]\n[0.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_4[1]\n[0.0, 2.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_6_8 = TimeSignature(as_string=\"6/8\")\n&gt;&gt;&gt; ts_6_8.pulses\n[3.0, 0.5]\n</code></pre> <pre><code>&gt;&gt;&gt; test_5 = ts_6_8.to_start_hierarchy()\n&gt;&gt;&gt; test_5[0]\n[0.0, 3.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_5[1]\n[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_6_8.fill_2s_3s()\n&gt;&gt;&gt; ts_6_8.pulses\n[3.0, 1.5, 0.5]\n</code></pre> <pre><code>&gt;&gt;&gt; test_6 = ts_6_8.to_start_hierarchy()\n&gt;&gt;&gt; test_6[0]\n[0.0, 3.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_6[1]\n[0.0, 1.5, 3.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_6[2]\n[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_5_4 = TimeSignature(as_string=\"5/4\")\n&gt;&gt;&gt; ts_5_4.pulses\n[5.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_7 = ts_5_4.to_start_hierarchy()\n&gt;&gt;&gt; test_7[0]\n[0.0, 5.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_7[1]\n[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n</code></pre> <pre><code>&gt;&gt;&gt; ts_2_3_4 = TimeSignature(as_string=\"2+3/4\")\n&gt;&gt;&gt; ts_2_3_4.pulses # as before\n[5.0, 1.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_8 = ts_2_3_4.to_start_hierarchy()\n&gt;&gt;&gt; test_8[0]\n[0.0, 5.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_8[1]\n[0.0, 2.0, 5.0]\n</code></pre> <pre><code>&gt;&gt;&gt; test_8[2]\n[0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def to_start_hierarchy(self) -&gt; list:\n    \"\"\"\n    Create a start hierarchy for almost any time signature\n\n    (with constraints as noted in the top level class description\n    and in the `.from_string` method).\n    See below for several examples of how this handles\n    specific time signatures and related assumptions,\n    and note the effect of running `fill_2s_3s()`.\n\n    Returns\n    -------\n    list\n        Returns a list of lists with start positions by level.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; ts_4_4 = TimeSignature(as_string=\"4/4\")\n    &gt;&gt;&gt; ts_4_4.pulses\n    [4.0, 1.0]\n\n    &gt;&gt;&gt; test_1 = ts_4_4.to_start_hierarchy()\n    &gt;&gt;&gt; test_1[0]\n    [0.0, 4.0]\n\n    &gt;&gt;&gt; test_1[1]\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n\n    &gt;&gt;&gt; ts_4_4.fill_2s_3s()\n    &gt;&gt;&gt; ts_4_4.pulses\n    [4.0, 2.0, 1.0]\n\n    &gt;&gt;&gt; test_2 = ts_4_4.to_start_hierarchy()\n    &gt;&gt;&gt; test_2[0]\n    [0.0, 4.0]\n\n    &gt;&gt;&gt; test_2[1]\n    [0.0, 2.0, 4.0]\n\n    &gt;&gt;&gt; test_2[2]\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n\n    &gt;&gt;&gt; ts_2_2 = TimeSignature(as_string=\"2/2\")\n    &gt;&gt;&gt; ts_2_2.pulses\n    [4.0, 2.0]\n\n    &gt;&gt;&gt; test_3 = ts_2_2.to_start_hierarchy()\n    &gt;&gt;&gt; test_3[0]\n    [0.0, 4.0]\n\n    &gt;&gt;&gt; test_3[1]\n    [0.0, 2.0, 4.0]\n\n    &gt;&gt;&gt; ts_2_2.fill_2s_3s() # no effect, unchanged\n    &gt;&gt;&gt; ts_2_2.pulses\n    [4.0, 2.0]\n\n    &gt;&gt;&gt; test_4 = ts_2_2.to_start_hierarchy()\n    &gt;&gt;&gt; test_4[0]\n    [0.0, 4.0]\n\n    &gt;&gt;&gt; test_4[1]\n    [0.0, 2.0, 4.0]\n\n    &gt;&gt;&gt; ts_6_8 = TimeSignature(as_string=\"6/8\")\n    &gt;&gt;&gt; ts_6_8.pulses\n    [3.0, 0.5]\n\n    &gt;&gt;&gt; test_5 = ts_6_8.to_start_hierarchy()\n    &gt;&gt;&gt; test_5[0]\n    [0.0, 3.0]\n\n    &gt;&gt;&gt; test_5[1]\n    [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n    &gt;&gt;&gt; ts_6_8.fill_2s_3s()\n    &gt;&gt;&gt; ts_6_8.pulses\n    [3.0, 1.5, 0.5]\n\n    &gt;&gt;&gt; test_6 = ts_6_8.to_start_hierarchy()\n    &gt;&gt;&gt; test_6[0]\n    [0.0, 3.0]\n\n    &gt;&gt;&gt; test_6[1]\n    [0.0, 1.5, 3.0]\n\n    &gt;&gt;&gt; test_6[2]\n    [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0]\n\n    &gt;&gt;&gt; ts_5_4 = TimeSignature(as_string=\"5/4\")\n    &gt;&gt;&gt; ts_5_4.pulses\n    [5.0, 1.0]\n\n    &gt;&gt;&gt; test_7 = ts_5_4.to_start_hierarchy()\n    &gt;&gt;&gt; test_7[0]\n    [0.0, 5.0]\n\n    &gt;&gt;&gt; test_7[1]\n    [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n\n    &gt;&gt;&gt; ts_2_3_4 = TimeSignature(as_string=\"2+3/4\")\n    &gt;&gt;&gt; ts_2_3_4.pulses # as before\n    [5.0, 1.0]\n\n    &gt;&gt;&gt; test_8 = ts_2_3_4.to_start_hierarchy()\n    &gt;&gt;&gt; test_8[0]\n    [0.0, 5.0]\n\n    &gt;&gt;&gt; test_8[1]\n    [0.0, 2.0, 5.0]\n\n    &gt;&gt;&gt; test_8[2]\n    [0.0, 1.0, 2.0, 3.0, 4.0, 5.0]\n\n    \"\"\"\n    # 1. Basic elements: all periodic cycles from the full cycle to the `beat_type` level.\n    pulses = (\n        PulseLengths(  # TODO consistency wrt what is added to the class.\n            pulse_lengths=self.pulses, cycle_length=self.cycle_length\n        )\n    )\n    start_hierarchy = pulses.to_start_hierarchy()\n\n    # 2. irregular beat layer, if applicable.\n    if len(self.beats) &gt; 1:  # not a regular pulse e.g., (2, 3)\n        bp = BeatPattern(\n            self.beats, self.beat_type\n        )  # TODO consistency wrt what is added to the class.\n        beat_starts = bp.beat_pattern_to_start_hierarchy()\n        start_hierarchy.append(beat_starts)\n\n        start_hierarchy = [\n            list(i) for i in set(map(tuple, start_hierarchy))\n        ]\n        start_hierarchy.sort(key=len)\n        # TODO consider move to StartTimeHierarchy?\n\n    return start_hierarchy\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths","title":"PulseLengths","text":"<pre><code>PulseLengths(\n    pulse_lengths: list[float],\n    cycle_length: float | None = None,\n    include_cycle_length: bool = True,\n)\n</code></pre> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>to_start_hierarchy</code>             \u2013              <p>Convert a list of pulse lengths into a corresponding list of lists.</p> </li> <li> <code>one_pulse_to_start_hierarchy_list</code>             \u2013              <p>Convert a single pulse length and cycle length into a list of starts.</p> </li> <li> <code>to_array</code>             \u2013              <p>Create an array with the levels as rows,</p> </li> </ul> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def __init__(\n    self,\n    pulse_lengths: list[float],\n    cycle_length: Optional[float] = None,\n    include_cycle_length: bool = True,\n):\n    \"\"\"\n    Representation of fully periodic meter centred on the constituent pulse lengths.\n\n    Parameters\n    ----------\n    pulse_lengths\n        Any valid list of pulse lengths, e.g., [4, 2, 1].\n    cycle_length\n        Optional. If not provided, the cycle length is taken to be given by the longest pulse length.\n    include_cycle_length\n        Defaults to True. If True, when converting to starts, include the full cycle length in the list.\n\n    \"\"\"\n\n    self.pulse_lengths = pulse_lengths\n    self.pulse_lengths.sort(reverse=True)  # largest number first\n\n    self.cycle_length = cycle_length\n    if self.cycle_length is not None:\n        if pulse_lengths[0] &gt; self.cycle_length:\n            raise ValueError(\n                f\"The `pulse_length` {pulse_lengths[0]} is longer than the `cycle_length` ({self.cycle_length}).\"\n            )\n    else:\n        self.cycle_length = float(pulse_lengths[0])\n\n    self.start_hierarchy = None\n    self.include_cycle_length = include_cycle_length\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths(pulse_lengths)","title":"<code>pulse_lengths</code>","text":"(<code>list[float]</code>)           \u2013            <p>Any valid list of pulse lengths, e.g., [4, 2, 1].</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths(cycle_length)","title":"<code>cycle_length</code>","text":"(<code>float | None</code>, default:                   <code>None</code> )           \u2013            <p>Optional. If not provided, the cycle length is taken to be given by the longest pulse length.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths(include_cycle_length)","title":"<code>include_cycle_length</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Defaults to True. If True, when converting to starts, include the full cycle length in the list.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths.to_start_hierarchy","title":"to_start_hierarchy","text":"<pre><code>to_start_hierarchy(require_2_or_3_between_levels: bool = False)\n</code></pre> <p>Convert a list of pulse lengths into a corresponding list of lists.</p> <p>Gives start positions per metrical level. All values (pulse lengths, start positions, and cycle_length) are all expressed in terms of quarter length.</p> <p>That is, the user provides pulse lengths for each level of a metrical hierarchy, and the algorithm expands this into a hierarchy assuming equal spacing (aka \u201cisochrony\u201d).</p> <p>This does not work for (\u201cnonisochronous\u201d) pulse streams of varying duration in time signatures like 5/x, 7/x (e.g., the level of 5/4 with dotted/undotted 1/2 notes).</p> <p>It is still perfectly fine to use this for the pulse streams within those meters that are regular, equally spaced (\u201cisochronous\u201d) (e.g., the 1/4 note level of 5/4).</p> <p>The list of pulse lengths is handled internally in decreasing order, whatever the ordering in the argument.</p> <p>If <code>require_2_or_3_between_levels</code> is True (default), this functions checks that each level is either a 2 or 3 multiple of the next.</p> <p>By default, the cycle_length is taken by the longest pulse length. Alternatively, this can be user-defined to anything as long as it is</p> <ol> <li>longer than the longest pulse and</li> <li>if <code>require_2_or_3_between_levels</code> is True then exactly 2x or 3x longer.</li> </ol> <p>Parameters:</p> <ul> <li> </li> </ul> <p>Returns:</p> <ul> <li> <code>list</code>           \u2013            <p>Returns a list of lists with start positions by level.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; qsl = PulseLengths(pulse_lengths=[4, 2, 1, 0.5])\n&gt;&gt;&gt; qsl.pulse_lengths\n[4, 2, 1, 0.5]\n</code></pre> <pre><code>&gt;&gt;&gt; start_hierarchy = qsl.to_start_hierarchy()\n&gt;&gt;&gt; start_hierarchy[0]\n[0.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; start_hierarchy[1]\n[0.0, 2.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; start_hierarchy[2]\n[0.0, 1.0, 2.0, 3.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; start_hierarchy[3]\n[0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def to_start_hierarchy(\n    self,\n    require_2_or_3_between_levels: bool = False,\n):\n    \"\"\"\n    Convert a list of pulse lengths into a corresponding list of lists.\n\n    Gives start positions per metrical level.\n    All values (pulse lengths, start positions, and cycle_length)\n    are all expressed in terms of quarter length.\n\n    That is, the user provides pulse lengths for each level of a\n    metrical hierarchy, and the algorithm expands this into a hierarchy\n    assuming equal spacing (aka \u201cisochrony\u201d).\n\n    This does not work for (\u201cnonisochronous\u201d) pulse streams of varying duration\n    in time signatures like 5/x, 7/x (e.g., the level of 5/4 with\n    dotted/undotted 1/2 notes).\n\n    It is still perfectly fine to use this for the pulse streams\n    within those meters that are regular, equally spaced (\u201cisochronous\u201d)\n    (e.g., the 1/4 note level of 5/4).\n\n    The list of pulse lengths is handled internally in decreasing order,\n    whatever the ordering in the argument.\n\n    If `require_2_or_3_between_levels` is True (default), this functions\n    checks that each level is either a 2 or 3 multiple of the next.\n\n    By default, the cycle_length is taken by the longest pulse length.\n    Alternatively, this can be user-defined to anything as long as it is\n\n    1. longer than the longest pulse and\n    2. if `require_2_or_3_between_levels` is True then exactly 2x or 3x\n    longer.\n\n\n    Parameters\n    ----------\n    require_2_or_3_between_levels\n        Defaults to False.\n        If True, raise a ValueError in the case of this condition not being met.\n\n    Returns\n    -------\n    list\n        Returns a list of lists with start positions by level.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; qsl = PulseLengths(pulse_lengths=[4, 2, 1, 0.5])\n    &gt;&gt;&gt; qsl.pulse_lengths\n    [4, 2, 1, 0.5]\n\n    &gt;&gt;&gt; start_hierarchy = qsl.to_start_hierarchy()\n    &gt;&gt;&gt; start_hierarchy[0]\n    [0.0, 4.0]\n\n    &gt;&gt;&gt; start_hierarchy[1]\n    [0.0, 2.0, 4.0]\n\n    &gt;&gt;&gt; start_hierarchy[2]\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n\n    &gt;&gt;&gt; start_hierarchy[3]\n    [0.0, 0.5, 1.0, 1.5, 2.0, 2.5, 3.0, 3.5, 4.0]\n\n    \"\"\"\n\n    if require_2_or_3_between_levels:  # TODO consider refactor\n        for level in range(len(self.pulse_lengths) - 1):\n            if self.pulse_lengths[level] / self.pulse_lengths[\n                level + 1\n            ] not in [\n                2,\n                3,\n            ]:\n                raise ValueError(\n                    \"The proportion between consecutive levels is not 2 or 3 in \"\n                    f\"this case: {self.pulse_lengths[level]}:{self.pulse_lengths[level + 1]}.\"\n                )\n\n    start_list = []\n\n    for pulse_length in self.pulse_lengths:\n        starts = self.one_pulse_to_start_hierarchy_list(pulse_length)\n        start_list.append(starts)\n\n    self.start_hierarchy = start_list\n    return start_list\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths.to_start_hierarchy(require_2_or_3_between_levels)","title":"<code>require_2_or_3_between_levels</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Defaults to False. If True, raise a ValueError in the case of this condition not being met.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths.one_pulse_to_start_hierarchy_list","title":"one_pulse_to_start_hierarchy_list","text":"<pre><code>one_pulse_to_start_hierarchy_list(pulse_length: float)\n</code></pre> <p>Convert a single pulse length and cycle length into a list of starts. All expressed in quarter length.</p> <p>Note: A maximum of 4 decimal places is hardcoded. This is to avoid floating point errors or the need for one line of numpy (np.arange) in a module that doesn't otherwise use it. 4 decimal points should be sufficient for all realistic use cases.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pls = PulseLengths(pulse_lengths=[4, 2, 1, 0.5], cycle_length=4)\n&gt;&gt;&gt; pls.pulse_lengths\n[4, 2, 1, 0.5]\n</code></pre> <pre><code>&gt;&gt;&gt; pls.one_pulse_to_start_hierarchy_list(1)\n[0.0, 1.0, 2.0, 3.0, 4.0]\n</code></pre> <pre><code>&gt;&gt;&gt; pls = PulseLengths(pulse_lengths=[4, 2, 1, 0.5], cycle_length=4, include_cycle_length=False)\n&gt;&gt;&gt; pls.one_pulse_to_start_hierarchy_list(1)\n[0.0, 1.0, 2.0, 3.0]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def one_pulse_to_start_hierarchy_list(\n    self,\n    pulse_length: float,\n):\n    \"\"\"\n    Convert a single pulse length and cycle length into a list of starts.\n    All expressed in quarter length.\n\n    Note:\n    A maximum of 4 decimal places is hardcoded.\n    This is to avoid floating point errors or the need for one line of numpy (np.arange)\n    in a module that doesn't otherwise use it.\n    4 decimal points should be sufficient for all realistic use cases.\n\n    Parameters\n    --------\n    pulse_length\n        The quarter length of the pulse (note: must be shorter than the\n        `cycle_length`).\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; pls = PulseLengths(pulse_lengths=[4, 2, 1, 0.5], cycle_length=4)\n    &gt;&gt;&gt; pls.pulse_lengths\n    [4, 2, 1, 0.5]\n\n    &gt;&gt;&gt; pls.one_pulse_to_start_hierarchy_list(1)\n    [0.0, 1.0, 2.0, 3.0, 4.0]\n\n    &gt;&gt;&gt; pls = PulseLengths(pulse_lengths=[4, 2, 1, 0.5], cycle_length=4, include_cycle_length=False)\n    &gt;&gt;&gt; pls.one_pulse_to_start_hierarchy_list(1)\n    [0.0, 1.0, 2.0, 3.0]\n\n    \"\"\"\n    starts = []\n    count = 0\n    while count &lt; self.cycle_length:\n        starts.append(round(float(count), 4))\n        count += pulse_length\n\n    if self.include_cycle_length:\n        starts.append(round(float(count), 4))\n\n    return starts\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths.one_pulse_to_start_hierarchy_list(pulse_length)","title":"<code>pulse_length</code>","text":"(<code>float</code>)           \u2013            <p>The quarter length of the pulse (note: must be shorter than the <code>cycle_length</code>).</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.PulseLengths.to_array","title":"to_array","text":"<pre><code>to_array()\n</code></pre> <p>Create an array with the levels as rows, and the entries as pulse length values, where those pulse lengths start, and 0 otherwise.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; pls = PulseLengths(pulse_lengths=[4, 2, 1, 0.5], cycle_length=4)\n&gt;&gt;&gt; pls.to_array()\narray([[4. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],\n       [2. , 0. , 0. , 0. , 2. , 0. , 0. , 0. ],\n       [1. , 0. , 1. , 0. , 1. , 0. , 1. , 0. ],\n       [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]])\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def to_array(self):\n    \"\"\"\n    Create an array with the levels as rows,\n    and the entries as pulse length values,\n    where those pulse lengths start, and 0 otherwise.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; pls = PulseLengths(pulse_lengths=[4, 2, 1, 0.5], cycle_length=4)\n    &gt;&gt;&gt; pls.to_array()\n    array([[4. , 0. , 0. , 0. , 0. , 0. , 0. , 0. ],\n           [2. , 0. , 0. , 0. , 2. , 0. , 0. , 0. ],\n           [1. , 0. , 1. , 0. , 1. , 0. , 1. , 0. ],\n           [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5]])\n\n    \"\"\"\n    tatum = self.pulse_lengths[-1]\n    linear_positions = int(self.cycle_length / tatum)\n    granular_row = np.full(\n        shape=(1, linear_positions), fill_value=tatum, dtype=np.float64\n    )\n    symbolic_pulse_length_array = np.array(granular_row)\n    for pulse in self.pulse_lengths[-2::-1]:  # TODO check len?\n        multiple_of_tatum = int(pulse / tatum)\n        divider_of_cycle = int(linear_positions / multiple_of_tatum)\n        proto_row = np.zeros((1, multiple_of_tatum))\n        proto_row[0, 0] = pulse\n        row = proto_row\n        for i in range(divider_of_cycle - 1):\n            row = np.append(row, proto_row)\n        symbolic_pulse_length_array = np.vstack(\n            (row, symbolic_pulse_length_array)\n        )\n\n    return symbolic_pulse_length_array\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.BeatPattern","title":"BeatPattern","text":"<pre><code>BeatPattern(beat_list: tuple[int, ...], beat_type: int)\n</code></pre> <p>Encoding only the part of a metrical structure identified as the beat pattern.</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>beat_pattern_to_start_hierarchy</code>             \u2013              <p>Converts a list of beats</p> </li> </ul> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def __init__(\n    self,\n    beat_list: tuple[int, ...],\n    beat_type: int,\n):\n\n    self.beat_list = beat_list\n    self.beat_type = beat_type\n    self.start_time_hierarchy = self.beat_pattern_to_start_hierarchy()\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.BeatPattern(beat_list)","title":"<code>beat_list</code>","text":"(<code>tuple[int, ...]</code>)           \u2013            <p>An ordered list of the beat types.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.BeatPattern(beat_type)","title":"<code>beat_type</code>","text":"(<code>int</code>)           \u2013            <p>The lower value of a time signature to set the pulse value.</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.BeatPattern-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.representations.BeatPattern.beat_pattern_to_start_hierarchy","title":"beat_pattern_to_start_hierarchy","text":"<pre><code>beat_pattern_to_start_hierarchy(\n    include_cycle_length: bool = True,\n) -&gt; list\n</code></pre> <p>Converts a list of beats like [2, 2, 2] or [3, 3] or indeed [6, 9] into a list of within-cycle starting positions, as defined relative to the start of the cycle. Basically, the list of beats functions like the time signature's so-called \u201cnumerator\u201d, so for instance, <code>[2, 2, 3]</code> with the denominator <code>4</code> is a kind of 7/4. This equates to starting positions of <code>[0.0, 2.0, 4.0, 7.0]</code>.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; bp = BeatPattern((2, 2, 3), 4)\n&gt;&gt;&gt; bp.beat_pattern_to_start_hierarchy()\n[0.0, 2.0, 4.0, 7.0]\n</code></pre> <pre><code>&gt;&gt;&gt; bp.beat_pattern_to_start_hierarchy(include_cycle_length = False)\n[0.0, 2.0, 4.0]\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def beat_pattern_to_start_hierarchy(\n    self, include_cycle_length: bool = True\n) -&gt; list:\n    \"\"\"\n    Converts a list of beats\n    like [2, 2, 2]\n    or [3, 3]\n    or indeed\n    [6, 9]\n    into a list of within-cycle starting positions, as defined relative\n    to the start of the cycle.\n    Basically, the list of beats functions like the time signature's\n    so-called \u201cnumerator\u201d,\n    so for instance, `[2, 2, 3]` with the denominator `4` is a kind of 7/4.\n    This equates to starting positions of\n    `[0.0, 2.0, 4.0, 7.0]`.\n\n    Parameters\n    --------\n    include_cycle_length\n        If True (default) then each level ends with the full cycle length\n        (i.e., the start of the next cycle).\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; bp = BeatPattern((2, 2, 3), 4)\n    &gt;&gt;&gt; bp.beat_pattern_to_start_hierarchy()\n    [0.0, 2.0, 4.0, 7.0]\n\n    &gt;&gt;&gt; bp.beat_pattern_to_start_hierarchy(include_cycle_length = False)\n    [0.0, 2.0, 4.0]\n\n    \"\"\"\n    starts = [0.0]  # always float, always starts at zero\n    count = 0\n    for beat_val in self.beat_list:\n        count += beat_val\n        this_start = count * 4 / self.beat_type\n        starts.append(this_start)\n\n    if include_cycle_length:  # include last value\n        return starts\n    else:\n        return starts[:-1]\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.BeatPattern.beat_pattern_to_start_hierarchy(include_cycle_length)","title":"<code>include_cycle_length</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True (default) then each level ends with the full cycle length (i.e., the start of the next cycle).</p>"},{"location":"reference/time/meter/#amads.time.meter.representations.is_non_negative_integer_power_of_two","title":"is_non_negative_integer_power_of_two","text":"<pre><code>is_non_negative_integer_power_of_two(n: float) -&gt; bool\n</code></pre> <p>Checks if a number is a power of 2.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; is_non_negative_integer_power_of_two(0)\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; is_non_negative_integer_power_of_two(0.5)\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; is_non_negative_integer_power_of_two(1)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; is_non_negative_integer_power_of_two(2)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; is_non_negative_integer_power_of_two(3)\nFalse\n</code></pre> <pre><code>&gt;&gt;&gt; is_non_negative_integer_power_of_two(4)\nTrue\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def is_non_negative_integer_power_of_two(n: float) -&gt; bool:\n    \"\"\"\n    Checks if a number is a power of 2.\n\n    Examples\n    --------\n    &gt;&gt;&gt; is_non_negative_integer_power_of_two(0)\n    False\n\n    &gt;&gt;&gt; is_non_negative_integer_power_of_two(0.5)\n    False\n\n    &gt;&gt;&gt; is_non_negative_integer_power_of_two(1)\n    True\n\n    &gt;&gt;&gt; is_non_negative_integer_power_of_two(2)\n    True\n\n    &gt;&gt;&gt; is_non_negative_integer_power_of_two(3)\n    False\n\n    &gt;&gt;&gt; is_non_negative_integer_power_of_two(4)\n    True\n    \"\"\"\n    if n &lt;= 0:  # also catches type error if non-numeric\n        return False\n    if not isinstance(n, int):\n        if int(n) == n:\n            n = int(n)\n        else:\n            return False\n    return n &gt; 0 and (n &amp; (n - 1)) == 0\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.representations.switch_pulse_length_beat_type","title":"switch_pulse_length_beat_type","text":"<pre><code>switch_pulse_length_beat_type(\n    pulse_length_or_beat_type: float | ndarray,\n)\n</code></pre> <p>Switch between a pulse length and beat type. Accepts numeric values or numpy arrays thereof. Note that a float of vale 0 will raise a <code>ZeroDivisionError: division by zero</code>, but a numpy array will map any 0s to <code>inf</code> without error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; switch_pulse_length_beat_type(0.5)\n8.0\n</code></pre> <pre><code>&gt;&gt;&gt; switch_pulse_length_beat_type(8)\n0.5\n</code></pre> <pre><code>&gt;&gt;&gt; switch_pulse_length_beat_type(np.array([0.5, 8]))\narray([8. , 0.5])\n</code></pre> Source code in <code>amads/time/meter/representations.py</code> <pre><code>def switch_pulse_length_beat_type(\n    pulse_length_or_beat_type: Union[float, np.ndarray]\n):\n    \"\"\"\n    Switch between a pulse length and beat type.\n    Accepts numeric values or numpy arrays thereof.\n    Note that a float of vale 0 will raise a\n    `ZeroDivisionError: division by zero`,\n    but a numpy array will map any 0s to `inf` without error.\n\n    Examples\n    --------\n    &gt;&gt;&gt; switch_pulse_length_beat_type(0.5)\n    8.0\n\n    &gt;&gt;&gt; switch_pulse_length_beat_type(8)\n    0.5\n\n    &gt;&gt;&gt; switch_pulse_length_beat_type(np.array([0.5, 8]))\n    array([8. , 0.5])\n    \"\"\"\n    return 4 / pulse_length_or_beat_type\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.syncopation.SyncopationMetric","title":"SyncopationMetric","text":"<pre><code>SyncopationMetric(path_to_score: str | None = None)\n</code></pre> <p>times and similar).</p> <p>The parameters of this class allow users to run from a score (with onsets etc. deduced from there) or directly on their own data (the necessary parameters differ slightly for each method).</p> <p>Parameters:</p> <p>Methods:</p> <ul> <li> <code>load_note_array_from_score</code>             \u2013              <p>Parse a score and return Partitura's <code>.note_array()</code> with <code>include_metrical_position=True</code>.</p> </li> <li> <code>weighted_note_to_beat_distance</code>             \u2013              <p>TODO: WIP - does not currently replicate answers in the literature; further investigation to follow</p> </li> </ul> Source code in <code>amads/time/meter/syncopation.py</code> <pre><code>def __init__(self, path_to_score: Optional[str] = None):\n    \"\"\"\n    The methods of this class implement syncopation metrics from the\n    literature. These are typically based on simple data (note start\n    times and similar).\n\n    The parameters of this class allow users to run from a score\n    (with onsets etc. deduced from there) or directly on their own\n    data (the necessary parameters differ slightly for each method).\n\n    Parameters\n    ----------\n    path_to_score:\n        Path to the score in any supported format (e.g., MusicXML).\n        Deduce any necessary onsets, beats etc. from the score as\n        calculated by Partitura.\n        Warning: Partitura takes \u201cbeats\u201d from time signatures\n        denominators, e.g., 6/8 has 6 \u201cbeats\u201d (not 2).\n    \"\"\"\n    self.path_to_score = path_to_score\n    # TODO. TBC. May be redundant / better handled on a per-metric basis:\n    self.note_array = None\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.syncopation.SyncopationMetric(path_to_score)","title":"<code>path_to_score</code>","text":"(<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Path to the score in any supported format (e.g., MusicXML). Deduce any necessary onsets, beats etc. from the score as calculated by Partitura. Warning: Partitura takes \u201cbeats\u201d from time signatures denominators, e.g., 6/8 has 6 \u201cbeats\u201d (not 2).</p>"},{"location":"reference/time/meter/#amads.time.meter.syncopation.SyncopationMetric-functions","title":"Functions","text":""},{"location":"reference/time/meter/#amads.time.meter.syncopation.SyncopationMetric.load_note_array_from_score","title":"load_note_array_from_score","text":"<pre><code>load_note_array_from_score()\n</code></pre> <p>Parse a score and return Partitura's <code>.note_array()</code> with <code>include_metrical_position=True</code>.</p> <p>This should cover the required information. The note array's fields includes several fields of which methods here use the following (in their words):</p> <ul> <li>'onset_beat': onset time of the note in beats</li> <li>'duration_beat': duration of the note in beats</li> </ul> <p>These values are called in the form <code>note_array[\"onset_beat\"]</code>.</p> Source code in <code>amads/time/meter/syncopation.py</code> <pre><code>def load_note_array_from_score(self):\n    \"\"\"\n    Parse a score and return Partitura's `.note_array()` with `include_metrical_position=True`.\n\n    This should cover the required information.\n    The note array's fields includes several fields of which methods here\n    use the following (in their words):\n\n    * 'onset_beat': onset time of the note in beats\n    * 'duration_beat': duration of the note in beats\n\n    These values are called in the form `note_array[\"onset_beat\"]`.\n\n    \"\"\"\n    if self.note_array is not None:\n        print(\"already retrieved, skipping\")\n        return\n    if self.path_to_score is None:\n        raise ValueError(\"No score provided.\")\n    else:\n        score = load_score(self.path_to_score)\n        self.note_array = score.note_array(include_metrical_position=True)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.syncopation.SyncopationMetric.weighted_note_to_beat_distance","title":"weighted_note_to_beat_distance","text":"<pre><code>weighted_note_to_beat_distance(\n    onset_beats: list | None = None,\n) -&gt; float\n</code></pre> <p>TODO: WIP - does not currently replicate answers in the literature; further investigation to follow</p> <p>The weighted note-to-beat distance measure (WNBD) measures the distance between note starts and records the traversing of beats, and the distance to the nearest beat.</p> <p>The authors clarify that \u201cnotes are supposed to end where the next note starts\u201d, so we're working with the inter-note interval (INI), rather than the duration. Note that there are one fewer INI values than notes.</p> <p>Among the limitations is the incomplete definition of \u201cbeat\u201d and the agnostic view of metre: \u201cBy strong beats we just mean pulses.\u201d (\u00a73.4).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>WNBD value (float)</code>           \u2013            </li> </ul> <p>Examples:</p> <p>We use the example of the son clave (also available from the <code>meter.profiles</code> module), adapting to match presentation in the literature.</p> <pre><code>&gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0]\n&gt;&gt;&gt; onset_beats = vector_to_onset_beat(vector=son, beat_unit_length=4)\n&gt;&gt;&gt; sm = SyncopationMetric()\n&gt;&gt;&gt; sm.weighted_note_to_beat_distance(onset_beats=onset_beats)\nFraction(14, 5)\n</code></pre> <pre><code>&gt;&gt;&gt; hesitation = [1, 0, 1, 0, 1, 0, 0, 1]\n&gt;&gt;&gt; onset_beats = vector_to_onset_beat(vector=hesitation, beat_unit_length=4)\n&gt;&gt;&gt; sm = SyncopationMetric()\n&gt;&gt;&gt; sm.weighted_note_to_beat_distance(onset_beats=onset_beats)\nFraction(1, 2)\n</code></pre> <pre><code>&gt;&gt;&gt; from amads.music import example\n&gt;&gt;&gt; test_xml_file = str(example.fullpath(\"musicxml/ex1.xml\"))\n&gt;&gt;&gt; sm = SyncopationMetric(path_to_score=test_xml_file)\n&gt;&gt;&gt; sm.weighted_note_to_beat_distance()\nFraction(4, 3)\n</code></pre> Source code in <code>amads/time/meter/syncopation.py</code> <pre><code>def weighted_note_to_beat_distance(\n    self, onset_beats: Optional[list] = None\n) -&gt; float:\n    \"\"\"\n\n    TODO: WIP - does not currently replicate answers in the literature; further investigation to follow\n\n    The weighted note-to-beat distance measure (WNBD)\n    measures the distance between note starts and\n    records the traversing of beats, and the distance to the nearest beat.\n\n    The authors clarify that \u201cnotes are supposed to end where the\n    next note starts\u201d,\n    so we're working with the inter-note interval (INI), rather\n    than the duration.\n    Note that there are one fewer INI values than notes.\n\n    Among the limitations is the incomplete definition of \u201cbeat\u201d\n    and the agnostic view of metre:\n    \u201cBy strong beats we just mean pulses.\u201d (\u00a73.4).\n\n    Parameters\n    ----------\n    onset_beats:\n        User supplied data for the onset time of each note expressed\n        in beats. Optional.\n\n    Returns\n    -------\n    WNBD value (float)\n\n    Examples\n    --------\n    We use the example of the son clave\n    (also available from the `meter.profiles` module),\n    adapting to match presentation in the literature.\n\n    &gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0]\n    &gt;&gt;&gt; onset_beats = vector_to_onset_beat(vector=son, beat_unit_length=4)\n    &gt;&gt;&gt; sm = SyncopationMetric()\n    &gt;&gt;&gt; sm.weighted_note_to_beat_distance(onset_beats=onset_beats)\n    Fraction(14, 5)\n\n    &gt;&gt;&gt; hesitation = [1, 0, 1, 0, 1, 0, 0, 1]\n    &gt;&gt;&gt; onset_beats = vector_to_onset_beat(vector=hesitation, beat_unit_length=4)\n    &gt;&gt;&gt; sm = SyncopationMetric()\n    &gt;&gt;&gt; sm.weighted_note_to_beat_distance(onset_beats=onset_beats)\n    Fraction(1, 2)\n\n    &gt;&gt;&gt; from amads.music import example\n    &gt;&gt;&gt; test_xml_file = str(example.fullpath(\"musicxml/ex1.xml\"))\n    &gt;&gt;&gt; sm = SyncopationMetric(path_to_score=test_xml_file)\n    &gt;&gt;&gt; sm.weighted_note_to_beat_distance()\n    Fraction(4, 3)\n\n    \"\"\"\n    # onset_beats is required for user-provided,\n    if onset_beats is None:  # if not seek a score on the class\n        if self.path_to_score is not None:\n            self.load_note_array_from_score()\n            onset_beats = [\n                Fraction(float(x[\"onset_beat\"])) for x in self.note_array\n            ]  # type: ignore\n            # Sic, Fraction via first: Partitura uses np.float32 and\n            #    Fractions do not accept that type.\n            # TODO revisit class handling of this retrieval when\n            #    more algos are in\n        else:\n            raise ValueError(\"No score or user values provided.\")\n\n    per_note_syncopation_values = []\n\n    durations = [j - i for i, j in zip(onset_beats[:-1], onset_beats[1:])]\n    # Sic, although Partitura note_array provides durations,\n    #    we're using INI here.\n\n    for i in range(len(durations)):\n        onset = onset_beats[i]\n        if int(onset) == onset:  # starts on a beat\n            per_note_syncopation_values.append(0)\n        else:\n            duration = durations[i]\n            this_beat_int = int(onset)  # NB round down\n            if (\n                onset + duration &lt;= this_beat_int + 1\n            ):  # ends before or at e_{i+1}\n                numerator = 1\n            elif (\n                onset + duration &lt;= this_beat_int + 2\n            ):  # ends before or at e_{i+2}\n                numerator = 2\n            else:  # if onset + duration &gt; this_beat_int + 2: # ends after e_{i+2}\n                numerator = 1\n\n            distance_to_nearest_beat = abs(\n                round(onset) - Fraction(onset)\n            )  # Fraction\n            per_note_syncopation_values.append(\n                Fraction(numerator, distance_to_nearest_beat)\n            )\n\n    return sum(per_note_syncopation_values) / (\n        len(per_note_syncopation_values) + 1\n    )\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.syncopation.SyncopationMetric.weighted_note_to_beat_distance(onset_beats)","title":"<code>onset_beats</code>","text":"(<code>list | None</code>, default:                   <code>None</code> )           \u2013            <p>User supplied data for the onset time of each note expressed in beats. Optional.</p>"},{"location":"reference/time/meter/#amads.time.meter.syncopation.vector_to_onset_beat","title":"vector_to_onset_beat","text":"<pre><code>vector_to_onset_beat(vector: list, beat_unit_length: int = 2)\n</code></pre> <p>Map from a vector to onset beat data via <code>vector_to_multiset</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]  # Final 1 for cycle rotation\n&gt;&gt;&gt; vector_to_onset_beat(vector=son, beat_unit_length=4) # NB different beat value\n(Fraction(0, 1), Fraction(3, 4), Fraction(3, 2), Fraction(5, 2), Fraction(3, 1), Fraction(4, 1))\n</code></pre> Source code in <code>amads/time/meter/syncopation.py</code> <pre><code>def vector_to_onset_beat(vector: list, beat_unit_length: int = 2):\n    \"\"\"\n    Map from a vector to onset beat data via `vector_to_multiset`.\n\n    Examples\n    --------\n    &gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]  # Final 1 for cycle rotation\n    &gt;&gt;&gt; vector_to_onset_beat(vector=son, beat_unit_length=4) # NB different beat value\n    (Fraction(0, 1), Fraction(3, 4), Fraction(3, 2), Fraction(5, 2), Fraction(3, 1), Fraction(4, 1))\n\n    \"\"\"\n    onsets = [i for i, count in enumerate(vector) for _ in range(count)]\n    return tuple(Fraction(x, beat_unit_length) for x in onsets)\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.tatum.score_to_offsets","title":"score_to_offsets","text":"<pre><code>score_to_offsets(path_to_score: str, to_indices: bool = True) -&gt; list\n</code></pre> <p>Import a score and convert it to the sorted list of unique starting timepoints as measured in quarters since the start of the score, and (optionally) convert those starts to indices on a tatum grid.</p> <p>Note: score parsing warnings are supressed. If you need to test the validity of scores, do handle that separately.</p> <p>Parameters:</p> <p>Examples:</p> <p>If you want to suppress import warnings, then run this first.</p> <pre><code>&gt;&gt;&gt; score_path = \"https://github.com/MarkGotham/species/raw/refs/heads/main/1x1/005.mxl\"\n&gt;&gt;&gt; score_to_offsets(score_path, to_indices=False)\n[0.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0, 28.0, 32.0, 36.0, 40.0]\n&gt;&gt;&gt; score_to_offsets(score_path)\n[0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40]\n</code></pre> Source code in <code>amads/time/meter/tatum.py</code> <pre><code>def score_to_offsets(path_to_score: str, to_indices: bool = True) -&gt; list:\n    \"\"\"\n    Import a score and convert it to the sorted list of unique\n    starting timepoints as measured in quarters since the start of the score,\n    and (optionally) convert those starts to indices on a tatum grid.\n\n    Note: score parsing warnings are supressed.\n    If you need to test the validity of scores, do handle that separately.\n\n    Parameters\n    ----------\n    path_to_score\n        A string for the file path or URL.\n    to_indices\n        If True, convert the starts to indices on a tatum grid.\n\n    Examples\n    --------\n    If you want to suppress import warnings, then run this first.\n    &gt;&gt;&gt; score_path = \"https://github.com/MarkGotham/species/raw/refs/heads/main/1x1/005.mxl\"\n    &gt;&gt;&gt; score_to_offsets(score_path, to_indices=False)\n    [0.0, 4.0, 8.0, 12.0, 16.0, 20.0, 24.0, 28.0, 32.0, 36.0, 40.0]\n    &gt;&gt;&gt; score_to_offsets(score_path)\n    [0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40]\n\n    \"\"\"\n    set_reader_warning_level(\"none\")\n    score = read_score(path_to_score, show=False)\n    notes = score.get_sorted_notes()\n    timepoints = sorted(set(n.onset for n in notes))\n    if to_indices:\n        return starts_to_indices(timepoints)\n    else:\n        return timepoints\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.tatum.score_to_offsets(path_to_score)","title":"<code>path_to_score</code>","text":"(<code>str</code>)           \u2013            <p>A string for the file path or URL.</p>"},{"location":"reference/time/meter/#amads.time.meter.tatum.score_to_offsets(to_indices)","title":"<code>to_indices</code>","text":"(<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If True, convert the starts to indices on a tatum grid.</p>"},{"location":"reference/time/meter/#amads.time.meter.tatum.starts_to_indices","title":"starts_to_indices","text":"<pre><code>starts_to_indices(starts: list, tatum: Fraction = None) -&gt; list\n</code></pre> <p>Given a list of start times, convert to a list of indices on the tatum grid.</p> <p>If a tatum value is provided, use that; otherwise, deduce the tatum using gcd methods.</p> <p>This is the input format for the IMA algorithm, among others.</p> <p>Parameters:</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; starts_to_indices([0, 1/2, 2/3, 2.5])\n[0, 3, 4, 15]\n</code></pre> <pre><code>&gt;&gt;&gt; starts_to_indices([0, 1/2, 2/3, 2.5], tatum=Fraction(1, 6))\n[0, 3, 4, 15]\n</code></pre> <pre><code>&gt;&gt;&gt; starts_to_indices([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.5, 6.6640625, 6.83203125, 7.0])\n[0, 6, 12, 18, 24, 30, 36, 39, 40, 41, 42]\n</code></pre> <pre><code>&gt;&gt;&gt; starts_to_indices([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.5, 6.6640625, 6.83203125, 7.0], tatum=Fraction(1, 6))\n[0, 6, 12, 18, 24, 30, 36, 39, 40, 41, 42]\n</code></pre> <p>Also accepts tatum values greater than 1:</p> <pre><code>&gt;&gt;&gt; starts_to_indices([3, 6, 9], tatum=3)\n[1, 2, 3]\n</code></pre> <pre><code>&gt;&gt;&gt; starts_to_indices([3, 6, 9])\n[1, 2, 3]\n</code></pre> Source code in <code>amads/time/meter/tatum.py</code> <pre><code>def starts_to_indices(starts: list, tatum: Fraction = None) -&gt; list:\n    \"\"\"\n    Given a list of start times,\n    convert to a list of indices on the tatum grid.\n\n    If a tatum value is provided, use that;\n    otherwise, deduce the tatum using gcd methods.\n\n    This is the input format for the IMA algorithm, among others.\n\n    Parameters\n    ----------\n    starts\n        A list of numeric start times.\n    tatum\n        The tatum duration to use as the grid unit and values are rounded to it.\n        If None, it is\n        deduced automatically via `get_tatum_from_priorities`.\n\n    Examples\n    --------\n    &gt;&gt;&gt; starts_to_indices([0, 1/2, 2/3, 2.5])\n    [0, 3, 4, 15]\n\n    &gt;&gt;&gt; starts_to_indices([0, 1/2, 2/3, 2.5], tatum=Fraction(1, 6))\n    [0, 3, 4, 15]\n\n    &gt;&gt;&gt; starts_to_indices([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.5, 6.6640625, 6.83203125, 7.0])\n    [0, 6, 12, 18, 24, 30, 36, 39, 40, 41, 42]\n\n    &gt;&gt;&gt; starts_to_indices([0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 6.5, 6.6640625, 6.83203125, 7.0], tatum=Fraction(1, 6))\n    [0, 6, 12, 18, 24, 30, 36, 39, 40, 41, 42]\n\n    Also accepts tatum values greater than 1:\n\n    &gt;&gt;&gt; starts_to_indices([3, 6, 9], tatum=3)\n    [1, 2, 3]\n\n    &gt;&gt;&gt; starts_to_indices([3, 6, 9])\n    [1, 2, 3]\n\n    \"\"\"\n    if not starts:\n        raise ValueError(\"starts must not be empty\")\n\n    if tatum is None:\n        tatum = get_tatum_from_priorities(starts)\n\n    return [round(x / tatum) for x in starts]\n</code></pre>"},{"location":"reference/time/meter/#amads.time.meter.tatum.starts_to_indices(starts)","title":"<code>starts</code>","text":"(<code>list</code>)           \u2013            <p>A list of numeric start times.</p>"},{"location":"reference/time/meter/#amads.time.meter.tatum.starts_to_indices(tatum)","title":"<code>tatum</code>","text":"(<code>Fraction</code>, default:                   <code>None</code> )           \u2013            <p>The tatum duration to use as the grid unit and values are rounded to it. If None, it is deduced automatically via <code>get_tatum_from_priorities</code>.</p>"},{"location":"reference/time/notedensity/","title":"Note Density","text":""},{"location":"reference/time/notedensity/#amads.time.notedensity.note_density","title":"note_density","text":"<pre><code>note_density(score: Score, timetype: str | None = 'quarters') -&gt; float\n</code></pre> <p>Returns the number of notes per quarter or per second in a Score as a float.</p> <p>Specifically, compute note density as (number of notes - 1) divided by the time span from the first note onset to the last note onset. The subtraction of 1 ensures that density is measured in terms of intervals between notes. If there are no notes, return 0.0.</p> <p>Author: Tai Nakamura</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>Computed note density. Returns 0.0 if the score is empty or if all notes have the same onset time (i.e., time span equals zero).</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If <code>timetype</code> is not 'quarters' or 'seconds'.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65])  # all quarter notes\n&gt;&gt;&gt; note_density(score, timetype='quarters')\n1.0\n&gt;&gt;&gt; from amads.core.timemap import TimeMap\n&gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65])  # all quarter notes\n&gt;&gt;&gt; score.time_map = TimeMap(qpm = 120)  # set QPM to 120\n&gt;&gt;&gt; note_density(score, timetype='seconds')\n2.0\n&gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65], durations = [1.0, 2.0, 3.0, 4.0])  # mixed durations\n&gt;&gt;&gt; note_density(score, timetype='quarters')\n0.5\n</code></pre> Source code in <code>amads/time/notedensity.py</code> <pre><code>def note_density(score: Score, timetype: Optional[str] = \"quarters\") -&gt; float:\n    \"\"\"\n    Returns the number of notes per quarter or per second in a Score as a float.\n\n    Specifically, compute note density as (number of notes - 1) divided by\n    the time span from the first note onset to the last note onset.\n    The subtraction of 1 ensures that density is measured in terms\n    of intervals between notes.\n    If there are no notes, return 0.0.\n\n    &lt;small&gt;**Author**: Tai Nakamura&lt;/small&gt;\n\n    Parameters\n    ----------\n    score : Score\n        The musical score to analyze.\n    timetype : str, optional, default='quarters'\n        Time unit for calculation:\n\n        - 'quarters': notes per quarter (default)\n        - 'seconds' : notes per second\n\n    Returns\n    -------\n    float\n        Computed note density. Returns 0.0 if the score\n        is empty or if all notes have the same onset time\n        (i.e., time span equals zero).\n\n    Raises\n    ------\n    ValueError\n        If `timetype` is not 'quarters' or 'seconds'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65])  # all quarter notes\n    &gt;&gt;&gt; note_density(score, timetype='quarters')\n    1.0\n    &gt;&gt;&gt; from amads.core.timemap import TimeMap\n    &gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65])  # all quarter notes\n    &gt;&gt;&gt; score.time_map = TimeMap(qpm = 120)  # set QPM to 120\n    &gt;&gt;&gt; note_density(score, timetype='seconds')\n    2.0\n    &gt;&gt;&gt; score = Score.from_melody([60, 62, 64, 65], durations = [1.0, 2.0, 3.0, 4.0])  # mixed durations\n    &gt;&gt;&gt; note_density(score, timetype='quarters')\n    0.5\n    \"\"\"\n    notes = score.get_sorted_notes()\n    if not notes:\n        return 0.0\n\n    if timetype == \"seconds\":\n        if score.units_are_seconds:\n            start_onset = notes[0].onset\n            end_onset = notes[-1].onset\n        else:\n            start_onset = score.time_map.quarter_to_time(notes[0].onset)\n            end_onset = score.time_map.quarter_to_time(notes[-1].onset)\n    elif timetype == \"quarters\":\n        if score.units_are_seconds:\n            start_onset = score.time_map.time_to_quarter(notes[0].onset)\n            end_onset = score.time_map.time_to_quarter(notes[-1].onset)\n        else:\n            start_onset = notes[0].onset\n            end_onset = notes[-1].onset\n    else:\n        raise ValueError(\n            f\"Invalid timetype: {timetype}. Use 'quarters' or 'seconds'.\"\n        )\n    duration = end_onset - start_onset\n    if duration &lt;= 0:\n        return 0.0\n    return (len(notes) - 1) / duration\n</code></pre>"},{"location":"reference/time/notedensity/#amads.time.notedensity.note_density(score)","title":"<code>score</code>","text":"(<code>Score</code>)           \u2013            <p>The musical score to analyze.</p>"},{"location":"reference/time/notedensity/#amads.time.notedensity.note_density(timetype)","title":"<code>timetype</code>","text":"(<code>str</code>, default:                   <code>'quarters'</code> )           \u2013            <p>Time unit for calculation:</p> <ul> <li>'quarters': notes per quarter (default)</li> <li>'seconds' : notes per second</li> </ul>"},{"location":"reference/time/rhythm/","title":"Rhythm","text":""},{"location":"reference/time/rhythm/#amads.time.rhythm","title":"rhythm","text":"<p>Basic properties of rhythms, which is to say 1D representations of musical events, without measures, beats etc., and certainly no scores.</p> <p>Broadly, this is for stand-alone functions clearly intended for short, simple representations of rhythmic cycles, and is not suitable for calling on scores, for instance.</p> <p>This also includes some measures of rhythmic complexity  (which is clearly not the same as syncopation, but related, and often studied together.</p> <p>Author: Mark Gotham</p>"},{"location":"reference/time/rhythm/#amads.time.rhythm.has_oddity_property","title":"has_oddity_property","text":"<pre><code>has_oddity_property(vector: list[int] | tuple[int, ...]) -&gt; bool\n</code></pre> <p>Given a rhythm cycle (i.e., with the expectation of repetition) as a vector, check if it has Arom's \"rhythmic-oddity\" property: no two onsets partition the cycle into two equal parts. This is slightly confusing to get the right way around: the function returns <code>True</code> (i.e., yes, has the property) in the absence of this equal division.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if the rhythm has the rhythmic-oddity property, False otherwise.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; son = (1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n&gt;&gt;&gt; has_oddity_property(son)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n&gt;&gt;&gt; has_oddity_property(bemb\u00e9)\nFalse\n</code></pre> <p>And here's a simple rhythm that does have the equal division:</p> <pre><code>&gt;&gt;&gt; has_oddity_property((1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1))\nFalse\n</code></pre> <p>Note that there does not need to be any further similarity between the two halves:</p> <pre><code>&gt;&gt;&gt; has_oddity_property((1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1))\nFalse\n</code></pre> Source code in <code>amads/time/rhythm.py</code> <pre><code>def has_oddity_property(vector: Union[list[int], tuple[int, ...]]) -&gt; bool:\n    \"\"\"\n    Given a rhythm cycle (i.e., with the expectation of repetition) as a\n    vector, check if it has Arom's \"rhythmic-oddity\" property:\n    no two onsets partition the cycle into two equal parts.\n    This is slightly confusing to get the right way around:\n    the function returns `True` (i.e., yes, has the property)\n    in the _absence_ of this equal division.\n\n    Parameters\n    ----------\n    vector\n        A vector for either the event positions in the cycle time span, or\n        the beat pattern (sic, either).\n\n    Returns\n    -------\n    bool\n        True if the rhythm has the rhythmic-oddity property, False otherwise.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; son = (1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n    &gt;&gt;&gt; has_oddity_property(son)\n    True\n\n    &gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n    &gt;&gt;&gt; has_oddity_property(bemb\u00e9)\n    False\n\n    And here's a simple rhythm that does have the equal division:\n    &gt;&gt;&gt; has_oddity_property((1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1))\n    False\n\n    Note that there does not need to be any further similarity between the two halves:\n    &gt;&gt;&gt; has_oddity_property((1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1))\n    False\n\n    \"\"\"\n    if not isinstance(vector, (list, tuple)):\n        raise TypeError(\"The `vector` must be a list or tuple.\")\n\n    vector_length = len(vector)\n    if vector_length % 2 != 0:\n        return True  # By definition\n    half_length = vector_length // 2\n\n    indices = indicator_to_indices(vector)\n    indices_set = set(indices)\n    for i in indices:\n        if (i + half_length) % vector_length in indices_set:\n            return False\n\n    return True\n</code></pre>"},{"location":"reference/time/rhythm/#amads.time.rhythm.has_oddity_property(vector)","title":"<code>vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>A vector for either the event positions in the cycle time span, or the beat pattern (sic, either).</p>"},{"location":"reference/time/rhythm/#amads.time.rhythm.keith_via_toussaint","title":"keith_via_toussaint","text":"<pre><code>keith_via_toussaint(vector)\n</code></pre> <p>Although Keith's measure is described in terms of beats, it is inflexible to metric structure and fully defined by the onset pattern.</p> <p>Parameters:</p> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the vector length is not a power of 2.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0]\n&gt;&gt;&gt; keith_via_toussaint(son)\n2\n</code></pre> Source code in <code>amads/time/rhythm.py</code> <pre><code>def keith_via_toussaint(vector):\n    \"\"\"\n    Although Keith's measure is described in terms of beats,\n    it is inflexible to metric structure and fully defined by\n    the onset pattern.\n\n    Parameters\n    ----------\n    vector\n        An indicator vector whose length must be a power of 2.\n\n    Raises\n    ------\n    ValueError\n        If the vector length is not a power of 2.\n\n    Examples\n    --------\n    &gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0]\n    &gt;&gt;&gt; keith_via_toussaint(son)\n    2\n\n    \"\"\"\n    if not _is_power_of_2(len(vector)):\n        raise ValueError(\n            f\"Vector length (currently {len(vector)}) must be a power of 2.\"\n        )\n\n    indices = indicator_to_indices(vector)  # Keith/Toussaint's `S`\n    deltas = indicator_to_interval(\n        vector, wrap=True\n    )  # Keith/Toussaint also `delta`\n    powers_of_2 = [\n        _prev_power_of_2(x) for x in deltas\n    ]  # Keith/Toussaint's big D\n    count = 0\n    for i in range(len(indices)):\n        this_case = indices[i] / powers_of_2[i]\n        if int(this_case) != this_case:\n            count += 1\n    return count\n</code></pre>"},{"location":"reference/time/rhythm/#amads.time.rhythm.keith_via_toussaint(vector)","title":"<code>vector</code>","text":"\u2013            <p>An indicator vector whose length must be a power of 2.</p>"},{"location":"reference/time/rhythm/#amads.time.rhythm.has_deep_property","title":"has_deep_property","text":"<pre><code>has_deep_property(vector: list[int] | tuple[int, ...]) -&gt; bool\n</code></pre> <p>So-called \"Deep\" rhythms have distinct numbers of each interval class among all (not-necessarily adjacent) intervals. See <code>indicator_to_interval</code> with the arguments <code>wrap=True</code>, <code>adjacent_not_all=False</code>.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shiko = (1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n&gt;&gt;&gt; indicator_to_interval(shiko, wrap=True, adjacent_not_all=False)\n(0, 2, 0, 3, 0, 4, 0, 1)\n</code></pre> <p>Note the distinct numbers in the above.</p> <pre><code>&gt;&gt;&gt; has_deep_property(shiko)\nTrue\n</code></pre> <p>The son clave is not deep, since multiple interval classes share the same count:</p> <pre><code>&gt;&gt;&gt; son = (1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n&gt;&gt;&gt; has_deep_property(son)\nFalse\n</code></pre> Source code in <code>amads/time/rhythm.py</code> <pre><code>def has_deep_property(vector: Union[list[int], tuple[int, ...]]) -&gt; bool:\n    \"\"\"\n    So-called \"Deep\" rhythms have distinct numbers of each interval class\n    among all (not-necessarily adjacent) intervals.\n    See `indicator_to_interval` with the arguments `wrap=True`,\n    `adjacent_not_all=False`.\n\n    Examples\n    --------\n\n    &gt;&gt;&gt; shiko = (1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n    &gt;&gt;&gt; indicator_to_interval(shiko, wrap=True, adjacent_not_all=False)\n    (0, 2, 0, 3, 0, 4, 0, 1)\n\n    Note the distinct numbers in the above.\n\n    &gt;&gt;&gt; has_deep_property(shiko)\n    True\n\n    The son clave is not deep, since multiple interval classes share the same count:\n\n    &gt;&gt;&gt; son = (1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0)\n    &gt;&gt;&gt; has_deep_property(son)\n    False\n\n    \"\"\"\n    intervals = indicator_to_interval(vector, wrap=True, adjacent_not_all=False)\n    non_zero_uses = [x for x in intervals if x != 0]\n    return len(non_zero_uses) == len(set(non_zero_uses))\n</code></pre>"},{"location":"reference/time/rhythm/#amads.time.rhythm.off_beatness","title":"off_beatness","text":"<pre><code>off_beatness(vector: list[int] | tuple[int, ...]) -&gt; int\n</code></pre> <p>The \"off-beatness\" measure records the number of events in a rhythmic cycle at positions which cannot fall on a regular beat division of the cycle. For a more formal definition, see <code>totatives</code>.</p> <p>This function expects an indicator vector (values of 0 or 1). Behaviour with non-indicator (weighted) vectors is undefined.</p> <p>Examples:</p> <p>Gomez et al. explore 10 \"canonical\" 12-unit rhythms of which they find the Bemb\u00e9 notable for being \"the most frequently used\" and because it realizes the \"highest value of off-beatness\" among these 10.</p> <pre><code>&gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n&gt;&gt;&gt; off_beatness(bemb\u00e9)\n3\n</code></pre> <p>Looking beyond these cases, the true highest value for a 12-unit cycle is 4 (using indices 1, 5, 7, 11), as shown in the minimal case here:</p> <pre><code>&gt;&gt;&gt; off_beatness((0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1))\n4\n</code></pre> Source code in <code>amads/time/rhythm.py</code> <pre><code>def off_beatness(vector: Union[list[int], tuple[int, ...]]) -&gt; int:\n    \"\"\"\n    The \"off-beatness\" measure records the number of events in a rhythmic cycle\n    at positions which cannot fall on a regular beat division of the cycle.\n    For a more formal definition, see `totatives`.\n\n    This function expects an indicator vector (values of 0 or 1).\n    Behaviour with non-indicator (weighted) vectors is undefined.\n\n    Examples\n    --------\n\n    Gomez et al. explore 10 \"canonical\" 12-unit rhythms of which they\n    find the Bemb\u00e9 notable for being \"the most frequently used\" and\n    because it realizes the \"highest value of off-beatness\" among these 10.\n\n    &gt;&gt;&gt; bemb\u00e9 = (1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1)\n    &gt;&gt;&gt; off_beatness(bemb\u00e9)\n    3\n\n    Looking beyond these cases, the true highest value for a 12-unit\n    cycle is 4 (using indices 1, 5, 7, 11), as shown in the minimal\n    case here:\n\n    &gt;&gt;&gt; off_beatness((0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1))\n    4\n\n    \"\"\"\n    t = set(totatives(len(vector)))\n    positions = vector_to_multiset(vector)\n    return sum(1 for item in t if item in positions)\n</code></pre>"},{"location":"reference/time/rhythm/#amads.time.rhythm.totatives","title":"totatives","text":"<pre><code>totatives(n)\n</code></pre> <p>Calculates the totatives of n, which are the positive integers less than n that are relatively prime to n.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[int]</code>           \u2013            <p>A list of integers representing the totatives of n. This list is empty if n is less than or equal to 1.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; totatives(12)\n[1, 5, 7, 11]\n</code></pre> <pre><code>&gt;&gt;&gt; len(totatives(12))\n4\n</code></pre> <pre><code>&gt;&gt;&gt; totatives(16)\n[1, 3, 5, 7, 9, 11, 13, 15]\n</code></pre> <pre><code>&gt;&gt;&gt; len(totatives(16))\n8\n</code></pre> Source code in <code>amads/time/rhythm.py</code> <pre><code>def totatives(n):\n    \"\"\"\n    Calculates the totatives of n, which are the positive integers less\n    than n that are relatively prime to n.\n\n    Parameters\n    ----------\n    n : int\n        A positive integer. In the rhythmic case, this denotes cycle length.\n\n    Returns\n    -------\n    list[int]\n        A list of integers representing the totatives of n.\n        This list is empty if n is less than or equal to 1.\n\n    Examples\n    --------\n    &gt;&gt;&gt; totatives(12)\n    [1, 5, 7, 11]\n\n    &gt;&gt;&gt; len(totatives(12))\n    4\n\n    &gt;&gt;&gt; totatives(16)\n    [1, 3, 5, 7, 9, 11, 13, 15]\n\n    &gt;&gt;&gt; len(totatives(16))\n    8\n\n    \"\"\"\n    if n &lt;= 1:\n        return []\n\n    return [i for i in range(1, n) if integer_gcd_pair(n, i) == 1]\n</code></pre>"},{"location":"reference/time/rhythm/#amads.time.rhythm.totatives(n)","title":"<code>n</code>","text":"(<code>int</code>)           \u2013            <p>A positive integer. In the rhythmic case, this denotes cycle length.</p>"},{"location":"reference/time/rhythm/#amads.time.rhythm.vector_to_onset_beat","title":"vector_to_onset_beat","text":"<pre><code>vector_to_onset_beat(\n    vector: list[int] | tuple[int, ...], beat_unit_length: int = 2\n) -&gt; tuple\n</code></pre> <p>Map from a vector to onset beat data via <code>vector_to_multiset</code>.</p> <p>Parameters:</p> <p>Examples:</p> <p>The son clave in 16 subdivisions. The 17th element marks the cycle end:</p> <pre><code>&gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]\n&gt;&gt;&gt; vector_to_onset_beat(vector=son, beat_unit_length=4)\n(Fraction(0, 1), Fraction(3, 4), Fraction(3, 2), Fraction(5, 2), Fraction(3, 1), Fraction(4, 1))\n</code></pre> Source code in <code>amads/time/rhythm.py</code> <pre><code>def vector_to_onset_beat(\n    vector: Union[list[int], tuple[int, ...]], beat_unit_length: int = 2\n) -&gt; tuple:\n    \"\"\"\n    Map from a vector to onset beat data via `vector_to_multiset`.\n\n    Parameters\n    ----------\n    vector\n        An indicator vector.\n        When representing a cycle with rotation,\n        the final element should be a repeat of the first onset to mark the end of the cycle\n        (hence vectors of length `cycle_length + 1` are common here).\n    beat_unit_length\n        The number of subdivisions per beat.\n        Default is 2.\n\n    Examples\n    --------\n\n    The son clave in 16 subdivisions.\n    The 17th element marks the cycle end:\n\n    &gt;&gt;&gt; son = [1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1]\n    &gt;&gt;&gt; vector_to_onset_beat(vector=son, beat_unit_length=4)\n    (Fraction(0, 1), Fraction(3, 4), Fraction(3, 2), Fraction(5, 2), Fraction(3, 1), Fraction(4, 1))\n\n    \"\"\"\n    onsets = vector_to_multiset(vector)\n    return tuple(Fraction(x, beat_unit_length) for x in onsets)\n</code></pre>"},{"location":"reference/time/rhythm/#amads.time.rhythm.vector_to_onset_beat(vector)","title":"<code>vector</code>","text":"(<code>list[int] | tuple[int, ...]</code>)           \u2013            <p>An indicator vector. When representing a cycle with rotation, the final element should be a repeat of the first onset to mark the end of the cycle (hence vectors of length <code>cycle_length + 1</code> are common here).</p>"},{"location":"reference/time/rhythm/#amads.time.rhythm.vector_to_onset_beat(beat_unit_length)","title":"<code>beat_unit_length</code>","text":"(<code>int</code>, default:                   <code>2</code> )           \u2013            <p>The number of subdivisions per beat. Default is 2.</p>"},{"location":"reference/time/swing/","title":"Swing","text":""},{"location":"reference/time/swing/#amads.time.swing","title":"swing","text":"<p>This module implements various functions useful for analyzing swing in jazz and other genres.</p> <p>Author: Huw Cheston (2025)</p> References <ul> <li> <p>Benadon, F. (2006). Slicing the Beat: Jazz Eighth-Notes as Expressive     Microrhythm.     Ethnomusicology, 50(1), 73\u201398. https://doi.org/10.2307/20174424</p> </li> <li> <p>Corcoran, C., &amp; Frieler, K. (2021). Playing It Straight: Analyzing Jazz     Soloists\u2019 Swing Eighth-Note Distributions with the Weimar Jazz Database.     Music Perception, 38(4), 372\u2013385.     https://doi.org/10.1525/mp.2021.38.4.372</p> </li> </ul>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio","title":"beat_upbeat_ratio","text":"<pre><code>beat_upbeat_ratio(\n    beats: Iterable[float],\n    upbeats: Iterable[float],\n    log2: bool = False,\n    bounded: bool = False,\n    lower_bound: float = LOW_BUR,\n    upper_bound: float = HIGH_BUR,\n) -&gt; list[float]\n</code></pre> <p>Extracts beat-upbeat ratio (BUR) values from an array of beats and upbeats.</p> <p>The beat-upbeat ratio (BUR) is used to analyze the amount of \u201cswing\u201d in two consecutive eighth-note beat durations. It is calculated by dividing the duration of the first (\u201clong\u201d) eighth-note beat by the duration of the second (\u201cshort\u201d) eighth-note beat. A BUR value of 2 represents \u201cperfect\u201d swing (e.g., a triplet quarter note followed by a triplet eighth note), while a BUR of 1 represents \u201ceven\u201d eighth-note durations.</p> <p>The formula for BUR is:</p> <p>$\\text{BUR} = \\frac{t_{a,b} - t_{a}}{t_{b} - t_{a,b}}$, where</p> <p>$t_a$ is the beat at position $a$, $t_b$ is the beat at position $b$, and $t_{a,b}$ is the single upbeat between beats $a$ and $b$.</p> <p>The function takes two iterables of timestamps: <code>beats</code> and <code>upbeats</code>. Both lists should be unique, and missing values should not be present. The function returns an array of BUR values with a size of <code>len(beats) - 1</code>. If multiple <code>upbeats</code> are found between two consecutive <code>beats</code> or if no <code>upbeat</code> is found, the BUR for those beats will be omitted and the corresponding value will be <code>None</code>.</p> <p>Additionally, the function can calculate the $log_2$ of the BUR values, where a value of 1.0 corresponds to \u201ctriplet\u201d swing. This can be enabled by setting <code>log2=True</code>. The values can also be filtered to remove outliers by setting <code>bounded=True</code>, with the default values for the boundaries coming from Corcoran &amp; Frieler (2021).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>list[float]</code>           \u2013            <p>A list of the calculated BUR values.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n&gt;&gt;&gt; my_upbeats = [0.5, 1.75, 2.2]\n&gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats)\n[1., 3., 0.25]\n</code></pre> <pre><code>&gt;&gt;&gt; # Consecutive beats without a matching upbeat will be skipped.\n&gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n&gt;&gt;&gt; my_upbeats = [0.5, 2.2]\n&gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats)\n[1., None, 0.25]\n</code></pre> <pre><code>&gt;&gt;&gt; # Consecutive beats with multiple matching upbeats will be skipped.\n&gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n&gt;&gt;&gt; my_upbeats = [0.5, 1.5, 1.75, 1.8, 2.2]\n&gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats)\n[1., None, 0.25]\n</code></pre> <pre><code>&gt;&gt;&gt; # Filter out outlying values by setting `bounded=True`.\n&gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n&gt;&gt;&gt; my_upbeats = [0.5, 1.75, 2.99]\n&gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats, bounded=True)\n[1., 3., None]\n</code></pre> Source code in <code>amads/time/swing.py</code> <pre><code>def beat_upbeat_ratio(\n    beats: Iterable[float],\n    upbeats: Iterable[float],\n    log2: bool = False,\n    bounded: bool = False,\n    lower_bound: float = LOW_BUR,\n    upper_bound: float = HIGH_BUR,\n) -&gt; list[float]:\n    r\"\"\"\n    Extracts beat-upbeat ratio (BUR) values from an array of beats and upbeats.\n\n    The beat-upbeat ratio (BUR) is used to analyze the amount of \u201cswing\u201d in two\n    consecutive eighth-note beat durations. It is calculated by dividing the\n    duration of the first (\u201clong\u201d) eighth-note beat by the duration of the\n    second (\u201cshort\u201d) eighth-note beat. A BUR value of 2 represents \u201cperfect\u201d\n    swing (e.g., a triplet quarter note followed by a triplet eighth note),\n    while a BUR of 1 represents \u201ceven\u201d eighth-note durations.\n\n    The formula for BUR is:\n\n    $\\text{BUR} = \\frac{t_{a,b} - t_{a}}{t_{b} - t_{a,b}}$, where\n\n    $t_a$ is the beat at position $a$, $t_b$ is the beat at position $b$,\n    and $t_{a,b}$ is the single upbeat between beats $a$ and $b$.\n\n    The function takes two iterables of timestamps: `beats` and `upbeats`.\n    Both lists should be unique, and missing values should not be present.\n    The function returns an array of BUR values with a size of\n    `len(beats) - 1`. If multiple `upbeats` are found between two\n    consecutive `beats` or if no `upbeat` is found, the BUR for those\n    beats will be omitted and the corresponding value will be `None`.\n\n    Additionally, the function can calculate the $log_2$ of the\n    BUR values, where a value of 1.0 corresponds to \u201ctriplet\u201d swing.\n    This can be enabled by setting `log2=True`. The values can also\n    be filtered to remove outliers by setting `bounded=True`, with\n    the default values for the boundaries coming from Corcoran &amp;\n    Frieler (2021).\n\n    Parameters\n    ----------\n    beats : Iterable[float]\n        An array of beat timestamps. Should not overlap with `upbeats`.\n    upbeats : Iterable[float]\n        An array of upbeat timestamps.\n    log2 : bool, optional\n        If True, computes the log base 2 of BUR values, as used in [2].\n        Defaults to False.\n    bounded : bool, optional\n        If True, filters out BUR values outside the specified range.\n        Defaults to False.\n    lower_bound : float, optional\n        Lower boundary for filtering BUR values. Defaults to 0.25\n        ($log_2$ value of -2).\n    upper_bound : float, optional\n        Upper boundary for filtering BUR values. Defaults to 4.0 ($log_2$\n        value of 2).\n\n    Returns\n    -------\n    list[float]\n        A list of the calculated BUR values.\n\n    Examples\n    --------\n    &gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n    &gt;&gt;&gt; my_upbeats = [0.5, 1.75, 2.2]\n    &gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats)\n    [1., 3., 0.25]\n\n    &gt;&gt;&gt; # Consecutive beats without a matching upbeat will be skipped.\n    &gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n    &gt;&gt;&gt; my_upbeats = [0.5, 2.2]\n    &gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats)\n    [1., None, 0.25]\n\n    &gt;&gt;&gt; # Consecutive beats with multiple matching upbeats will be skipped.\n    &gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n    &gt;&gt;&gt; my_upbeats = [0.5, 1.5, 1.75, 1.8, 2.2]\n    &gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats)\n    [1., None, 0.25]\n\n    &gt;&gt;&gt; # Filter out outlying values by setting `bounded=True`.\n    &gt;&gt;&gt; my_beats = [0., 1., 2., 3.]\n    &gt;&gt;&gt; my_upbeats = [0.5, 1.75, 2.99]\n    &gt;&gt;&gt; beat_upbeat_ratio(my_beats, my_upbeats, bounded=True)\n    [1., 3., None]\n\n    \"\"\"\n\n    # Parse beats and upbeats to an array, sorting as required\n    beats = np.sort(np.array(beats))\n    upbeats = np.sort(np.array(upbeats))\n    # Validate inputs and raise an errors if required\n    _validate_bur_inputs(beats, upbeats)\n    # Match beats with upbeats and return a 2d array of shape\n    #    [[beat1, upbeat, beat2], [beat2, upbeat, beat3]]\n    matched = match_beats_and_upbeats(beats, upbeats)\n    # Raise an error if we cannot find any matches between beats and upbeats\n    if all([np.isnan(i) for i in matched[:, 1]]):\n        raise ValueError(\n            \"No matches found between beats and upbeats, cannot calculate BUR\"\n        )\n    # Calculate the BUR for upbeats between consecutive beats\n    #\n    # Use isitem() because Python 3.10 will print np.float64(...) instead of ...\n    # when the value is a numpy float:\n    burs = [\n        _bur(b1, upbeat, b2).item() if not np.isnan(upbeat) else None\n        for b1, upbeat, b2 in matched\n    ]\n    # Apply our filtering if required\n    # Filter before log_2 transform to make things simpler\n    if bounded:\n        burs = [i if lower_bound &lt; i &lt; upper_bound else None for i in burs]\n    # Express as base-2 log if required\n    if log2:\n        burs = [log2_(b) if b is not None else None for b in burs]\n    return burs\n</code></pre>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio(beats)","title":"<code>beats</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>An array of beat timestamps. Should not overlap with <code>upbeats</code>.</p>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio(upbeats)","title":"<code>upbeats</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>An array of upbeat timestamps.</p>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio(log2)","title":"<code>log2</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, computes the log base 2 of BUR values, as used in [2]. Defaults to False.</p>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio(bounded)","title":"<code>bounded</code>","text":"(<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If True, filters out BUR values outside the specified range. Defaults to False.</p>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio(lower_bound)","title":"<code>lower_bound</code>","text":"(<code>float</code>, default:                   <code>LOW_BUR</code> )           \u2013            <p>Lower boundary for filtering BUR values. Defaults to 0.25 ($log_2$ value of -2).</p>"},{"location":"reference/time/swing/#amads.time.swing.beat_upbeat_ratio(upper_bound)","title":"<code>upper_bound</code>","text":"(<code>float</code>, default:                   <code>HIGH_BUR</code> )           \u2013            <p>Upper boundary for filtering BUR values. Defaults to 4.0 ($log_2$ value of 2).</p>"},{"location":"reference/time/swing/#amads.time.swing.mean_bur","title":"mean_bur","text":"<pre><code>mean_bur(\n    beats: Iterable[float], upbeats: Iterable[float], **kwargs\n) -&gt; float\n</code></pre> <p>Calculates mean BUR (or $log_2$ BUR) given a list of beats and upbeats</p> Source code in <code>amads/time/swing.py</code> <pre><code>def mean_bur(\n    beats: Iterable[float], upbeats: Iterable[float], **kwargs\n) -&gt; float:\n    \"\"\"Calculates mean BUR (or $log_2$ BUR) given a list of beats and upbeats\"\"\"\n    # We use nanmean here as we may have null values in cases where\n    # multiple upbeats match with a single pair of beats, or where\n    # no upbeats match with a beat.\n    #     I think this makes sense to avoid the user having to chop a\n    # large list into multiple sublists depending on the presence of nans.\n    return float(np.nanmean(beat_upbeat_ratio(beats, upbeats, **kwargs)))\n</code></pre>"},{"location":"reference/time/swing/#amads.time.swing.std_bur","title":"std_bur","text":"<pre><code>std_bur(\n    beats: Iterable[float], upbeats: Iterable[float], **kwargs\n) -&gt; float\n</code></pre> <p>Calculates standard deviation BUR (or $log_2$ BUR) given a list of beats and upbeats</p> Source code in <code>amads/time/swing.py</code> <pre><code>def std_bur(\n    beats: Iterable[float], upbeats: Iterable[float], **kwargs\n) -&gt; float:\n    \"\"\"Calculates standard deviation BUR (or $log_2$ BUR) given a list of beats and upbeats\"\"\"\n    return np.nanstd(beat_upbeat_ratio(beats, upbeats, **kwargs))\n</code></pre>"},{"location":"reference/time/swing/#amads.time.swing.match_beats_and_upbeats","title":"match_beats_and_upbeats","text":"<pre><code>match_beats_and_upbeats(beats: ndarray, upbeats: ndarray) -&gt; ndarray\n</code></pre> <p>Iterates over consecutive beats and creates an array of <code>[[beat1, upbeat, beat2], [beat2, upbeat, beat3]]</code></p> Source code in <code>amads/time/swing.py</code> <pre><code>def match_beats_and_upbeats(\n    beats: np.ndarray, upbeats: np.ndarray\n) -&gt; np.ndarray:\n    \"\"\"Iterates over consecutive beats and creates an array of `[[beat1, upbeat, beat2], [beat2, upbeat, beat3]]`\"\"\"\n\n    matched = []\n    # Iterate over consecutive pairs of beats\n    for b1, b2 in zip(beats, beats[1:]):\n        # Get the upbeats that are between both pairs of beats\n        upbeat_bw = upbeats[(b1 &lt; upbeats) &amp; (upbeats &lt; b2)]\n        # Add a missing value in cases where multiple upbeats match with a single pair of beats, or no upbeats match\n        #  We do not consider cases where multiple upbeats match with a single beat, as these are not \"swing 8ths\"\n        #  Adding a missing value means that we'll have the shape len(beats) - 1\n        if len(upbeat_bw) &gt; 1 or len(upbeat_bw) == 0:\n            matched.append([b1, None, b2])\n        # This will only catch cases where we have matched a single upbeat\n        else:\n            matched.append([b1, upbeat_bw[0], b2])\n    # Create a 2d array of [[beat1, upbeat, beat2], [beat2, upbeat, beat3]]\n    return np.array(matched, dtype=float)\n</code></pre>"},{"location":"reference/time/tempo/","title":"Tempo","text":""},{"location":"reference/time/tempo/#amads.time.tempo","title":"tempo","text":"<p>This module provides functions for analyzing tempo characteristics in musical performances. It includes calculations for tempo slope, tempo drift, and tempo fluctuation.</p> <p>Author: Huw Cheston (2025)</p> References <ul> <li> <p>Cheston, H., Schlichting, J. L., Cross, I., &amp; Harrison, P. M. C. (2024).       Jazz Trio Database: Automated Annotation of Jazz Piano Trio Recordings        Processed Using Audio Source Separation. Transactions of the International       Society for Music Information Retrieval, 7(1), 144\u2013158.       https://doi.org/10.5334/tismir.186</p> </li> <li> <p>Cheston, H., Cross, I., &amp; Harrison, P. (2024). Trade-offs in Coordination Strategies       for Duet Jazz Performances Subject to Network Delay and Jitter.       Music Perception, 42(1), 48\u201372. https://doi.org/10.1525/mp.2024.42.1.48</p> </li> </ul>"},{"location":"reference/time/tempo/#amads.time.tempo.tempo_slope","title":"tempo_slope","text":"<pre><code>tempo_slope(beats: Iterable[float]) -&gt; float\n</code></pre> <p>Calculates the tempo slope for a sequence of beat timestamps.</p> <p>The tempo slope represents the overall tempo change per second in a performance. It is determined by the slope of a linear regression of instantaneous tempo against beat onset time. A negative slope indicates deceleration, while a positive slope indicates acceleration. The units are (quarter-note) beats-per-minute-per-second</p> <p>The equation is:</p> <p>$\\hat{S} = \\frac{\\sum\\limits_{i=1}^N (x_i - \\bar{x}) (y_i - \\bar{y})}{\\sum\\limits_{i=1}^N (x_i - \\bar{x})^2}$,</p> <p>where $x_i$ is the time of beat $i$ and $y_i$ is the tempo value in (quarter-note) beats-per-minute.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The computed tempo slope value.</p> </li> </ul> Source code in <code>amads/time/tempo.py</code> <pre><code>def tempo_slope(beats: Iterable[float]) -&gt; float:\n    r\"\"\"\n    Calculates the tempo slope for a sequence of beat timestamps.\n\n    The tempo slope represents the overall tempo change per second in a performance.\n    It is determined by the slope of a linear regression of instantaneous tempo against\n    beat onset time. A negative slope indicates deceleration, while a positive slope\n    indicates acceleration. The units are (quarter-note) beats-per-minute-per-second\n\n    The equation is:\n\n    $\\hat{S} = \\frac{\\sum\\limits_{i=1}^N (x_i - \\bar{x}) (y_i - \\bar{y})}{\\sum\\limits_{i=1}^N (x_i - \\bar{x})^2}$,\n\n    where $x_i$ is the time of beat $i$ and $y_i$ is the tempo value in\n    (quarter-note) beats-per-minute.\n\n    Parameters\n    ----------\n    beats : Iterable[float]\n        An iterable of beat timestamps in seconds, such as quarter-note onsets.\n\n    Returns\n    -------\n    float\n        The computed tempo slope value.\n\n    \"\"\"\n\n    return float(fit_tempo_linear_regression(beats).slope)\n</code></pre>"},{"location":"reference/time/tempo/#amads.time.tempo.tempo_slope(beats)","title":"<code>beats</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>An iterable of beat timestamps in seconds, such as quarter-note onsets.</p>"},{"location":"reference/time/tempo/#amads.time.tempo.tempo_fluctuation","title":"tempo_fluctuation","text":"<pre><code>tempo_fluctuation(beats: Iterable[float]) -&gt; float\n</code></pre> <p>Calculates the fluctuation around the overall tempo of a sequence of beats.</p> <p>Tempo fluctuation is measured as the standard deviation of the instantaneous tempo, normalized by the mean tempo. Higher values indicate greater variability in tempo.</p> <p>The equation is:</p> <p>$\\text{F} = \\dfrac{\\sqrt{\\frac{1}{N-1}  \\sum\\limits_{i=1}^N (y_i - \\bar{y})^2}}{\\bar{y}}$,</p> <p>where $y_i$ is the tempo value in (quarter-note) beats-per-minute at beat $i$.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The computed tempo fluctuation value.</p> </li> </ul> Source code in <code>amads/time/tempo.py</code> <pre><code>def tempo_fluctuation(beats: Iterable[float]) -&gt; float:\n    r\"\"\"\n    Calculates the fluctuation around the overall tempo of a sequence of beats.\n\n    Tempo fluctuation is measured as the standard deviation of the instantaneous tempo,\n    normalized by the mean tempo. Higher values indicate greater variability in tempo.\n\n    The equation is:\n\n    $\\text{F} = \\dfrac{\\sqrt{\\frac{1}{N-1}\n     \\sum\\limits_{i=1}^N (y_i - \\bar{y})^2}}{\\bar{y}}$,\n\n    where $y_i$ is the tempo value in (quarter-note) beats-per-minute at beat $i$.\n\n    Parameters\n    ----------\n    beats : Iterable[float]\n        An iterable of beat timestamps in seconds, such as quarter-note onsets.\n\n    Returns\n    -------\n    float\n        The computed tempo fluctuation value.\n\n    \"\"\"\n\n    # Compute instantaneous tempo values: this will also validate the input\n    tempos = beats_to_tempo(beats)\n    # Compute tempo fluctuation\n    # No need for np.nanstd etc. here, we won't have NaN values\n    return float(np.std(tempos) / np.mean(tempos))\n</code></pre>"},{"location":"reference/time/tempo/#amads.time.tempo.tempo_fluctuation(beats)","title":"<code>beats</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>An iterable of beat timestamps in seconds, such as quarter-note onsets.</p>"},{"location":"reference/time/tempo/#amads.time.tempo.tempo_mean","title":"tempo_mean","text":"<pre><code>tempo_mean(beats: Iterable[float])\n</code></pre> <p>Calculates the mean tempo from an iterable of timestamps in quarter-note beats-per-minute.</p> <p>The mean tempo can be calculated simply as:</p> <p>$\\bar{y} = \\dfrac{\\sum\\limits_{i=1}^N\\frac{60}{x_i - x_{i-1}}}{N-1}$</p> <p>where $x_i$ is the time of beat $i$ (and $i \\geq 1$) and $N$ is the number of beats.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>The computed mean tempo value.</p> </li> </ul> Source code in <code>amads/time/tempo.py</code> <pre><code>def tempo_mean(beats: Iterable[float]):\n    r\"\"\"\n    Calculates the mean tempo from an iterable of timestamps in quarter-note beats-per-minute.\n\n    The mean tempo can be calculated simply as:\n\n    $\\bar{y} = \\dfrac{\\sum\\limits_{i=1}^N\\frac{60}{x_i - x_{i-1}}}{N-1}$\n\n    where $x_i$ is the time of beat $i$ (and $i \\geq 1$) and $N$ is the number of beats.\n\n    Parameters\n    ----------\n    beats : Iterable[float]\n        An iterable of beat timestamps in seconds, such as quarter-note onsets.\n\n    Returns\n    -------\n    float\n        The computed mean tempo value.\n\n    \"\"\"\n\n    return np.mean(beats_to_tempo(beats))\n</code></pre>"},{"location":"reference/time/tempo/#amads.time.tempo.tempo_mean(beats)","title":"<code>beats</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>An iterable of beat timestamps in seconds, such as quarter-note onsets.</p>"},{"location":"reference/time/tempo/#amads.time.tempo.beats_to_tempo","title":"beats_to_tempo","text":"<pre><code>beats_to_tempo(beats: ndarray) -&gt; ndarray\n</code></pre> <p>Converts beat timestamps to instantaneous tempo measurements.</p> Source code in <code>amads/time/tempo.py</code> <pre><code>def beats_to_tempo(beats: np.ndarray) -&gt; np.ndarray:\n    \"\"\"Converts beat timestamps to instantaneous tempo measurements.\"\"\"\n\n    # Raise error on invalid inputs\n    _validate_beats(beats)\n    return np.array(60 / np.diff(beats))\n</code></pre>"},{"location":"reference/time/tempo/#amads.time.tempo.fit_tempo_linear_regression","title":"fit_tempo_linear_regression","text":"<pre><code>fit_tempo_linear_regression(beats: Iterable[float])\n</code></pre> <p>Fits linear regression of BPM measurements vs. onset time.</p> Source code in <code>amads/time/tempo.py</code> <pre><code>def fit_tempo_linear_regression(beats: Iterable[float]):\n    \"\"\"Fits linear regression of BPM measurements vs. onset time.\"\"\"\n\n    from scipy.stats import linregress\n\n    # Target variable: BPM measurements\n    # This will also validate the input\n    beats_arr = np.array(beats)\n    y = beats_to_tempo(beats_arr)\n    # Predictor variable: the onset time\n    x = beats_arr[1:]\n    return linregress(x, y)\n</code></pre>"},{"location":"reference/time/variability/","title":"Variability","text":""},{"location":"reference/time/variability/#amads.time.variability","title":"variability","text":"<p>Time variability.</p> <p>This module provides various functions for calculating rhythmic variability in music, including the normalized pairwise variability index (nPVI) and variations thereof.</p> <p>Author: Huw Cheston (2025)</p> References <ul> <li> <p>Daniele, J. R., &amp; Patel, A. D. (2013). An Empirical Study of     Historical Patterns in Musical Rhythm. Music Perception, 31(1), 10-18.       https://doi.org/10.1525/mp.2013.31.1.10</p> </li> <li> <p>Condit-Schultz, N. (2019). Deconstructing the nPVI: A Methodological     Critique of the Normalized Pairwise Variability Index as Applied to     Music. Music Perception,     36(3), 300\u2013313. https://doi.org/10.1525/mp.2019.36.3.300</p> </li> <li> <p>VanHandel, L., &amp; Song, T. (2010). The role of meter in compositional style     in 19th-century French and German art song. Journal of New Music     Research, 39, 1\u201311. https://doi.org/10.1080/09298211003642498</p> </li> </ul>"},{"location":"reference/time/variability/#amads.time.variability.normalized_pairwise_variability_index","title":"normalized_pairwise_variability_index","text":"<pre><code>normalized_pairwise_variability_index(\n    durations: Iterable[float],\n) -&gt; float\n</code></pre> <p>Calculates the normalised pairwise variability index (nPVI).</p> <p>The nPVI is a measure of variability between successive elements in a sequence. The equation is:</p> <p>$\\text{nPVI} = \\frac{100}{m-1} \\times \\sum\\limits_{k=1}^{m-1} \\left| \\frac{d_k - d_{k+1}}{\\frac{d_k + d_{k+1}}{2}} \\right|$</p> <p>where $m$ is the number of intervals, and $d_k$ is the duration of the $k^{th}$ interval.</p> <p>A completely regular stream of equal durations returns 0 variability. High difference between successive items returns a high nPVI value irrespective of other (e.g., metrical) considerations.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code>           \u2013            <p>the extracted nPVI value.</p> </li> </ul> <p>Examples:</p> <p>A completely regular stream of equal durations returns 0 variability.</p> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([1., 1., 1., 1.])\n0.\n</code></pre> <p>This example is from Daniele &amp; Patel (2013, Appendix).</p> <pre><code>&gt;&gt;&gt; durs = [1., 1/2, 1/2, 1., 1/2, 1/2, 1/3, 1/3, 1/3, 2., 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 3/2, 1., 1/2]\n&gt;&gt;&gt; x = normalized_pairwise_variability_index(durations=durs)\n&gt;&gt;&gt; round(x, 1)\n42.2\n</code></pre> <p>These next examples are from Condit-Schultz's 2019 critique (Figure 2).</p> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([0.25, 0.25, 0.25, 0.25, 1., 0.25, 0.25, 0.25, 0.25, 1.])\n40.\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([0.25, 0.25, 0.5, 1., 0.25, 0.25, 0.5, 1.])\n55.2\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([0.5, 0.25, 0.25, 1., 0.5, 0.25, 0.25, 1.])\n62.8\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([2, 1, 2, 1])\n66.66\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([0.5, 1, 2, 1, 0.5])\n66.66\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_variability_index([2, 1, 0.5, 1, 0.5, 0.25])\n66.66\n</code></pre> Source code in <code>amads/time/variability.py</code> <pre><code>def normalized_pairwise_variability_index(\n    durations: Iterable[float],\n) -&gt; float:\n    r\"\"\"\n    Calculates the normalised pairwise variability index (nPVI).\n\n    The nPVI is a measure of variability between successive elements\n    in a sequence. The equation is:\n\n    $\\text{nPVI} = \\frac{100}{m-1} \\times \\sum\\limits_{k=1}^{m-1}\n    \\left| \\frac{d_k - d_{k+1}}{\\frac{d_k + d_{k+1}}{2}} \\right|$\n\n    where $m$ is the number of intervals, and $d_k$ is the duration\n    of the $k^{th}$ interval.\n\n    A completely regular stream of equal durations returns 0 variability.\n    High difference between successive items returns a high nPVI value\n    irrespective of other (e.g., metrical) considerations.\n\n    Parameters\n    ----------\n    durations : Iterable[float]\n        the durations to analyse\n\n    Returns\n    -------\n    float\n        the extracted nPVI value.\n\n    Examples\n    -------\n\n    A completely regular stream of equal durations returns 0 variability.\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([1., 1., 1., 1.])\n    0.\n\n    This example is from Daniele &amp; Patel (2013, Appendix).\n\n    &gt;&gt;&gt; durs = [1., 1/2, 1/2, 1., 1/2, 1/2, 1/3, 1/3, 1/3, 2., 1/3, 1/3, 1/3, 1/3, 1/3, 1/3, 3/2, 1., 1/2]\n    &gt;&gt;&gt; x = normalized_pairwise_variability_index(durations=durs)\n    &gt;&gt;&gt; round(x, 1)\n    42.2\n\n    These next examples are from Condit-Schultz's 2019 critique (Figure 2).\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([0.25, 0.25, 0.25, 0.25, 1., 0.25, 0.25, 0.25, 0.25, 1.])\n    40.\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([0.25, 0.25, 0.5, 1., 0.25, 0.25, 0.5, 1.])\n    55.2\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([0.5, 0.25, 0.25, 1., 0.5, 0.25, 0.25, 1.])\n    62.8\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([2, 1, 2, 1])\n    66.66\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([0.5, 1, 2, 1, 0.5])\n    66.66\n\n    &gt;&gt;&gt; normalized_pairwise_variability_index([2, 1, 0.5, 1, 0.5, 0.25])\n    66.66\n    \"\"\"\n\n    _validate_inputs(durations)\n    numerator = (\n        sum(\n            [\n                abs((k - k1) / ((k + k1) / 2))\n                for (k, k1) in zip(durations, durations[1:])\n            ]\n        )\n        * 100\n    )\n    denominator = len(durations) - 1\n    return numerator / denominator\n</code></pre>"},{"location":"reference/time/variability/#amads.time.variability.normalized_pairwise_variability_index(durations)","title":"<code>durations</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>the durations to analyse</p>"},{"location":"reference/time/variability/#amads.time.variability.normalized_pairwise_calculation","title":"normalized_pairwise_calculation","text":"<pre><code>normalized_pairwise_calculation(\n    durations: Iterable[float],\n) -&gt; list[float]\n</code></pre> <p>Calculates the normalized pairwise calculation (nPC) for a list of durations, as defined by Condit-Schultz (2019).</p> <p>The nPVI is equivalent to the arithmetic mean of a set of nPC values. The equation for nPC can be written as:</p> <p>$\\text{nPC} = 200 * \\biggl{|} \\frac{\\text{antecedent IOI} -                                     \\text{consequent IOI}}     {\\text{antecedent IOI} + \\text{consequent IOI}} \\biggr{|}$</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>Iterable[float]</code>           \u2013            <p>the extracted nPC value(s) for every pair of antecedent-consequent durations</p> </li> </ul> <p>Examples:</p> <p>From Condit-Schultz (2019) figure 3.</p> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 15])\n[175.]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 7])\n[150.]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 5])\n[133.33]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 4])\n[120.]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 3])\n[100.]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 2])\n[66.67]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([2, 3])\n[40.]\n</code></pre> <pre><code>&gt;&gt;&gt; normalized_pairwise_calculation([1, 1])\n[0.]\n</code></pre> Source code in <code>amads/time/variability.py</code> <pre><code>def normalized_pairwise_calculation(durations: Iterable[float]) -&gt; list[float]:\n    r\"\"\"\n    Calculates the normalized pairwise calculation (nPC) for a list of\n    durations, as defined by Condit-Schultz (2019).\n\n    The nPVI is equivalent to the arithmetic mean of a set of nPC values.\n    The equation for nPC can be written as:\n\n    $\\text{nPC} = 200 * \\biggl{|} \\frac{\\text{antecedent IOI} -\n                                        \\text{consequent IOI}}\n        {\\text{antecedent IOI} + \\text{consequent IOI}} \\biggr{|}$\n\n    Parameters\n    ----------\n    durations : Iterable[float]\n        the durations to analyse\n\n    Returns\n    -------\n    Iterable[float]\n        the extracted nPC value(s) for every pair of\n        antecedent-consequent durations\n\n    Examples\n    --------\n\n    From Condit-Schultz (2019) figure 3.\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 15])\n    [175.]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 7])\n    [150.]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 5])\n    [133.33]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 4])\n    [120.]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 3])\n    [100.]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 2])\n    [66.67]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([2, 3])\n    [40.]\n\n    &gt;&gt;&gt; normalized_pairwise_calculation([1, 1])\n    [0.]\n\n    \"\"\"\n\n    _validate_inputs(durations)\n    return [\n        _normalized_pairwise_calculation(a_ioi, c_ioi)\n        for a_ioi, c_ioi in zip(durations, durations[1:])\n    ]\n</code></pre>"},{"location":"reference/time/variability/#amads.time.variability.normalized_pairwise_calculation(durations)","title":"<code>durations</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>the durations to analyse</p>"},{"location":"reference/time/variability/#amads.time.variability.isochrony_proportion","title":"isochrony_proportion","text":"<pre><code>isochrony_proportion(durations: Iterable[float]) -&gt; float\n</code></pre> <p>Calculates the isochrony proportion (IsoP) for a list of durations, as defined in Condit-Schultz (2019): \"by iterating over every pair of successive IOIs in a rhythm, counting the pairs that are identical, and dividing this count by the total number of pairs (one less than the total number of IOIs).\"</p> <p>Condit-Schultz 2019 demonstrates that the IsoP accounts for a large degree of the variance in the nPVI.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>the extracted IsoP value</code> )          \u2013            </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; isochrony_proportion([1, 1, 2, 2, 1, 0.5])\n0.4\n</code></pre> Source code in <code>amads/time/variability.py</code> <pre><code>def isochrony_proportion(\n    durations: Iterable[float],\n) -&gt; float:\n    r\"\"\"\n    Calculates the isochrony proportion (IsoP) for a list of durations, as defined in Condit-Schultz (2019):\n    \"by iterating over every pair of successive IOIs in a rhythm,\n    counting the pairs that are identical,\n    and dividing this count by the total number of pairs (one less than the total number of IOIs).\"\n\n    Condit-Schultz 2019 demonstrates that the IsoP accounts for a large degree of the variance in the nPVI.\n\n    Parameters\n    ----------\n    durations (Iterable[float]): the durations to analyse\n\n    Returns\n    -------\n    float: the extracted IsoP value\n\n    Examples\n    --------\n    &gt;&gt;&gt; isochrony_proportion([1, 1, 2, 2, 1, 0.5])\n    0.4\n\n    \"\"\"\n\n    _validate_inputs(durations)\n    isochronous = 0\n    # Iterate over every pair of successive IOIs in a rhythm\n    for a1, a2 in zip(durations, durations[1:]):\n        # If both IOIs are the same\n        if math.isclose(a1, a2, abs_tol=TINY):\n            # Increase the counter by one\n            isochronous += 1\n    # Divide the counter by the total number of pairs (one less than the total number of IOIs)\n    denominator = len(durations) - 1\n    return isochronous / denominator\n</code></pre>"},{"location":"reference/time/variability/#amads.time.variability.isochrony_proportion(durations)","title":"<code>durations</code>","text":"(<code>Iterable[float]</code>)           \u2013"},{"location":"reference/time/variability/#amads.time.variability.pairwise_anisochronous_contrast_index","title":"pairwise_anisochronous_contrast_index","text":"<pre><code>pairwise_anisochronous_contrast_index(\n    durations: Iterable[float],\n) -&gt; float\n</code></pre> <p>Calculates the pairwise anisochronous contrast index (pACI) for a list of durations.</p> <p>Defined in Condit-Schultz (2019), the pACI is equivalent to the nPVI, except that it \"factors out\" isochronous pairs of IOIs. This means that it is sensitive to changes in the frequencies of IOIs pairs such as 2:1, 3:1, without being \"overwhelmed by isochronous pairs\" (1:1).</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>the extracted pACI value</code> )          \u2013            </li> </ul> Source code in <code>amads/time/variability.py</code> <pre><code>def pairwise_anisochronous_contrast_index(\n    durations: Iterable[float],\n) -&gt; float:\n    r\"\"\"\n    Calculates the pairwise anisochronous contrast index (pACI) for a list of durations.\n\n    Defined in Condit-Schultz (2019), the pACI is equivalent to the nPVI,\n    except that it \"factors out\" isochronous pairs of IOIs.\n    This means that it is sensitive to changes in the frequencies of IOIs pairs such as 2:1, 3:1, without\n    being \"overwhelmed by isochronous pairs\" (1:1).\n\n    Parameters\n    ----------\n    durations (Iterable[float]): the durations to analyse\n\n    Returns\n    -------\n    float: the extracted pACI value\n\n    \"\"\"\n\n    _validate_inputs(durations)\n    all_npcs = []\n    # Iterate over successive IOIs\n    for a1, a2 in zip(durations, durations[1:]):\n        # If the two IOIs are NOT isochronous\n        if not math.isclose(a1, a2, abs_tol=TINY):\n            # Calculate the nPC for this pair of durations\n            npc = _normalized_pairwise_calculation(a1, a2)\n            all_npcs.append(npc)\n    # Raise errors as required\n    if len(all_npcs) == 0:\n        raise ValueError(\n            \"No non-isochronous pairs were found, cannot calculate pACI.\"\n        )\n    # Return the average\n    return sum(all_npcs) / len(all_npcs)\n</code></pre>"},{"location":"reference/time/variability/#amads.time.variability.pairwise_anisochronous_contrast_index(durations)","title":"<code>durations</code>","text":"(<code>Iterable[float]</code>)           \u2013"},{"location":"reference/time/variability/#amads.time.variability.phrase_normalized_pairwise_variability_index","title":"phrase_normalized_pairwise_variability_index","text":"<pre><code>phrase_normalized_pairwise_variability_index(\n    durations: Iterable[float], phrase_boundaries: Iterable[float]\n) -&gt; float\n</code></pre> <p>Calculates the phrase-normalized pairwise variability index (pnPVI), as defined by VanHandel &amp; Song (2010).</p> <p>The pnNPVI calculates the nPVI, ignoring cases where pairs of IOIs straddle a phrase boundary. To do so, we also need a list of times for where those phrase boundaries fall.</p> <p>Parameters:</p> <p>Returns:</p> <ul> <li> <code>float</code> (              <code>the extracted pnNPVI value</code> )          \u2013            </li> </ul> Source code in <code>amads/time/variability.py</code> <pre><code>def phrase_normalized_pairwise_variability_index(\n    durations: Iterable[float],\n    phrase_boundaries: Iterable[float],\n) -&gt; float:\n    r\"\"\"\n    Calculates the phrase-normalized pairwise variability index (pnPVI), as defined by VanHandel &amp; Song (2010).\n\n    The pnNPVI calculates the nPVI, ignoring cases where pairs of IOIs straddle a phrase boundary.\n    To do so, we also need a list of times for where those phrase boundaries fall.\n\n    Parameters\n    ----------\n    durations (Iterable[float]): the durations to analyse\n        phrase_boundaries (Iterable[float]): the phrase boundaries to analyse\n\n    Returns\n    -------\n    float: the extracted pnNPVI value\n\n    \"\"\"\n\n    # Validate all inputs\n    _validate_inputs(durations)\n    _validate_inputs(\n        phrase_boundaries, _kind=\"phrase boundaries\", _min=1\n    )  # need at least one phrase boundary\n    # We use the \"counter\" to keep track of where we are in the phrase\n    counter = 0\n    all_npcs = []\n    # Iterate over pairs of IOIs\n    for a1, a2 in zip(durations, durations[1:]):\n        # This is where we \"end\" the current boundary: add both IOIs to the counter\n        end_pos = counter + a1 + a2\n        # If we're not straddling any of the phrase boundaries\n        if not any([counter &lt;= pb &lt;= end_pos for pb in phrase_boundaries]):\n            # Calculate the nPC\n            npc = _normalized_pairwise_calculation(a1, a2)\n            all_npcs.append(npc)\n        # Add the first IOI to the counter to move forwards in time for the next pair\n        counter += a1\n    # Raise errors as required\n    if len(all_npcs) == 0:\n        raise ValueError(\n            \"All pairs of IOIs cross phrase boundaries, cannot calculate pnNPVI.\"\n        )\n    # Return the average of all nPC values\n    return sum(all_npcs) / len(all_npcs)\n</code></pre>"},{"location":"reference/time/variability/#amads.time.variability.phrase_normalized_pairwise_variability_index(durations)","title":"<code>durations</code>","text":"(<code>Iterable[float]</code>)           \u2013            <p>phrase_boundaries (Iterable[float]): the phrase boundaries to analyse</p>"},{"location":"user_guide/installation/","title":"Installation","text":""},{"location":"user_guide/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.8 or higher</li> <li>Git</li> </ul>"},{"location":"user_guide/installation/#installation-steps","title":"Installation Steps","text":"<ol> <li>Clone the repository:</li> </ol> <pre><code>git clone https://github.com/music-computing/amads.git\ncd toolkit\n</code></pre> <ol> <li>Create and activate a virtual environment:</li> </ol> <pre><code># Create virtual environment\npython -m venv venv\n\n# Activate virtual environment\n# On Windows:\nvenv\\Scripts\\activate\n# On macOS/Linux:\nsource venv/bin/activate\n</code></pre> <ol> <li>Install the package in editable mode:</li> </ol> <pre><code># Basic installation\npip install -e .\n\n# If you plan to contribute to the codebase\npip install -e \".[dev]\"\npre-commit install\n</code></pre> <p>Your installation is now complete! The package is installed in editable mode, which means any changes you make to the source code will be reflected immediately without needing to reinstall.</p> <p>Note: If you plan to build the documentation or contribute to development, use the second installation command with <code>[dev]</code> which includes additional dependencies like mkdocs and other documentation tools.</p>"}]}